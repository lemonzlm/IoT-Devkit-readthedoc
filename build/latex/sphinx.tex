%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,12pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{xeCJK}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small,formatcom=\xeCJKVerbAddon}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\usepackage{xeCJK}
\setCJKmainfont[BoldFont=STZhongsong, ItalicFont=STKaiti]{STSong}
\setCJKsansfont[BoldFont=STHeiti]{STXihei}
\setCJKmonofont{STFangsong}
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt
\parindent 2em
\definecolor{VerbatimColor}{rgb}{0.95,0.95,0.95}
\setcounter{tocdepth}{3}
\renewcommand\familydefault{\ttdefault}
\renewcommand\CJKfamilydefault{\CJKrmdefault}


\title{物联网关键技术以及智能医疗物理网实验指导书}
\date{2023 年 09 月 17 日}
\release{0.2}
\author{作者： 张利民}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{发布}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{IoT实验箱与前置知识准备}
\label{\detokenize{dev-board/index:iot}}\label{\detokenize{dev-board/index::doc}}
\sphinxAtStartPar
本章介绍如下几个部分：
\begin{itemize}
\item {} 
\sphinxAtStartPar
实验箱的物理构成与系统结构。

\item {} 
\sphinxAtStartPar
集成开发环境

\item {} 
\sphinxAtStartPar
相关MCU的基础知识

\item {} 
\sphinxAtStartPar
Clion项目工程的基础知识

\item {} 
\sphinxAtStartPar
ESP\sphinxhyphen{}IDF SDK 基础知识

\end{itemize}

\sphinxstepscope


\section{低功耗节点实验箱}
\label{\detokenize{dev-board/arch:id1}}\label{\detokenize{dev-board/arch::doc}}
\sphinxAtStartPar
本教程所描述的iot实验系统包含如下几个部分，基本涵盖了iot领域的主要技术内容。
\begin{itemize}
\item {} 
\sphinxAtStartPar
节点设备
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT

\item {} 
\sphinxAtStartPar
B\sphinxhyphen{}L475\sphinxhyphen{}IOT01A

\end{itemize}

\item {} 
\sphinxAtStartPar
LoRa网关

\item {} 
\sphinxAtStartPar
iot平台

\end{itemize}

\sphinxAtStartPar
涉及到的主要Iot技术包含：
\begin{itemize}
\item {} 
\sphinxAtStartPar
感知层：涉及温度，湿度，3轴磁力计，3D加速度计，3D陀螺仪，数字气压计，浓度时间和姿势检测，手势识别，运动检测等十余种传感器数据采集

\item {} 
\sphinxAtStartPar
识别层：NFC

\item {} 
\sphinxAtStartPar
网络层：WiFi，Bluetooth，BLE，lora，nb\sphinxhyphen{}iot，

\item {} 
\sphinxAtStartPar
平台：emqx，chirpstack，TTN，thingsboard。

\item {} 
\sphinxAtStartPar
支持接入协议：mqtt，coap，http

\end{itemize}

\sphinxAtStartPar
实验系统的架构如下图所示：

\sphinxAtStartPar
\sphinxincludegraphics{{architecture}.png}


\subsection{1  节点设备\sphinxhyphen{}实验箱}
\label{\detokenize{dev-board/arch:id2}}
\sphinxAtStartPar
节点设备由两个MCU为主线，分别包含其各自的外围设备，具体包括如下几个部分。
\begin{itemize}
\item {} 
\sphinxAtStartPar
B\sphinxhyphen{}L475E\sphinxhyphen{}IOT01A

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
MUC
&\sphinxstyletheadfamily 
\sphinxAtStartPar
STM32BL475E
&\sphinxstyletheadfamily 
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
Bluetooth
&
\sphinxAtStartPar
SPBTLE\sphinxhyphen{}RF
&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
WiFi
&
\sphinxAtStartPar
INVENTEK
&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
NFC
&
\sphinxAtStartPar
M24SR
&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
microphone
&
\sphinxAtStartPar
MP34DT01
&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
sensors
&
\sphinxAtStartPar
若干
&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
接口
&
\sphinxAtStartPar
arduino，PMOD，micro usb
&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
debuge
&
\sphinxAtStartPar
ST Link
&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
LoRA
&
\sphinxAtStartPar
RAK3172
&
\sphinxAtStartPar
外置，UART
\\
\hline
\sphinxAtStartPar
IDE
&
\sphinxAtStartPar
STM32CUBE, Keil，IAR，Arm Mbed
&
\sphinxAtStartPar

\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
MCU
&\sphinxstyletheadfamily 
\sphinxAtStartPar
ESP32
&\sphinxstyletheadfamily 
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
Bluetooth
&
\sphinxAtStartPar
on chip
&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
WiFi
&
\sphinxAtStartPar
on chip
&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
SD卡
&
\sphinxAtStartPar

&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
摄像头
&
\sphinxAtStartPar

&
\sphinxAtStartPar
外置
\\
\hline
\sphinxAtStartPar
LCD
&
\sphinxAtStartPar
3.2“ SPI
&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
接口
&
\sphinxAtStartPar
micro usb，
&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
JTAG
&
\sphinxAtStartPar
JTAG PROG
&
\sphinxAtStartPar
板载
\\
\hline
\sphinxAtStartPar
LoRA
&
\sphinxAtStartPar
RAK3172
&
\sphinxAtStartPar
外置
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
节点设备概念图如下：

\sphinxAtStartPar
\sphinxincludegraphics{{lw-node}.png}


\subsubsection{1.1 ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT}
\label{\detokenize{dev-board/arch:esp-wrover-kit}}
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/hw-reference/esp32/get-started-wrover-kit.html}{ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT} 是 \sphinxhref{https://espressif.com/}{乐鑫}的一款基于 \sphinxhref{https://www.espressif.com/zh-hans/products/socs/esp32}{ESP32} 芯片的开发板。ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 开发板已集成了如下组件：
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP32\sphinxhyphen{}WROVER\sphinxhyphen{}E 模组

\item {} 
\sphinxAtStartPar
LCD 屏

\item {} 
\sphinxAtStartPar
microSD 卡槽

\item {} 
\sphinxAtStartPar
双USB, 一个用于通信，一个用于debug

\item {} 
\sphinxAtStartPar
内置调试器

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{实物图：}

\sphinxAtStartPar
\sphinxincludegraphics{{esp-wrover-kit}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{esp-wrover-kit-1}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{esp-worver-kit-3}.png}

\sphinxAtStartPar
\sphinxstylestrong{布局}

\sphinxAtStartPar
\sphinxincludegraphics{{esp-kit-layout}.png}

\sphinxAtStartPar
\sphinxstylestrong{功能框图}

\sphinxAtStartPar
\sphinxincludegraphics{{structure}.png}

\sphinxAtStartPar
\sphinxstylestrong{电路原理图：}

\sphinxAtStartPar
\DUrole{xref,download,myst}{ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT\_V4\_1\sphinxhyphen{}3.pdf}

\sphinxAtStartPar
功能说明请参见\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/hw-reference/esp32/get-started-wrover-kit.html}{官方网页}

\sphinxAtStartPar
\sphinxstylestrong{开发环境}
\begin{itemize}
\item {} 
\sphinxAtStartPar
官方环境：eclipse based  ide

\item {} 
\sphinxAtStartPar
VS Code + esp\sphinxhyphen{}idf plugin

\item {} 
\sphinxAtStartPar
VS Code + platformio

\item {} 
\sphinxAtStartPar
Clion

\end{itemize}


\subsubsection{1.2 B\sphinxhyphen{}L475E\sphinxhyphen{}IOT01A}
\label{\detokenize{dev-board/arch:b-l475e-iot01a}}
\sphinxAtStartPar
\sphinxstylestrong{描述}

\sphinxAtStartPar
\sphinxhref{https://www.st.com/zh/evaluation-tools/b-l475e-iot01a.html}{B\sphinxhyphen{}L475E\sphinxhyphen{}IOT01A}物联网节点探索套件允许用户开发与云服务器直接连接的应用程序。

\sphinxAtStartPar
该探索套件利用低功耗通信、多路传感和基于Arm® Cortex® \sphinxhyphen{}M4内核的STM32L4系列功能，支持广泛的应用。
它可支持Arduino Uno V3和PMOD连接，借助大量可选的专用附加板，能够实现无限扩展功能。

\sphinxAtStartPar
\sphinxstylestrong{所有功能}
\begin{itemize}
\item {} 
\sphinxAtStartPar
超低功耗STM32L4系列MCU基于Arm® Cortex®\sphinxhyphen{}M4内核，具有1 MB的Flash存储器和128 KB的RAM，并采用LQFP100封装

\item {} 
\sphinxAtStartPar
64 Mbit的Quad\sphinxhyphen{}SPI（Macronix）闪存

\item {} 
\sphinxAtStartPar
Bluetooth® V4.1模块（SPBTLE\sphinxhyphen{}RF）

\item {} 
\sphinxAtStartPar
Sub\sphinxhyphen{}GHz（868 MHz或915 MHz）低功耗可编程RF模块（SPSGRF\sphinxhyphen{}868或SPSGRF\sphinxhyphen{}915）

\item {} 
\sphinxAtStartPar
符合802.11 b/g/n规范的Wi\sphinxhyphen{}Fi®模块来自Inventek Systems（ISM43362\sphinxhyphen{}M3G\sphinxhyphen{}L44）

\item {} 
\sphinxAtStartPar
基于M24SR及其印刷NFC天线的动态NFC标签

\item {} 
\sphinxAtStartPar
2个全向数字麦克风(MP34DT01)

\item {} 
\sphinxAtStartPar
用于相对湿度和温度测量的电容式数字传感器（HTS221）

\item {} 
\sphinxAtStartPar
高性能3轴磁力计（LIS3MDL）

\item {} 
\sphinxAtStartPar
3D加速度计和3D陀螺仪（LSM6DSL）

\item {} 
\sphinxAtStartPar
260\sphinxhyphen{}1260 hPa绝对数字输出气压计（LPS22HB）

\item {} 
\sphinxAtStartPar
渡越时间和姿势检测传感器（VL53L0X）

\item {} 
\sphinxAtStartPar
2个按钮(用户和复位按钮)

\item {} 
\sphinxAtStartPar
带有Micro\sphinxhyphen{}AB连接器的USB OTG FS

\item {} 
\sphinxAtStartPar
扩展连接器：
\begin{itemize}
\item {} 
\sphinxAtStartPar
Arduino™ Uno V3

\item {} 
\sphinxAtStartPar
PMOD

\end{itemize}

\item {} 
\sphinxAtStartPar
灵活的电源选项：
\begin{itemize}
\item {} 
\sphinxAtStartPar
ST LINK USB VBUS或外部电源

\end{itemize}

\item {} 
\sphinxAtStartPar
具有USB重新枚举功能的板上ST\sphinxhyphen{}LINK/V2\sphinxhyphen{}1调试器/编程器：大容量存储器、虚拟COM端口和调试端口

\item {} 
\sphinxAtStartPar
作为STM32Cube MCU软件包的一部分，提供全面的免费软件HAL库（包括大量示例）

\item {} 
\sphinxAtStartPar
支持广泛的集成开发环境（IDE），包括IAR™、Keil®、基于GCC的IDE、Arm® Mbed Enabled™

\item {} 
\sphinxAtStartPar
Arm® Mbed™在线工具（参见\sphinxhref{http://mbed.org/}{http://mbed.org}）

\end{itemize}

\sphinxAtStartPar
开发板结构框图

\sphinxAtStartPar
\sphinxincludegraphics{{stm32-arch}.png}

\sphinxAtStartPar
开发板布局

\sphinxAtStartPar
\sphinxincludegraphics{{stm-layout-up}.png}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{**正面布局**}}

\sphinxAtStartPar
\sphinxincludegraphics{{stm-layout-back}.png}

\sphinxAtStartPar
\sphinxstylestrong{\sphinxcode{\sphinxupquote{背部布局}}}

\sphinxAtStartPar
\sphinxstylestrong{开发环境}
\begin{itemize}
\item {} 
\sphinxAtStartPar
STM32CUBE IDE

\item {} 
\sphinxAtStartPar
keil

\item {} 
\sphinxAtStartPar
IAR

\item {} 
\sphinxAtStartPar
STM32CUBEMX+Clion

\end{itemize}

\sphinxAtStartPar
开发者技术手册

\sphinxAtStartPar
\DUrole{xref,download,myst}{um2153\sphinxhyphen{}discovery\sphinxhyphen{}kit\sphinxhyphen{}for\sphinxhyphen{}iot\sphinxhyphen{}node\sphinxhyphen{}multichannel\sphinxhyphen{}communication\sphinxhyphen{}with\sphinxhyphen{}stm32l4\sphinxhyphen{}stmicroelectronics.pdf}


\subsubsection{1.3 LoRa节点\sphinxhyphen{}RAK3172}
\label{\detokenize{dev-board/arch:lora-rak3172}}
\sphinxAtStartPar
\sphinxstylestrong{模块概述}

\sphinxAtStartPar
\sphinxhref{https://docs.rakwireless.com.cn/Product-Categories/WisDuo/RAK3172-Module/Overview/}{RAK3172}模块集成了STM32WLE5CC MCU芯片，是一款低功耗、远距离、易用、小巧的无线数据应用LoRa®收发模块。该模块遵循LoRaWAN® 1.0.3协议，支持Class A、Class B、Class C三种工作模式，易于连接到不同的LoRaWAN服务器平台，如TTN、Chirpstack、Activity、腾讯云等等。该模块还支持LoRa® P2P（点对点）通信，可帮助用户快速实现自己的远距离LoRa®网络。

\sphinxAtStartPar
用户可通过UART接口使用AT命令来配置模式和控制模块工作。RAK3172特别适合需要低功耗、电池供电的各种应用。

\sphinxAtStartPar
\sphinxstylestrong{电路板图}

\sphinxAtStartPar
\sphinxincludegraphics{{rak3172-3d}.png}

\sphinxAtStartPar
\sphinxstylestrong{系统框图}

\sphinxAtStartPar
RAK3172模块的内部组成和主要外部接口如下图所示。

\sphinxAtStartPar
\sphinxincludegraphics{{rak3172-inner}.png}

\sphinxAtStartPar
\sphinxstylestrong{产品特性}
\begin{itemize}
\item {} 
\sphinxAtStartPar
集成STM32WLE5CC芯片

\item {} 
\sphinxAtStartPar
遵循LoRaWAN® 1.0.3协议

\item {} 
\sphinxAtStartPar
支持的频段：EU433、CN470、IN865、EU868、AU915、US915、KR920、RU864、AS923\sphinxhyphen{}1/2/3/4

\item {} 
\sphinxAtStartPar
LoRaWAN激活模式：OTAA、ABP

\item {} 
\sphinxAtStartPar
支持LoRa® P2P（点对点）通信

\item {} 
\sphinxAtStartPar
具有简单易用的AT命令功能

\item {} 
\sphinxAtStartPar
支持通过UART接口发送AT命令

\item {} 
\sphinxAtStartPar
使用优化过的天线，通信距离可超过15 km

\item {} 
\sphinxAtStartPar
CPU核：ARM 32\sphinxhyphen{}bit Cortex\sphinxhyphen{}M4

\item {} 
\sphinxAtStartPar
内置带ECC的256 KB闪存

\item {} 
\sphinxAtStartPar
64 KB RAM

\item {} 
\sphinxAtStartPar
超低功耗，睡眠模式下功耗低至1.69 μA

\item {} 
\sphinxAtStartPar
温度范围：\sphinxhyphen{}40 °C \textasciitilde{} +85 °C

\item {} 
\sphinxAtStartPar
供电电压：2.0 V \textasciitilde{} 3.6 V

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{引脚定义}

\sphinxAtStartPar
\sphinxincludegraphics{{rak3172-pins}.png}

\sphinxAtStartPar
\sphinxstylestrong{与MCU的连接}

\sphinxAtStartPar
\sphinxincludegraphics{{rak3172-connetion}.png}


\subsubsection{1.4 NB\sphinxhyphen{}IOT节点}
\label{\detokenize{dev-board/arch:nb-iot}}
\sphinxAtStartPar
待更新


\subsection{2 LoRaWAN网关}
\label{\detokenize{dev-board/arch:lorawan}}
\sphinxAtStartPar
LoRaWAN®是一种低功耗广域（LPWA）网络协议，旨在以无线方式将电池操作的“things”连接到区域、国家或全球网络中的互联网，致力于解决关键的物联网（IoT）要求，如双向通信、端到端安全、移动性和本地化服务。

\sphinxAtStartPar
lora网关包含硬件部分和软件支持。硬件部分包括LoRA Wan 集中器与宿主机，软件运行在宿主机上。
\begin{itemize}
\item {} 
\sphinxAtStartPar
LoraWan集中器

\item {} 
\sphinxAtStartPar
Raspberry Pi 4B+

\item {} 
\sphinxAtStartPar
chirpstack

\end{itemize}

\sphinxAtStartPar
相关规范与国际组织
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.lora-alliance.org/}{LoRa Alliance}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://lora-alliance.org/lorawan-for-developers}{LoRaWAN specification}

\end{itemize}


\subsubsection{2.1 LoraWan集中器：RAK2287}
\label{\detokenize{dev-board/arch:lorawan-rak2287}}
\sphinxAtStartPar
\sphinxstylestrong{概述}

\sphinxAtStartPar
RAK2287是一款LPWAN集中器模块，易于集成到现有的路由器或其它网络设备中，为其添加LPWAN网关功能。主要功能特点如下。
\begin{itemize}
\item {} 
\sphinxAtStartPar
基于Semtech SX1302

\item {} 
\sphinxAtStartPar
支持SPI接口，具有Mini PCI\sphinxhyphen{}e标准插槽的嵌入式平台

\item {} 
\sphinxAtStartPar
集成了ZOE\sphinxhyphen{}M8Q GPS芯片

\item {} 
\sphinxAtStartPar
提供多达10条可编程并行解调路径

\item {} 
\sphinxAtStartPar
中等干扰环境下，每平方公里最多可覆盖500个节点

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{特性}
\begin{itemize}
\item {} 
\sphinxAtStartPar
基于Mini PCI\sphinxhyphen{}e外形尺寸而设计，带散热片。

\item {} 
\sphinxAtStartPar
SX1302基带处理器，实现了8 x 8通道LoRa数据包检测器，8 x SF5\sphinxhyphen{}SF12 LoRa解调器，8 x SF5\sphinxhyphen{} SF10 LoRa解调器，一个125/250/500 kHz高速LoRa解调器和一个（G）FSK解调器。

\item {} 
\sphinxAtStartPar
Mini PCI\sphinxhyphen{}e接口，电压为3.3 V

\item {} 
\sphinxAtStartPar
兼容Mini PCI\sphinxhyphen{}e类型的3G/LTE卡

\item {} 
\sphinxAtStartPar
发射功率最大可达27 dBm，接收灵敏度低至\sphinxhyphen{}139 dBm@SF12，带宽125 kHz

\item {} 
\sphinxAtStartPar
支持最新的LoRaWAN 1.0.3协议

\item {} 
\sphinxAtStartPar
支持全球免许可证频段：EU868, CN470, US915, AS923, AU915, KR920, IN865, AS920

\item {} 
\sphinxAtStartPar
支持SPI接口

\item {} 
\sphinxAtStartPar
内置ZOE\sphinxhyphen{}M8Q GPS模块

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{电路板}

\sphinxAtStartPar
\sphinxincludegraphics{{rak2287-board}.png}

\sphinxAtStartPar
RAK2287主电路板

\sphinxAtStartPar
\sphinxstylestrong{系统框图}

\sphinxAtStartPar
RAK2287板卡配备了一个\sphinxhref{https://www.semtech.com/products/wireless-rf/lora-core/sx1302\#documentation}{SX1302芯片}和两个SX1250。第一个芯片用于射频信号，是设备的核心。后者提供了相关的LoRa调制解调器和处理功能。该模块实现了符合PCI Express Mini Card要求的附加信号调整电路，并且提供了一个UFL连接器，可用于集成外部天线。

\sphinxAtStartPar
\sphinxincludegraphics{{rak287-block}.png}

\sphinxAtStartPar
RAK2287系统框图

\sphinxAtStartPar
\sphinxstylestrong{引脚定义}

\sphinxAtStartPar
\sphinxincludegraphics{{rak2287-pins}.png}

\sphinxAtStartPar
\sphinxstylestrong{原理图}

\sphinxAtStartPar
\sphinxincludegraphics{{rak2287-sch}.png}

\sphinxAtStartPar
更多内容请参考\sphinxhref{https://docs.rakwireless.com.cn/Product-Categories/WisLink/RAK2287/Datasheet/}{数据手册}


\subsubsection{2.2 宿主机：Raspberry Pi 4B+}
\label{\detokenize{dev-board/arch:raspberry-pi-4b}}
\sphinxAtStartPar
\sphinxstylestrong{技术参数}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Broadcom BCM2711, Quad core Cortex\sphinxhyphen{}A72 (ARM v8) 64\sphinxhyphen{}bit SoC @ 1.5GHz

\item {} 
\sphinxAtStartPar
1GB, 2GB, 4GB or 8GB LPDDR4\sphinxhyphen{}3200 SDRAM (depending on model)

\item {} 
\sphinxAtStartPar
2.4 GHz and 5.0 GHz IEEE 802.11ac wireless, Bluetooth 5.0, BLE

\item {} 
\sphinxAtStartPar
Gigabit Ethernet

\item {} 
\sphinxAtStartPar
2 USB 3.0 ports; 2 USB 2.0 ports.

\item {} 
\sphinxAtStartPar
Raspberry Pi standard 40 pin GPIO header (fully backwards compatible with previous boards)

\item {} 
\sphinxAtStartPar
2 × micro\sphinxhyphen{}HDMI ports (up to 4kp60 supported)

\item {} 
\sphinxAtStartPar
2\sphinxhyphen{}lane MIPI DSI display port

\item {} 
\sphinxAtStartPar
2\sphinxhyphen{}lane MIPI CSI camera port

\item {} 
\sphinxAtStartPar
4\sphinxhyphen{}pole stereo audio and composite video port

\item {} 
\sphinxAtStartPar
H.265 (4kp60 decode), H264 (1080p60 decode, 1080p30 encode)

\item {} 
\sphinxAtStartPar
OpenGL ES 3.1, Vulkan 1.0

\item {} 
\sphinxAtStartPar
Micro\sphinxhyphen{}SD card slot for loading operating system and data storage

\item {} 
\sphinxAtStartPar
5V DC via USB\sphinxhyphen{}C connector (minimum 3A*)

\item {} 
\sphinxAtStartPar
5V DC via GPIO header (minimum 3A*)

\item {} 
\sphinxAtStartPar
Power over Ethernet (PoE) enabled (requires separate PoE HAT)

\item {} 
\sphinxAtStartPar
Operating temperature: 0 – 50 degrees C ambient

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{产品图}

\sphinxAtStartPar
\sphinxincludegraphics{{pi4-layout}.png}

\sphinxAtStartPar
RaspberryPi 40 PIN 接口定义

\sphinxAtStartPar
\sphinxincludegraphics{{pi4-pins}.png}


\subsubsection{1.2.2 LoraWan 软件：ChripStack}
\label{\detokenize{dev-board/arch:lorawan-chripstack}}
\sphinxAtStartPar
ChirpStack是一个开源的LoRaWAN网络服务器。主要功能包括：
\begin{itemize}
\item {} 
\sphinxAtStartPar
可用于设置私有或公共LoRaWAN网络。

\item {} 
\sphinxAtStartPar
ChirpStack提供了一个Web界面，用于管理网关、设备和租户，

\item {} 
\sphinxAtStartPar
与主要云提供商、数据库和通常用于处理设备数据的服务进行数据集成。

\item {} 
\sphinxAtStartPar
ChirpStack提供了一个基于gRPC的API，可用于集成或扩展ChirpStack。

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{ChirpStack架构}

\sphinxAtStartPar
ChirpStack包含如下几个主要部分
\begin{itemize}
\item {} 
\sphinxAtStartPar
chirpstack gateway bridge：处理与网关集中器之间的通信

\item {} 
\sphinxAtStartPar
chirpstack network server

\item {} 
\sphinxAtStartPar
chirpstack application server

\end{itemize}

\sphinxAtStartPar
chirpstack 部署如图所示：

\sphinxAtStartPar
\sphinxincludegraphics{{chirpstack}.png}






\subsection{3 IoT 平台}
\label{\detokenize{dev-board/arch:iot}}
\sphinxAtStartPar
本项目的IoT云平台集成了众多优秀的开源项目，经过优化，整合了各自的优点，主要包括如下三个开源项目：
\begin{itemize}
\item {} 
\sphinxAtStartPar
ChirpStack

\item {} 
\sphinxAtStartPar
ThingsBoard

\item {} 
\sphinxAtStartPar
EMQX

\end{itemize}

\sphinxAtStartPar
本项目中平台功能以ThingsBoard为核心，以EMQX取代其他两个项目的内置的MQTT Broker，ChirpStack则主要用于来自LoRaWAN的信息。平台结构如下图：

\sphinxAtStartPar
\sphinxincludegraphics{{iot-platform}.png}


\subsubsection{3.1 ThingsBoard}
\label{\detokenize{dev-board/arch:thingsboard}}
\sphinxAtStartPar
\sphinxhref{https://thingsboard.io}{ThingsBoard}是一个开源物联网平台，可以快速开发、管理和扩展物联网项目。他可以提供开箱即用的物联网云或本地解决方案，为物联网应用程序启用服务器端基础设施。我们的平台构建于其之上，并对其中mqtt的海量并发进行了优化。

\sphinxAtStartPar
\sphinxstylestrong{特点}
\begin{itemize}
\item {} 
\sphinxAtStartPar
配置设备、资产和客户，并定义它们之间的关系。

\item {} 
\sphinxAtStartPar
从设备和资产收集数据并使之可视化。

\item {} 
\sphinxAtStartPar
分析传入的遥测数据和警报触发信息。

\item {} 
\sphinxAtStartPar
使用远程过程调用（RPC）控制设备。

\item {} 
\sphinxAtStartPar
根据设备的生命周期事件、REST API事件、RPC请求等构建工作流程。

\item {} 
\sphinxAtStartPar
提供响应敏捷的动态仪表板，向客户展示设备或资产遥测信息。

\item {} 
\sphinxAtStartPar
使用自定义的规则链实现特定功能。

\item {} 
\sphinxAtStartPar
与其他iot平台或系统集成。

\end{itemize}

\sphinxAtStartPar
平台总体框架如下图所示：

\sphinxAtStartPar
\sphinxincludegraphics{{thingsboard}.png}

\sphinxAtStartPar
系统实际使用架构包含两种模式，整体模式架构和基于微服务的架构。

\sphinxAtStartPar
\sphinxstylestrong{1 整体模式架构}

\sphinxAtStartPar
在\sphinxhref{https://thingsboard.io/docs/reference/monolithic/}{整体模式}下，所有ThingsBoard组件都在单个Java虚拟机（JVM）中启动，并共享相同的操作系统资源。由于ThingsBoard是用Java编写的，整体架构的明显优势是最大限度地减少了运行ThingsBoard所需的内存。这样就可以在受限环境中使用256或512 MB的RAM启动和运行ThingsBoard进程。但他也有明显的缺点，如果某个组建的消息过载，例如MQTT传输，它也可能影响其他组件。例如，如果ThingsBoard进程的操作系统限制为4096文件描述符，则无法同时从设备和websocket用户会话中打开超过4096个MQTT会话。

\sphinxAtStartPar
整体模式架构如下图所示：

\sphinxAtStartPar
\sphinxincludegraphics{{tb-componets}.png}

\sphinxAtStartPar
架构个组件描述请参见\sphinxhref{https://thingsboard.io/docs/reference/monolithic/}{官方说明}。

\sphinxAtStartPar
\sphinxstylestrong{2 微服务架构}

\sphinxAtStartPar
ThingsBoard v2.2，该平台支持\sphinxhref{https://thingsboard.io/docs/reference/msa/}{微服务部署模式}。微服务选项更适合高可用性和可扩展的场景。

\sphinxAtStartPar
其具体架构如下图所示：

\sphinxAtStartPar
\sphinxincludegraphics{{tb-micro-service}.png}

\sphinxAtStartPar
\sphinxstylestrong{3 iot gateway}

\sphinxAtStartPar
ThingsBoard 支持的iot协议有mqtt, coap以及http， 对于其他协议，可以采用\sphinxhref{https://thingsboard.io/docs/iot-gateway/what-is-iot-gateway/}{iot gateway} 组件来实现。

\sphinxAtStartPar
iot gateway框架如图所示：

\sphinxAtStartPar
\sphinxincludegraphics{{tb-gateway}.svg}


\subsubsection{3.2 ChirpStack}
\label{\detokenize{dev-board/arch:chirpstack}}
\sphinxAtStartPar
如上所述，本项目中，chirpstack的部署在两个物理位置，gateway bridge 在lora网关中部署，而iot 平台中，则部署chirpstack network server以及 application server。

\sphinxAtStartPar
chirpstack network server 作为mqtt客户端，用MQTT Broker 发布和订阅消息。本项目中由emqx取代了原来项目中的默认MQTT Broker Mosquito。

\sphinxAtStartPar
application server将遥测数据以及交换信息于Thethingsboard集成。


\subsubsection{3.3 EMQX}
\label{\detokenize{dev-board/arch:emqx}}
\sphinxAtStartPar
EMQX 是一款大规模可弹性伸缩的云原生分布式物联网 MQTT 消息服务器。

\sphinxAtStartPar
目前emqx已经成为全球最具扩展性，github上活跃度最高的 MQTT 消息服务器，EMQX 提供了高效可靠海量物联网设备连接，能够高性能实时移动与处理消息和事件流数据，可快速构建关键业务的物联网平台与应用。

\sphinxAtStartPar
\sphinxstylestrong{优势}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{开放源码}：基于 Apache 2.0 许可证完全开源，自 2013 年起 200+ 开源版本迭代。

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{MQTT 5.0}：100\% 支持 MQTT 5.0 和 3.x 协议标准，更好的伸缩性、安全性和可靠性。

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{海量连接}：单节点支持 500 万 MQTT 设备连接，集群可扩展至 1 亿并发 MQTT 连接。

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{高性能}：单节点支持每秒实时接收、移动、处理与分发数百万条的 MQTT 消息。

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{低时延}：基于 Erlang/OTP 软实时的运行时系统设计，消息分发与投递时延低于 1 毫秒。

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{高可用}：采用 Masterless 的大规模分布式集群架构，实现系统高可用和水平扩展。

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{用法}

\sphinxAtStartPar
本项目中emqx作为唯一开放的mqtt代理服务。与平台外部直接连接，而在平台内部，对于chirpstack network server，直接连接。而对于the things network，由于tb有自己的mqtt broker，因此需要使用emqx的mqtt桥接功能，具体如下所示：

\sphinxAtStartPar
1 入方向

\sphinxAtStartPar
\sphinxincludegraphics{{emqx-in}.png}

\sphinxAtStartPar
2 出方向

\sphinxAtStartPar
\sphinxincludegraphics{{emqx-out}.png}

\sphinxstepscope


\section{开发环境}
\label{\detokenize{dev-board/ide:id1}}\label{\detokenize{dev-board/ide::doc}}
\sphinxAtStartPar
开发环境需要确定 IDE 的操作系统，采用的编程语言，集成开发环境 IDE，以及 SDK。这主要取决于所采用的：
\begin{itemize}
\item {} 
\sphinxAtStartPar
编程语言

\item {} 
\sphinxAtStartPar
MCU 可使用的 IDE 环境

\item {} 
\sphinxAtStartPar
官方的 SDK

\item {} 
\sphinxAtStartPar
IDE 对本实验箱的兼容性

\item {} 
\sphinxAtStartPar
IDE 的跨平台特性以及易用性

\end{itemize}


\subsection{1 OS}
\label{\detokenize{dev-board/ide:os}}
\sphinxAtStartPar
本手册的实验项目采用\sphinxstylestrong{Ubuntu20}，但本项目的 IDE 是可以跨平台使用的，因此，在 Windows，Mac OS X 上同样可以使用。区别仅在于驱动以及 python 的版本。

\sphinxAtStartPar
但在实际应用中，跨平台项目，IDE 以及开发语言（如 Python）在不同的 OS 中往往呈现不兼容的情况，考虑到嵌入式开发，开源项目，以及 GitHub 上大量的代码均是在 Linux 平台下开发和测试，因此，本文档和实验系统均已 Linux 为主，同学们可以在自己的电脑上使用 Windows，允许但不提倡，建议同学自己的机器可以采用虚拟机的方式。


\subsection{2 开发语言}
\label{\detokenize{dev-board/ide:id2}}
\sphinxAtStartPar
本系统的两块 MCU 均支持开发语言与开发框架。
\begin{itemize}
\item {} 
\sphinxAtStartPar
C

\item {} 
\sphinxAtStartPar
\sphinxhref{https://micropython.org}{micropython}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.arduino.cc/en/software}{arduino}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://platformio.org}{platformio}

\end{itemize}

\sphinxAtStartPar
MicroPython 以及 Arduino 均具有简单易学的特点，同时也是跨平台语言，在构建项目原型以及验证设计方法时有着方便快捷的特点，但由于以下两个原因，本手册不以这两种语言讲述，建议有兴趣的同学自行学习使用。
\begin{itemize}
\item {} 
\sphinxAtStartPar
运行速度和功耗不适宜生产环境。

\item {} 
\sphinxAtStartPar
不能使用 OS，无法完全隔离硬件。

\end{itemize}

\sphinxAtStartPar
本手册中以生产环境中的默认开发语言 C 为基础叙述，这也是两款 MCU 的官方指定开发语言。


\subsection{3 IDE}
\label{\detokenize{dev-board/ide:ide}}
\sphinxAtStartPar
本手册的实验箱涉及到两颗 MCU，因此 IDE 的选择应当兼顾到两块 MCU 的兼容性。IDE 有官方提供的 IDE，以及第三方 IDE。


\subsubsection{3.1 官方 IDE}
\label{\detokenize{dev-board/ide:id3}}
\sphinxAtStartPar
对于 ESP32:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Eclipse + \sphinxhref{https://github.com/espressif/idf-eclipse-plugin/blob/master/README.md}{esp\sphinxhyphen{}idf plugin}

\item {} 
\sphinxAtStartPar
VsCode + \sphinxhref{https://github.com/espressif/vscode-esp-idf-extension/blob/master/docs/tutorial/install.md}{esp\sphinxhyphen{}idf plugin}

\end{itemize}

\sphinxAtStartPar
对于 STM32L475
\begin{itemize}
\item {} 
\sphinxAtStartPar
STM32CubeIDE

\end{itemize}

\sphinxAtStartPar
官方 IDE 的共同特点是支持比较丰富。但是其缺点是都基于 eclipse，Eclipse 的最大不足有两点：
\begin{itemize}
\item {} 
\sphinxAtStartPar
由于需要 Java 虚拟机，运行速度慢，对机器要求高

\item {} 
\sphinxAtStartPar
代码补全功能差，编程不友好。

\end{itemize}

\sphinxAtStartPar
因此，本手册不采用官方提供的 IDE。


\subsubsection{3.2 第三方 IDE}
\label{\detokenize{dev-board/ide:id4}}
\sphinxAtStartPar
对于 ESP32:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Clion

\item {} 
\sphinxAtStartPar
vscode + platformio

\end{itemize}

\sphinxAtStartPar
对于 STM32L475:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Clion + stm32cubemx

\item {} 
\sphinxAtStartPar
vscode + platformio

\item {} 
\sphinxAtStartPar
keil

\item {} 
\sphinxAtStartPar
IAR

\end{itemize}

\sphinxAtStartPar
本项目希望两块 MCU 能够统一 IDE，因此，由于 keil，iar 均只用于 Windows，不予考虑。可见，vscode + platformio 是最统一的，且是开源的，但是经过实测，其稳定性和对官方的兼容性都存在一定问题，因此，也不予采用。

\sphinxAtStartPar
Clion 是 jetbrain 旗下的一款针对 c/c++的 ide 平台，近年增加了对嵌入式开发的支持，特别是内置支持 STM32，考虑到 Clion 的优异性能对嵌入式的支持，\sphinxstylestrong{本手册采用 Clion 作为统一开发平台。}

\sphinxAtStartPar
特别的，clion 是跨平台 IDE，因此他并不限于在 Linux 系统下开发。


\subsection{4 SDK 以及 Tools}
\label{\detokenize{dev-board/ide:sdk-tools}}

\subsubsection{STM32L4CUBE}
\label{\detokenize{dev-board/ide:stm32l4cube}}
\sphinxAtStartPar
待更新


\subsubsection{ESP\sphinxhyphen{}IDF}
\label{\detokenize{dev-board/ide:esp-idf}}
\sphinxAtStartPar
见后节

\sphinxstepscope


\section{MCU 基础}
\label{\detokenize{dev-board/mcu:mcu}}\label{\detokenize{dev-board/mcu::doc}}
\sphinxAtStartPar
实验箱设计采用双MCU并行设计，即 \sphinxstylestrong{ESP32} 和 \sphinxstylestrong{STM32L475}，每个MCU均单独提供WIFI, Bluetooth（重点BLE），RFID, NFC, 十余种外部传感器，LoRa, NB\sphinxhyphen{}IoT以及丰富的预留接口。可承担绝大部分IoT节点功能实验。

\sphinxstepscope


\subsection{ESP32 基础}
\label{\detokenize{dev-board/esp32:esp32}}\label{\detokenize{dev-board/esp32::doc}}
\sphinxAtStartPar
ESP32 是我国物联网芯片企业乐鑫的主力产品，在 IOT 芯片低功耗领域全球出货量第一。不同于传统的 RF 芯片和 MCU，它专为低功耗 IoT 领域设计，提出了专用解决方案。

\sphinxAtStartPar
以下为 ESP32 功能框图

\sphinxAtStartPar
\sphinxincludegraphics{{esp32-block}.png}


\subsubsection{特点}
\label{\detokenize{dev-board/esp32:id1}}
\sphinxAtStartPar
ESP32 是集成 2.4GHz Wi\sphinxhyphen{}Fi 和蓝牙双模的单芯片方案，采用台积电(TSMC)低功耗 40 纳米工艺，具有超高的射频性能、稳定性、通用性和可靠性，以及超低的功耗，满足不同的功耗需求，适用于各种应用场景。


\paragraph{超低功耗}
\label{\detokenize{dev-board/esp32:id2}}
\sphinxAtStartPar
ESP32 专为移动设备、可穿戴电子产品和物联网(IoT)应用而设计。作为业内领先的低功耗芯片，ESP32 具有精细的时钟门控、省电模式和动态电压调整等特性。具体参见技术手册的 RTC 和低功耗管理。


\paragraph{高集成度}
\label{\detokenize{dev-board/esp32:id3}}
\sphinxAtStartPar
ESP32 外部元器件只需大约 20 个。ESP32 集成了天线开关、射频 Balun、功率放大器、低噪声放大器、滤波器以及电源管理模块，极大减少了印刷电路板(PCB)的面积。


\paragraph{WiFi 功能}
\label{\detokenize{dev-board/esp32:wifi}}\begin{itemize}
\item {} 
\sphinxAtStartPar
802.11b/g/n

\item {} 
\sphinxAtStartPar
802.11n (2.4 GHz) 速度高达 150 Mbps

\item {} 
\sphinxAtStartPar
无线多媒体 (WMM)

\item {} 
\sphinxAtStartPar
帧聚合 (TX/RX A\sphinxhyphen{}MPDU, RX A\sphinxhyphen{}MSDU)

\item {} 
\sphinxAtStartPar
立即块确认 (Immediate Block ACK)

\item {} 
\sphinxAtStartPar
重组 (Defragmentation)

\item {} 
\sphinxAtStartPar
Beacon 自动监测（硬件 TSF）

\item {} 
\sphinxAtStartPar
4 × 虚拟 Wi\sphinxhyphen{}Fi 接口

\item {} 
\sphinxAtStartPar
同时支持基础结构型网络 (Infrastructure BSS) Station 模式/SoftAP 模式/混杂模式 请注意 ESP32 在 Station 模式下扫描时，SoftAP 信道会同时改变

\item {} 
\sphinxAtStartPar
天线分集

\end{itemize}


\paragraph{BlueTooth 功能}
\label{\detokenize{dev-board/esp32:bluetooth}}\begin{itemize}
\item {} 
\sphinxAtStartPar
蓝牙 v4.2 完整标准，包含传统蓝牙 (BR/EDR) 和低功耗蓝牙 (Bluetooth LE)

\item {} 
\sphinxAtStartPar
支持标准 Class\sphinxhyphen{}1、Class\sphinxhyphen{}2 和 Class\sphinxhyphen{}3，且无需外部功率放大器

\item {} 
\sphinxAtStartPar
增强型功率控制 (Enhanced Power Control)

\item {} 
\sphinxAtStartPar
输出功率高达 +9 dBm

\item {} 
\sphinxAtStartPar
NZIF 接收器具有–94 dBm 的 BLE 接收灵敏度

\item {} 
\sphinxAtStartPar
自适应跳频 (AFH)

\item {} 
\sphinxAtStartPar
基于 SDIO/SPI/UART 接口的标准 HCI

\item {} 
\sphinxAtStartPar
高速 UART HCI，最高可达 4 Mbps

\item {} 
\sphinxAtStartPar
支持蓝牙 4.2 BR/EDR 和 Bluetooth LE 双模 controller

\item {} 
\sphinxAtStartPar
同步面向连接/扩展同步面向连接 (SCO/eSCO)

\item {} 
\sphinxAtStartPar
CVSD 和 SBC 音频编解码算法

\item {} 
\sphinxAtStartPar
蓝牙微微网 (Piconet) 和散射网 (Scatternet)

\item {} 
\sphinxAtStartPar
支持传统蓝牙和低功耗蓝牙的多设备连接

\item {} 
\sphinxAtStartPar
支持同时广播和扫描

\end{itemize}


\paragraph{MCU 功能}
\label{\detokenize{dev-board/esp32:mcu}}
\sphinxAtStartPar
ESP32 采用著名的 EDA 设计公司 Cadence® 的 Tensilica® Xtensa® 处理器 IP 授权，该 MCU 架构侧重高性能，低功耗的实时处理器芯片。乐鑫公司在此基础上集成了 WIFI 和 BT 基带，成为完整的 ESP32。该处理器性能强大，外设丰富，主要表现在：


\subparagraph{CPU 与存储}
\label{\detokenize{dev-board/esp32:cpu}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Xtensa ® 32\sphinxhyphen{}bit LX6 双核处理器

\item {} 
\sphinxAtStartPar
CoreMark ® 得分：主频 240 MHz：994.26 CoreMark；4.14 CoreMark/MHz

\item {} 
\sphinxAtStartPar
448 KB ROM

\item {} 
\sphinxAtStartPar
520 KB SRAM

\item {} 
\sphinxAtStartPar
16 KB RTC SRAM

\item {} 
\sphinxAtStartPar
QSPI 支持多个 Flash/SRAM

\end{itemize}


\subparagraph{时钟与定时器}
\label{\detokenize{dev-board/esp32:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
内置 8MHz 振荡器，支持自校准

\item {} 
\sphinxAtStartPar
内置 RC 振荡器，支持自校准

\item {} 
\sphinxAtStartPar
支持外置 2MHz 至 60MHz 的主晶振（如果使用 Wi\sphinxhyphen{}Fi/蓝牙功能，则目前仅支持 40MHz 晶振）

\item {} 
\sphinxAtStartPar
支持外置 32kHz 晶振，用于 RTC，支持自校准

\item {} 
\sphinxAtStartPar
2 个定时器群组，每组包括 2 个 64\sphinxhyphen{}bit 通用定时器和 1 个主系统看门狗

\item {} 
\sphinxAtStartPar
1 个 RTC 定时器

\item {} 
\sphinxAtStartPar
RTC 看门狗

\end{itemize}


\subparagraph{外设接口}
\label{\detokenize{dev-board/esp32:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
34 个 GPIO 口

\item {} 
\sphinxAtStartPar
12\sphinxhyphen{}bit SAR ADC，多达 18 个通道

\item {} 
\sphinxAtStartPar
2 个 8\sphinxhyphen{}bit D/A 转换器

\item {} 
\sphinxAtStartPar
10 个触摸传感器

\item {} 
\sphinxAtStartPar
4 个 SPI

\item {} 
\sphinxAtStartPar
2 个 I2S

\item {} 
\sphinxAtStartPar
2 个 I2C

\item {} 
\sphinxAtStartPar
3 个 UART

\item {} 
\sphinxAtStartPar
1 个 Host SD/eMMC/SDIO

\item {} 
\sphinxAtStartPar
1 个 Slave SDIO/SPI

\item {} 
\sphinxAtStartPar
带有专用 DMA 的以太网 MAC 接口，支持 IEEE 1588

\item {} 
\sphinxAtStartPar
TWAI ® ，兼容 ISO 11898\sphinxhyphen{}1（CAN 规范 2.0）

\item {} 
\sphinxAtStartPar
RMT (TX/RX)

\item {} 
\sphinxAtStartPar
电机 PWM

\item {} 
\sphinxAtStartPar
LED PWM，多达 16 个通道

\end{itemize}


\subparagraph{安全}
\label{\detokenize{dev-board/esp32:id6}}\begin{itemize}
\item {} 
\sphinxAtStartPar
安全启动

\item {} 
\sphinxAtStartPar
flash 加密

\item {} 
\sphinxAtStartPar
1024\sphinxhyphen{}bit OTP，用户可用的高达 768 bit

\item {} 
\sphinxAtStartPar
加密硬件加速器：
\begin{itemize}
\item {} 
\sphinxAtStartPar
AES

\item {} 
\sphinxAtStartPar
Hash (SHA\sphinxhyphen{}2)

\item {} 
\sphinxAtStartPar
RSA

\item {} 
\sphinxAtStartPar
ECC

\item {} 
\sphinxAtStartPar
随机数生成器 (RNG)

\end{itemize}

\end{itemize}


\subsubsection{系统与存储}
\label{\detokenize{dev-board/esp32:id7}}
\sphinxAtStartPar
完整技术资料请见{\hyperref[\detokenize{dev-board/esp32:../reference.md}]{\sphinxcrossref{\DUrole{xref,myst}{参考文档}}}}。由于系统与存储是 ESP32 的核心部分，这里重点介绍，其他外设以及低功耗协处理器等内容请参见\sphinxhref{https://www.espressif.com/sites/default/files/documentation/esp32\_technical\_reference\_manual\_cn.pdf}{ESP32 技术参考手册}

\sphinxAtStartPar
ESP32 采用两个哈佛结构 Xtensa LX6 CPU 构成双核系统。所有的片上存储器、片外存储器以及外设都分布在 两个 CPU 的数据总线和／或指令总线上。 除下文列出的个别情况外，两个 CPU 的地址映射呈对称结构，即使用相同的地址访问同一目标。系统中多个外 设能够通过 DMA 访问片上存储器。 两个 CPU 的名称分别是“PRO\_CPU”和“APP\_CPU”。PRO 代表“protocol（协议）”，APP 代表“application （应用）”。在大多数情况下，两个 CPU 的功能是相同的。


\paragraph{主要特性}
\label{\detokenize{dev-board/esp32:id8}}\begin{itemize}
\item {} 
\sphinxAtStartPar
地址空间
\begin{itemize}
\item {} 
\sphinxAtStartPar
对称地址映射

\item {} 
\sphinxAtStartPar
数据总线与指令总线分别有 4 GB (32\sphinxhyphen{}bit) 地址空间

\item {} 
\sphinxAtStartPar
1296 KB 片上存储器地址空间

\item {} 
\sphinxAtStartPar
19704 KB 片外存储器地址空间

\item {} 
\sphinxAtStartPar
512 KB 外设地址空间

\item {} 
\sphinxAtStartPar
部分片上存储器与片外存储器既能被数据总线也能被指令总线访问

\item {} 
\sphinxAtStartPar
328 KB DMA 地址空间

\end{itemize}

\item {} 
\sphinxAtStartPar
片上存储器
\begin{itemize}
\item {} 
\sphinxAtStartPar
448 KB Internal ROM

\item {} 
\sphinxAtStartPar
520 KB Internal SRAM

\item {} 
\sphinxAtStartPar
8 KB RTC FAST Memory

\item {} 
\sphinxAtStartPar
8 KB RTC SLOW Memory

\end{itemize}

\item {} 
\sphinxAtStartPar
片外存储器 片外 SPI 存储器可作为片外存储器被映射到可用的地址空间。部分片上存储器可用作片外存储器的 Cache。
\begin{itemize}
\item {} 
\sphinxAtStartPar
最大支持 16 MB 片外 SPI Flash

\item {} 
\sphinxAtStartPar
最大支持 8 MB 片外 SPI SRAM

\end{itemize}

\item {} 
\sphinxAtStartPar
外设
\begin{itemize}
\item {} 
\sphinxAtStartPar
41 个外设模块

\end{itemize}

\item {} 
\sphinxAtStartPar
DMA
\begin{itemize}
\item {} 
\sphinxAtStartPar
13 个具有 DMA 功能的模块

\end{itemize}

\end{itemize}

\sphinxAtStartPar
下图为系统与存储空间结构关系

\sphinxAtStartPar
\sphinxincludegraphics{{system_structure}.png}

\sphinxAtStartPar
下图为地址映射结构

\sphinxAtStartPar
\sphinxincludegraphics{{addr_mapping}.png}


\paragraph{功能描述}
\label{\detokenize{dev-board/esp32:id9}}

\subparagraph{地址映射}
\label{\detokenize{dev-board/esp32:id10}}
\sphinxAtStartPar
同构双核系统由两个哈佛结构 Xtensa LX6 CPU 构成，每个 CPU 都具有 4 GB（32\sphinxhyphen{}bit）的地址空间。两个 CPU 的地址映射是对称的。

\sphinxAtStartPar
地址 0x4000\_0000 以下的部分属于数据总线的地址范围，地址 0x4000\_0000 \textasciitilde{} 0x4FFF\_FFFF 部分为指令总线的地址范围，地址 0x5000\_0000 及以上的部分是数据总线与指令总线共用的地址范围。

\sphinxAtStartPar
CPU 的数据总线与指令总线都为小端序。即字节地址 0x0、0x1、0x2、0x3 访问的字节分别是 0x0 访问的 32\sphinxhyphen{}bit 字中的最低、次低、次高、最高字节。CPU 可以通过数据总线按照字节、半字、字进行对齐与非对齐的数据访问。CPU 可以通过指令总线进行数据访问，但必须是\sphinxstylestrong{字对齐方式}；非对齐数据访问会导致 CPU 工作异常。

\sphinxAtStartPar
两个 CPU 都能够使用数据总线与指令总线直接访问片上存储器、使用 Cache 和 MMU 直接访问映射到地址空间的片外存储器、使用指令总线直接访问外设。当两个 CPU 访问同一目标时，其使用相同的地址，整个系统的地址映射呈对称结构。表 {[}1\sphinxhyphen{}1{]}描述了两个 CPU 的数据总线与指令总线中的各段地址所能访问的目标。

\sphinxAtStartPar
系统中部分片上存储器与部分片外存储器既可以被数据总线访问也可以被指令总线访问，这种情况下，两个 CPU 都可以用多个地址访问到同一目标。

\sphinxAtStartPar
\sphinxstylestrong{表} 1­. \sphinxstylestrong{地址映射}

\sphinxAtStartPar
\sphinxincludegraphics{{addr_mapping_bus}.png}


\subparagraph{片上存储器}
\label{\detokenize{dev-board/esp32:id11}}
\sphinxAtStartPar
片上存储器分为 Internal ROM、Internal SRAM、RTC FAST Memory、RTC SLOW Memory 四个部分，其容量分别为 448 KB、520 KB、8 KB、8 KB。其中 448 KB Internal ROM 分为 384 KB Internal ROM 0、64 KB Internal ROM 1 两部分；520 KB Internal SRAM 分为 192 KB Internal SRAM 0、128 KB Internal SRAM 1、200 KB Internal SRAM 2 三部分。

\sphinxAtStartPar
RTC FAST Memory 与 RTC SLOW Memory 都为 SRAM。

\sphinxAtStartPar
下表列出了所有片上存储器以及片上存储器的数据总线与指令总线地址段。

\sphinxAtStartPar
\sphinxincludegraphics{{onchip-reg-mapping}.png}


\subparagraph{Internal ROM 0}
\label{\detokenize{dev-board/esp32:internal-rom-0}}
\sphinxAtStartPar
Internal ROM 0 的容量为 384 KB，可以被两个 CPU 通过指令总线 0x4000\_0000 \textasciitilde{} 0x4005\_FFFF 读取。

\sphinxAtStartPar
访问 ROM 0 的头 32 KB 的地址（0x4000\_0000 \textasciitilde{} 0x4000\_7FFF）可以被重新映射到 Internal SRAM 1 中的一部分，这部分原本被地址 0x400B\_0000 \textasciitilde{} 0x400B\_7FFF 访问。重映射时，这 32 KB SRAM 不能再被地址 0x400B\_0000 \textasciitilde{} 0x400B\_7FFF 访问，但是可以被数据总线 (0x3FFE\_8000 \textasciitilde{} 0x3FFE\_FFFF）访问。实现方式是分别为两个 CPU 配置一个寄存器，即为 PRO\_CPU 置位 DPORT\_PRO\_BOOT\_REMAP\_CTRL\_REG 寄存器的 bit 0 或者为 APP\_CPU 置位 DPORT\_APP\_BOOT\_REMAP\_CTRL\_REG 寄存器的 bit 0。


\subparagraph{Internal ROM 1}
\label{\detokenize{dev-board/esp32:internal-rom-1}}
\sphinxAtStartPar
Internal ROM 1 的容量为 64 KB，其可以被两个 CPU 通过数据总线 0x3FF9\_0000 \textasciitilde{} 0x3FF9\_FFFF 读取。


\subparagraph{Internal SRAM 0}
\label{\detokenize{dev-board/esp32:internal-sram-0}}
\sphinxAtStartPar
Internal SRAM 0 的容量为 192 KB，通过配置，硬件的头 64 KB 可以作为 Cache 来缓存片外存储器。不作为 Cache 使用时，头 64 KB 可以被两个 CPU 通过指令总线 0x4007\_0000 \textasciitilde{} 0x4007\_FFFF 读写，其余 128 KB 可以被两个 CPU 通过指令总线 0x4008\_0000 \textasciitilde{} 0x4009\_FFFF 读写。


\subparagraph{Internal SRAM 1}
\label{\detokenize{dev-board/esp32:internal-sram-1}}
\sphinxAtStartPar
Internal SRAM 1 的容量为 128 KB，其既可以被两个 CPU 通过数据总线 0x3FFE\_0000 \textasciitilde{} 0x3FFF\_FFFF 读写，也可以被两个 CPU 通过指令总线 0x400A\_0000 \textasciitilde{} 0x400B\_FFFF 读写。

\sphinxAtStartPar
指令总线地址和数据总线地址访问的 word 是逆序的。即地址：
\begin{itemize}
\item {} 
\sphinxAtStartPar
0x3FFE\_0000 访问的字节等同于 0x400B\_FFFC 访问的 word 中的最低字节

\item {} 
\sphinxAtStartPar
0x3FFE\_0001 访问的字节等同于 0x400B\_FFFC 访问的 word 中的次低字节

\item {} 
\sphinxAtStartPar
0x3FFE\_0002 访问的字节等同于 0x400B\_FFFC 访问的 word 中的次高字节

\item {} 
\sphinxAtStartPar
0x3FFE\_0003 访问的字节等同于 0x400B\_FFFC 访问的 word 中的最高字节

\item {} 
\sphinxAtStartPar
0x3FFE\_0004 访问的字节等同于 0x400B\_FFF8 访问的 word 中的最低字节

\item {} 
\sphinxAtStartPar
0x3FFE\_0005 访问的字节等同于 0x400B\_FFF8 访问的 word 中的次低字节

\item {} 
\sphinxAtStartPar
0x3FFE\_0006 访问的字节等同于 0x400B\_FFF8 访问的 word 中的次高字节

\item {} 
\sphinxAtStartPar
0x3FFE\_0007 访问的字节等同于 0x400B\_FFF8 访问的 word 中的最高字节

\item {} 
\sphinxAtStartPar
0x3FFF\_FFF8 访问的字节等同于 0x400A\_0004 访问的 word 中的最低字节

\item {} 
\sphinxAtStartPar
0x3FFF\_FFF9 访问的字节等同于 0x400A\_0004 访问的 word 中的次低字节

\item {} 
\sphinxAtStartPar
0x3FFF\_FFFA 访问的字节等同于 0x400A\_0004 访问的 word 中的次高字节

\item {} 
\sphinxAtStartPar
0x3FFF\_FFFB 访问的字节等同于 0x400A\_0004 访问的 word 中的最高字节

\item {} 
\sphinxAtStartPar
0x3FFF\_FFFC 访问的字节等同于 0x400A\_0000 访问的 word 中的最低字节

\item {} 
\sphinxAtStartPar
0x3FFF\_FFFD 访问的字节等同于 0x400A\_0000 访问的 word 中的次低字节

\item {} 
\sphinxAtStartPar
0x3FFF\_FFFE 访问的字节等同于 0x400A\_0000 访问的 word 中的次高字节

\item {} 
\sphinxAtStartPar
0x3FFF\_FFFF 访问的字节等同于 0x400A\_0000 访问的 word 中的最高字节

\end{itemize}

\sphinxAtStartPar
部分存储器可以被重新映射到 ROM 0 的地址空间。详细信息请参见 Internal Rom 0


\subparagraph{Internal SRAM 2}
\label{\detokenize{dev-board/esp32:internal-sram-2}}
\sphinxAtStartPar
Internal SRAM 2 的容量为 200 KB，其可以被两个 CPU 通过数据总线 0x3FFA\_E000 \textasciitilde{} 0x3FFD\_FFFF 读写。


\subparagraph{DMA}
\label{\detokenize{dev-board/esp32:dma}}
\sphinxAtStartPar
DMA 使用与 CPU 数据总线完全相同的地址读写 Internal SRAM 1 与 Internal SRAM 2。即 DMA 使用地址 0x3FFE\_0000 \textasciitilde{} 0x3FFF\_FFFF 读写 Internal SRAM 1，使用地址 0x3FFA\_E000 \textasciitilde{} 0x3FFD\_FFFF 读写 Internal SRAM 2。

\sphinxAtStartPar
系统中具有 DMA 功能的模块总共有 13 个。表 {[}1\sphinxhyphen{}3{]} 列出了所有具有 DMA 功能的模块。

\sphinxAtStartPar
\sphinxstylestrong{表} 1­3. \sphinxstylestrong{具有} DMA \sphinxstylestrong{功能的模块}

\sphinxAtStartPar
\sphinxincludegraphics{{dam-moduler}.png}


\subparagraph{RTC FAST Memory}
\label{\detokenize{dev-board/esp32:rtc-fast-memory}}
\sphinxAtStartPar
RTC FAST Memory 为 8 KB SRAM，其只能被 PRO\_CPU 通过数据总线 0x3FF8\_0000 \textasciitilde{} 0x3FF8\_1FFF 读写，或被 PRO\_CPU 通过指令总线 0x400C\_0000 \textasciitilde{} 0x400C\_1FFF 读写。与其他存储器不同，APP\_CPU 不能访问 RTC FAST Memory。

\sphinxAtStartPar
PRO\_CPU 的这两段地址同序访问 RTC FAST Memory。即地址 0x3FF8\_0000 与 0x400C\_0000 访问到相同的 word，0x3FF8\_0004 与 0x400C\_0004 访问到相同的 word，0x3FF8\_0008 与 0x400C\_0008 访问到相同的 word，以此类推。APP\_CPU 的这两段地址不能访问到 RTC FAST Memory，也不能访问到其他任何目标。


\subparagraph{RTC SLOW Memory}
\label{\detokenize{dev-board/esp32:rtc-slow-memory}}
\sphinxAtStartPar
RTC SLOW Memory 为 8 KB SRAM，其可以被两个 CPU 通过数据总线与指令总线共用地址段 0x5000\_0000 \textasciitilde{}0x5000\_1FFF 读写。


\subparagraph{片外存储器}
\label{\detokenize{dev-board/esp32:id12}}
\sphinxAtStartPar
ESP32 将 External Flash 与 External SRAM 作为片外存储器。表 {[}1\sphinxhyphen{}4{]}列出了两个 CPU 的数据总线与指令总线中的各段地址通过 Cache 与 MMU 所能访问的片外存储器。两个 CPU 通过 Cache 与 MMU 对片外存储器进行访问时，Cache 将根据 MMU 中的设置把 CPU 的地址变换为 External Flash 与 External SRAM 的实地址。经过变换之后的实地址最大支持 16 MB 的 External Flash 与 8 MB 的 External SRAM。

\sphinxAtStartPar
\sphinxstylestrong{表} 1­4. \sphinxstylestrong{片外存储器地址映射}

\sphinxAtStartPar
\sphinxincludegraphics{{external-rom-mapping}.png}


\subparagraph{Cache}
\label{\detokenize{dev-board/esp32:cache}}
\sphinxAtStartPar
如下图 {[}1\sphinxhyphen{}3{]}所示，ESP32 的 2 个 CPU 各有一组大小为 32 KB 的 cache，用以访问外部存储器。PRO CPU 和 APP CPU 分别使用 DPORT\_PRO\_CACHE\_CTRL\_REG 的 PRO\_CACHE\_ENABLE 位和 DPORT\_APP\_CACHE\_CTRL\_REG 的 APP\_CACHE\_ENABLE 位使能 Cache 功能。

\sphinxAtStartPar
ESP32 Cache 采用两路组相连的映射方式。当只有 PRO CPU 使用 Cache 或只有 APP CPU 使用 Cache 时，可以通过配置寄存器 DPORT\_CACHE\_MUX\_MODE\_REG 的 CACHE\_MUX\_MODE{[}1:0{]} 位，选择使用 Internal

\sphinxAtStartPar
\sphinxincludegraphics{{cache-instructure}.png}

\sphinxAtStartPar
\sphinxstylestrong{图} 1­3. Cache \sphinxstylestrong{系统框图}

\sphinxAtStartPar
SRAM0 的 POOL0 或 POOL1 作为 cache memory。当 PRO CPU 和 APP CPU 都使用 Cache 时，Internal SRAM0 的 POOL0 和 POOL1 可以复用作为 cache memory。详见表 {[}1\sphinxhyphen{}5{]}。

\sphinxAtStartPar
\sphinxstylestrong{表} 1­\sphinxhyphen{}5. Cache memory \sphinxstylestrong{模式}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
CACHE\_MUX\_MODE
&\sphinxstyletheadfamily 
\sphinxAtStartPar
POOL0
&\sphinxstyletheadfamily 
\sphinxAtStartPar
POOL1
\\
\hline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
PRO CPU
&
\sphinxAtStartPar
APP CPU
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
PRO CPU/APP CPU
&
\sphinxAtStartPar
\sphinxhyphen{}
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
PRO CPU/APP CPU
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
APP CPU
&
\sphinxAtStartPar
PRO CPU
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
由表 {[}1\sphinxhyphen{}5{]} 可知，当 CACHE\_MUX\_MODE 为 1 或 2 时，PRO CPU 和 APP CPU 不可同时开启 Cache 功能。开启 Cache 功能后，POOL0 或者 POOL1 只作为 cache memory 使用，不能复用作为指令总线的访问区域。

\sphinxAtStartPar
ESP32 Cache 具有 Flush 功能。需要注意的是，当使用 Flush 功能时，写入 cache 的数据将被丢弃，并不会写回到 External SRAM 中。实现 flush 操作的方法为：先将 DPORT\_\sphinxstyleemphasis{x}\_CACHE\_CTRL\_REG 的 \sphinxstyleemphasis{x}\_CACHE\_FLUSH\_ENA 位清 0，再将该位置 1。此后，系统硬件会将寄存器中的 \sphinxstyleemphasis{x}\_CACHE\_FLUSH\_DONE 位置为 1 时，表明 cache flush 操作已经完成，其中 \sphinxstyleemphasis{x} 表示“PRO”或“APP”。

\sphinxAtStartPar
ESP32 Cache 的地址映射详见片上存储器章节和片外存储器章节。


\subparagraph{外设}
\label{\detokenize{dev-board/esp32:id13}}
\sphinxAtStartPar
ESP32 共有 41 个外设模块。表 {[}1\sphinxhyphen{}6{]} 详细描述了两个 CPU 的数据总线中的各段地址所能访问的各个外设模块。除了 PID Controller 以外，其余外设模块都可以被两个 CPU 用相同地址访问到。

\sphinxAtStartPar
\sphinxstylestrong{表} 1­\sphinxhyphen{}6. \sphinxstylestrong{外设地址映射}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{|l|l|l|l|l|l|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
总线类型
&\sphinxstyletheadfamily 
\sphinxAtStartPar
地为地址
&\sphinxstyletheadfamily 
\sphinxAtStartPar
高位地址
&\sphinxstyletheadfamily 
\sphinxAtStartPar
容量
&\sphinxstyletheadfamily 
\sphinxAtStartPar
目标
&\sphinxstyletheadfamily 
\sphinxAtStartPar
备注
\\
\hline
\endfirsthead

\multicolumn{6}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} 续上页}}}\\
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
总线类型
&\sphinxstyletheadfamily 
\sphinxAtStartPar
地为地址
&\sphinxstyletheadfamily 
\sphinxAtStartPar
高位地址
&\sphinxstyletheadfamily 
\sphinxAtStartPar
容量
&\sphinxstyletheadfamily 
\sphinxAtStartPar
目标
&\sphinxstyletheadfamily 
\sphinxAtStartPar
备注
\\
\hline
\endhead

\hline
\multicolumn{6}{r}{\makebox[0pt][r]{\sphinxtablecontinued{下页继续}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF0\_0000
&
\sphinxAtStartPar
0x3FF0\_0FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
DPort Register
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF0\_1000
&
\sphinxAtStartPar
0x3FF0\_1FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
AES Accelerator
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF0\_2000
&
\sphinxAtStartPar
0x3FF0\_2FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
RSA Accelerator
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF0\_3000
&
\sphinxAtStartPar
0x3FF0\_3FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
SHA Accelerator
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF0\_4000
&
\sphinxAtStartPar
0x3FF0\_4FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
Secure Boot
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0x3FF0\_5000
&
\sphinxAtStartPar
0x3FF0\_FFFF
&
\sphinxAtStartPar
44 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF1\_0000
&
\sphinxAtStartPar
0x3FF1\_3FFF
&
\sphinxAtStartPar
16 KB
&
\sphinxAtStartPar
Cache MMU Table
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0x3FF1\_4000
&
\sphinxAtStartPar
0x3FF1\_EFFF
&
\sphinxAtStartPar
44 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF1\_F000
&
\sphinxAtStartPar
0x3FF1\_FFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
PID Controller
&
\sphinxAtStartPar
{[}每个 CPU 单独外设{]}
\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0x3FF2\_0000
&
\sphinxAtStartPar
0x3FF3\_FFFF
&
\sphinxAtStartPar
128 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF4\_0000
&
\sphinxAtStartPar
0x3FF4\_0FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
UART0
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0x3FF4\_1000
&
\sphinxAtStartPar
0x3FF4\_1FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF4\_2000
&
\sphinxAtStartPar
0x3FF4\_2FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
SPI1
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF4\_3000
&
\sphinxAtStartPar
0x3FF4\_3FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
SPI0
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF4\_4000
&
\sphinxAtStartPar
0x3FF4\_4FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
GPIO
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0x3FF4\_5000
&
\sphinxAtStartPar
0x3FF4\_7FFF
&
\sphinxAtStartPar
12 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF4\_8000
&
\sphinxAtStartPar
0x3FF4\_8FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
RTC
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF4\_9000
&
\sphinxAtStartPar
0x3FF4\_9FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
IO MUX
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0x3FF4\_A000
&
\sphinxAtStartPar
0x3FF4\_AFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF4\_B000
&
\sphinxAtStartPar
0x3FF4\_BFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
SDIO Slave
&
\sphinxAtStartPar
{[}三个部分之一{]}
\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF4\_C000
&
\sphinxAtStartPar
0x3FF4\_CFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
UDMA1
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0x3FF4\_D000
&
\sphinxAtStartPar
0x3FF4\_EFFF
&
\sphinxAtStartPar
8 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF4\_F000
&
\sphinxAtStartPar
0x3FF4\_FFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
I2S0
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF5\_0000
&
\sphinxAtStartPar
0x3FF5\_0FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
UART1
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0x3FF5\_1000
&
\sphinxAtStartPar
0x3FF5\_2FFF
&
\sphinxAtStartPar
8 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF5\_3000
&
\sphinxAtStartPar
0x3FF5\_3FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
I2C0
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF5\_4000
&
\sphinxAtStartPar
0x3FF5\_4FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
UDMA0
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF5\_5000
&
\sphinxAtStartPar
0x3FF5\_5FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
SDIO Slave
&
\sphinxAtStartPar
{[}三个部分之一{]}
\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF5\_6000
&
\sphinxAtStartPar
0x3FF5\_6FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
RMT
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF5\_7000
&
\sphinxAtStartPar
0x3FF5\_7FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
PCNT
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF5\_8000
&
\sphinxAtStartPar
0x3FF5\_8FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
SDIO Slave
&
\sphinxAtStartPar
{[}三个部分之一{]}
\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF5\_9000
&
\sphinxAtStartPar
0x3FF5\_9FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
LED PWM
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF5\_A000
&
\sphinxAtStartPar
0x3FF5\_AFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
eFuse Controller
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF5\_B000
&
\sphinxAtStartPar
0x3FF5\_BFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
Flash Encryption
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0x3FF5\_C000
&
\sphinxAtStartPar
0x3FF5\_DFFF
&
\sphinxAtStartPar
8 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF5\_E000
&
\sphinxAtStartPar
0x3FF5\_EFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
MCPWM0
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF5\_F000
&
\sphinxAtStartPar
0x3FF5\_FFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
TIMG0
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF6\_0000
&
\sphinxAtStartPar
0x3FF6\_0FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
TIMG1
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0x3FF6\_1000
&
\sphinxAtStartPar
0x3FF6\_3FFF
&
\sphinxAtStartPar
12 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF6\_4000
&
\sphinxAtStartPar
0x3FF6\_4FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
SPI2
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF6\_5000
&
\sphinxAtStartPar
0x3FF6\_5FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
SPI3
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF6\_6000
&
\sphinxAtStartPar
0x3FF6\_6FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
SYSCON
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF6\_7000
&
\sphinxAtStartPar
0x3FF6\_7FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
I2C1
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF6\_8000
&
\sphinxAtStartPar
0x3FF6\_8FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
SDMMC
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF6\_9000
&
\sphinxAtStartPar
0x3FF6\_AFFF
&
\sphinxAtStartPar
8 KB
&
\sphinxAtStartPar
EMAC
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF6\_B000
&
\sphinxAtStartPar
0x3FF6\_BFFF
&
\sphinxAtStartPar
4KB
&
\sphinxAtStartPar
TWAI
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF6\_C000
&
\sphinxAtStartPar
0x3FF6\_CFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
MCPWM1
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF6\_D000
&
\sphinxAtStartPar
0x3FF6\_DFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
I2S1
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF6\_E000
&
\sphinxAtStartPar
0x3FF6\_EFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
UART2
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF6\_F000
&
\sphinxAtStartPar
0x3FF6\_FFFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF7\_0000
&
\sphinxAtStartPar
0x3FF7\_0FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0x3FF7\_1000
&
\sphinxAtStartPar
0x3FF7\_4FFF
&
\sphinxAtStartPar
16 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
数据
&
\sphinxAtStartPar
0x3FF7\_5000
&
\sphinxAtStartPar
0x3FF7\_5FFF
&
\sphinxAtStartPar
4 KB
&
\sphinxAtStartPar
RNG
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar

&
\sphinxAtStartPar
0x3FF7\_6000
&
\sphinxAtStartPar
0x3FF7\_FFFF
&
\sphinxAtStartPar
40 KB
&
\sphinxAtStartPar
保留
&
\sphinxAtStartPar

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

\sphinxAtStartPar
注意：
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用 0x3FF40000 \textasciitilde{} 0x3FF7FFFF 地址空间 (DPORT) 访问的外设，CPU 也可以使用 0x60000000 \textasciitilde{} 0x6003FFFF 地址空间 (AHB) 访问。即使用 (0x3FF40000 + n) 地址和使用 (0x60000000 + n) 地址访问的内容是相同的，其中 n = 0 \textasciitilde{} 0x3FFFF。

\item {} 
\sphinxAtStartPar
相比于通过 AHB 访问外设，CPU 通过 DPORT 访问外设效率更高。但是 DPORT 有预测性读 (speculative read) 的特点，不能保证每一次的读访问都是真实有效的。另外，DPORT 会打乱总线上的读写操作的先后顺序以提升性能，这可能会导致对读写操作的先后顺序有严格要求的程序发生崩溃。此外使用 AHB 总线读 FIFO 会出现无法预知的错误。

\end{itemize}


\subparagraph{\sphinxstylestrong{不对称} PID Controller \sphinxstylestrong{外设}}
\label{\detokenize{dev-board/esp32:pid-controller}}
\sphinxAtStartPar
系统中有两个 PID Controller 分别服务于 PRO\_CPU 和 APP\_CPU。PRO\_CPU \sphinxstylestrong{和} APP\_CPU \sphinxstylestrong{都只能访问自己的} PID Controller**，不能访问对方的** PID Controller**。**两个 CPU 都使用数据总线 0x3FF1\_F000 \textasciitilde{} 3FF1\_FFFF 访问自己的 PID Controller。


\subparagraph{不连续外设地址范围}
\label{\detokenize{dev-board/esp32:id14}}
\sphinxAtStartPar
外设模块 SDIO Slave 被划分为三部分。两个 CPU 访问这三部分的地址是不连续的。这三部分分别被两个 CPU 的数据总线 0x3FF4\_B000 \textasciitilde{} 3FF4\_BFFF、0x3FF5\_5000 \textasciitilde{} 3FF5\_5FFF、0x3FF5\_8000 \textasciitilde{} 3FF5\_8FFF 访问。和其他外设一样，SDIO Slave 能被两个 CPU 访问。


\subparagraph{存储器速度}
\label{\detokenize{dev-board/esp32:id15}}
\sphinxAtStartPar
ROM 和 SRAM 的时钟源都是 CPU\_CLK，CPU 可在单个时钟周期内访问这两个存储器。由于 RTC FAST Memory 的时钟源是 APB\_CLOCK，RTC SLOW Memory 的时钟源是 FAST\_CLOCK，所以 CPU 访问这两个存储器的速度稍慢。DMA 在 APB\_CLK 时钟下访问存储器。

\sphinxAtStartPar
SRAM 每 32K 为一个块。只要同时访问的是不同的块，那么 CPU 和 DMA 可以同时以最快速度访问 SRAM。

\sphinxstepscope


\subsection{STM32L475}
\label{\detokenize{dev-board/stm32l475:stm32l475}}\label{\detokenize{dev-board/stm32l475::doc}}
\sphinxAtStartPar
待更新

\sphinxstepscope


\section{\sphinxstyleliteralintitle{\sphinxupquote{Clion}} 项目工程基础}
\label{\detokenize{dev-board/clion:clion}}\label{\detokenize{dev-board/clion::doc}}

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{Clion}} 特点}
\label{\detokenize{dev-board/clion:id1}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CLion}} 是一款跨平台的集成开发环境（IDE），专为 C 和 C++编程语言开发而设计。它由 JetBrains 公司开发，该公司也是创建 IntelliJ IDEA、PyCharm 等流行 IDE 的公司。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CLion}} 的代码分析能力非常强大，它能够帮助开发人员识别不同类型的错误和警告，并提供改进代码的建议。这反过来可以帮助开发人员及早发现错误，提高代码质量。

\sphinxAtStartPar
除了代码分析，\sphinxcode{\sphinxupquote{CLion}} 还提供了一系列调试工具，帮助开发人员在其代码中查找和修复错误。它支持本地和远程调试，并允许您同时调试多个线程，可以省大量时间。

\sphinxAtStartPar
此外，\sphinxcode{\sphinxupquote{CLion}} 还提供了集成的版本控制系统（VCS）支持，使您可以轻松管理代码更改并与其他开发人员协作。它支持 Git、SVN、Mercurial 等流行的 VCS 系统。这确保了开发人员可以无缝高效地协作。

\sphinxAtStartPar
同是它是提供跨平台支持的。它在 Windows、macOS 和 Linux 上可以无缝运行，因此您可以使用您喜欢的操作系统而不会出现任何兼容性问题。尽管如此，我们仍建议使用 Linux 平台为基础进行 cion 的相关开发。

\sphinxAtStartPar
\sphinxstylestrong{\sphinxcode{\sphinxupquote{CLion}} 对于嵌入式开发提供了广泛的支持}。它能够轻松地与嵌入式开发工具链集成，并支持多种嵌入式平台和微控制器。

\sphinxAtStartPar
首先，\sphinxcode{\sphinxupquote{CLion}} 支持嵌入式开发的调试。它能够与 GDB 和 LLDB 等调试器集成，支持本地和远程调试，并允许您在嵌入式设备上调试应用程序。此外，\sphinxcode{\sphinxupquote{CLion}} 还支持 J\sphinxhyphen{}Link，ST\sphinxhyphen{}Link 和 OpenOCD 等常用的调试器。

\sphinxAtStartPar
其次，\sphinxcode{\sphinxupquote{CLion}} 提供了对嵌入式开发环境的良好支持。它能够自动识别嵌入式编译器和工具链，并自动配置工程。它还能够在单个工程中管理多个嵌入式平台，以及自动检测和安装缺失的工具和库。


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{Clion}} 对嵌入式开发支持}
\label{\detokenize{dev-board/clion:id2}}
\sphinxAtStartPar
除此之外，\sphinxcode{\sphinxupquote{CLion}} 还提供了嵌入式开发的代码分析和代码完成功能。它支持针对嵌入式编程的特定代码检查，以帮助您在代码中发现和解决错误。同时，它还提供了代码完成和自动代码重构功能，以提高开发效率。

\sphinxAtStartPar
最后，\sphinxcode{\sphinxupquote{CLion}} 还提供了对跨平台嵌入式开发的支持。它支持嵌入式 Linux 平台和各种常见的嵌入式操作系统，例如\sphinxstylestrong{FreeRTOS}和 Zephyr。\sphinxstylestrong{\sphinxcode{\sphinxupquote{CLion}} 还能够集成 CMake}，以简化跨平台嵌入式开发的构建和配置。

\sphinxAtStartPar
综上所述，\sphinxcode{\sphinxupquote{CLion}} 是一款功能强大且易于使用的集成开发环境，特别适用于嵌入式开发。


\subsection{Cmake 与 \sphinxstyleliteralintitle{\sphinxupquote{makefile}}}
\label{\detokenize{dev-board/clion:cmake-makefile}}
\sphinxAtStartPar
\sphinxstylestrong{Cmake}是 \sphinxcode{\sphinxupquote{Clion}} 所采用的自动化构建工具，因此在了解 \sphinxcode{\sphinxupquote{Clion}} 之前，有必要掌握 Cmake 的基础知识。

\sphinxAtStartPar
CMake 是由 Kitware 公司的 Bill Hoffman 在 2000 年开发的一款跨平台自动化构建工具。\sphinxstylestrong{它是基于早期的 Make 工具和 CMake 的前身 cmake 1.x 版本发展而来}，目的是提供一个更强大、更易于使用和跨平台的自动化构建工具。CMake 最初是为了构建 VTK（Visualization ToolKit）和 ITK（Image Registration and Segmentation Toolkit）等项目而开发的，但现在已成为许多开源项目的构建工具，如 Boost、KDE、OpenCV 等等。

\sphinxAtStartPar
CMake 的主要优势包括：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
跨平台支持：CMake 可以自动生成适合不同操作系统和编译器的构建系统文件，使得开发人员可以在 Windows、Linux、MacOS 等不同平台上轻松构建项目。

\item {} 
\sphinxAtStartPar
灵活性：CMake 提供了丰富的配置选项，使得开发人员可以自由地控制编译器选项、链接选项、预处理器定义等。

\item {} 
\sphinxAtStartPar
可扩展性：CMake 提供了模块化的插件系统，允许开发人员编写自定义命令、函数、模块等，以满足不同项目的需求。

\item {} 
\sphinxAtStartPar
自动化构建：CMake 可以自动检测源文件、头文件和库文件等，从而自动构建项目。

\item {} 
\sphinxAtStartPar
与 IDE 的集成：CMake 可以与各种常见的 IDE 集成，如 Visual Studio、Eclipse、Qt Creator 等，使得开发人员可以在自己熟悉的开发环境中使用 CMake。

\end{enumerate}

\sphinxAtStartPar
CMake 可以用于生成各种不同类型的构建系统，如 \sphinxcode{\sphinxupquote{Makefile}}、Visual Studio Solution、Xcode 项目等等。CMake 的目标是简化软件开发过程中的构建和配置，尤其是在跨平台和复杂项目中。

\sphinxAtStartPar
为了更深入的了解 cmake 的基础，就必须要从早期的构建工具 Make 说起。


\subsubsection{Make 构建工具}
\label{\detokenize{dev-board/clion:make}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Makefile}} 是一种用于构建（build）软件的工具，通常用于编译源代码、链接库文件和生成可执行程序。以下是 make 的编译链接过程简图：

\sphinxAtStartPar
:arrow\_right\_hook: 预处理 —> 编译 —> 汇编 —> 连接

\sphinxAtStartPar
\sphinxincludegraphics{{compile-flow}.png}


\paragraph{预处理：}
\label{\detokenize{dev-board/clion:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
任务：处理宏定义，文件包含，条件编译（加\#开头的，命令）

\item {} 
\sphinxAtStartPar
name.c(源代码)—\sphinxhyphen{}>name.i(改装后的)
\sphinxcode{\sphinxupquote{gcc \sphinxhyphen{}E name.c \sphinxhyphen{}o name.i}}

\end{itemize}


\paragraph{编译：}
\label{\detokenize{dev-board/clion:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
任务：检查语法

\item {} 
\sphinxAtStartPar
name.i(改装后的)—\sphinxhyphen{}>name.s(汇编代码)
\sphinxcode{\sphinxupquote{gcc \sphinxhyphen{}S name.i \sphinxhyphen{}o name.s}}

\end{itemize}


\paragraph{汇编：}
\label{\detokenize{dev-board/clion:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
任务：汇编代码转机器码

\item {} 
\sphinxAtStartPar
name.s(汇编代码)—>name.o(二进制目标文件)

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gcc \sphinxhyphen{}c name.s \sphinxhyphen{}o name.o}}

\end{itemize}


\paragraph{链接：}
\label{\detokenize{dev-board/clion:id6}}\begin{itemize}
\item {} 
\sphinxAtStartPar
任务：将经过编译的若干个中间文件（二进制目标文件）和系统库（.a/.lib）链接为可执行文件

\item {} 
\sphinxAtStartPar
name.o—\sphinxhyphen{}>a.out/name.exe（可执行程序）

\item {} 
\sphinxAtStartPar
静态链接：整个拷贝库文件进可执行程序

\item {} 
\sphinxAtStartPar
动态链接：可执行文件中加入了所调用函数的描述信息，运行时再去链接动态库（DLL），根据链接产生的重定位信息，去寻找和执行 DLL 中相应的函数代码。
\sphinxcode{\sphinxupquote{gcc name.o \sphinxhyphen{}o name}}

\end{itemize}


\paragraph{\sphinxstyleliteralintitle{\sphinxupquote{makefile}} 书写}
\label{\detokenize{dev-board/clion:makefile}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
target... : dependency...
command
...
...

\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
target：目标文件(.o)/可执行文件/标签(Label)

\item {} 
\sphinxAtStartPar
dependency：生成 target 需要的依赖

\item {} 
\sphinxAtStartPar
command：make 真正要执行的命令（任意的 shell 命令）
\sphinxstylestrong{检查，dependency 中文件若更新，此 make 命令就会被执行，会引起链式反应}

\end{itemize}


\paragraph{make 命令执行}
\label{\detokenize{dev-board/clion:id7}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{make}}
执行第一个 target，根据依赖性向后寻找并执行
\sphinxcode{\sphinxupquote{make Label}}
去 Label 处开始执行，如 clean（clean 无依赖，不用检查）
\begin{itemize}
\item {} 
\sphinxAtStartPar
删除所有中间文件

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
clean :
rm \PYGZhy{}f \PYGZbs{}*.o

\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{make clean}}执行


\subsubsection{简易版本的 \sphinxstyleliteralintitle{\sphinxupquote{makefile}} 编写}
\label{\detokenize{dev-board/clion:id8}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} `Makefile`示例}

\PYG{c}{\PYGZsh{} 目标：依赖}
\PYG{n+nf}{hello}\PYG{o}{:} \PYG{n}{main}.\PYG{n}{o} \PYG{n}{hello}.\PYG{n}{o}
        gcc \PYGZhy{}o hello main.o hello.o

\PYG{c}{\PYGZsh{} 目标：依赖}
\PYG{n+nf}{main.o}\PYG{o}{:} \PYG{n}{main}.\PYG{n}{c}
        gcc \PYGZhy{}c main.c

\PYG{c}{\PYGZsh{} 目标：依赖}
\PYG{n+nf}{hello.o}\PYG{o}{:} \PYG{n}{hello}.\PYG{n}{c}
        gcc \PYGZhy{}c hello.c

\PYG{n+nf}{clean }\PYG{o}{:}
    rm \PYGZhy{}f *.o
\end{sphinxVerbatim}

\sphinxAtStartPar
在上面的 \sphinxcode{\sphinxupquote{Makefile}} 中，我们定义了三个目标：\sphinxcode{\sphinxupquote{hello}}、\sphinxcode{\sphinxupquote{main.o}}和\sphinxcode{\sphinxupquote{hello.o}}。\sphinxcode{\sphinxupquote{hello}}目标依赖于\sphinxcode{\sphinxupquote{main.o}}和\sphinxcode{\sphinxupquote{hello.o}}两个文件，\sphinxcode{\sphinxupquote{main.o}}和\sphinxcode{\sphinxupquote{hello.o}}分别依赖于对应的源代码文件。

\sphinxAtStartPar
当我们在命令行上输入\sphinxcode{\sphinxupquote{make hello}}命令时，Make 会读取 \sphinxcode{\sphinxupquote{Makefile}} 文件并根据依赖关系来构建\sphinxcode{\sphinxupquote{hello}}目标文件。由于\sphinxcode{\sphinxupquote{hello}}目标文件依赖于\sphinxcode{\sphinxupquote{main.o}}和\sphinxcode{\sphinxupquote{hello.o}}两个文件，Make 会检查它们的时间戳来确定是否需要重新构建。如果\sphinxcode{\sphinxupquote{main.o}}和\sphinxcode{\sphinxupquote{hello.o}}的时间戳比\sphinxcode{\sphinxupquote{hello}}文件的时间戳新，则需要重新构建\sphinxcode{\sphinxupquote{hello}}文件。

\sphinxAtStartPar
如果需要重新构建，Make 会执行所定义的命令来生成\sphinxcode{\sphinxupquote{hello}}文件。在本例中，我们使用 gcc 编译器将\sphinxcode{\sphinxupquote{main.o}}和\sphinxcode{\sphinxupquote{hello.o}}链接起来生成可执行文件\sphinxcode{\sphinxupquote{hello}}。

\sphinxAtStartPar
以上是一个简单的例子，但是，当项目规模变大时，\sphinxcode{\sphinxupquote{makefile}} 就变得越来越复杂，像魔鬼一样令人恐怖。此外，还有其他的严重问题构成了 makefile 的障碍，如下：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{学习曲线较陡峭}：相比于其他构建工具，Makefile 的语法和规则比较复杂，需要一定的学习成本。

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{难以维护}：当项目规模变大，Makefile 会变得越来越复杂，不易于维护和扩展。

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{平台依赖}：Makefile 是一种平台依赖性很强的构建工具，同一个 Makefile 文件可能在不同的操作系统上需要进行不同的修改。

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{不适用于所有项目}：Makefile 适用于 C/C++等编译型语言的构建，但不适用于其他类型的项目，如 Java、Python 等。

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{缺乏依赖管理}：Makefile 的依赖关系是通过文件时间戳来检测的，但如果依赖关系过于复杂，Makefile 就难以处理。

\end{enumerate}

\sphinxAtStartPar
此外，除了 GNU Make ，还有 QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：\sphinxstylestrong{如果软件想跨平台}，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。

\sphinxAtStartPar
居于上述理由，人们可是制作更为简单易行，跨平台的构建工具，这时 cmake 就孕育而生了。


\subsection{Cmake 基本概念}
\label{\detokenize{dev-board/clion:cmake}}
\sphinxAtStartPar
CMake 就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等 。在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
写 CMake 配置文件 CMakeLists.txt 。

\item {} 
\sphinxAtStartPar
执行命令 \sphinxcode{\sphinxupquote{cmake PATH}} 或者 \sphinxcode{\sphinxupquote{ccmake PATH}} 生成 Makefile（\sphinxcode{\sphinxupquote{ccmake}} 和 \sphinxcode{\sphinxupquote{cmake}} 的区别在于前者提供了一个交互式的界面）。其中， \sphinxcode{\sphinxupquote{PATH}} 是 CMakeLists.txt 所在的目录。

\item {} 
\sphinxAtStartPar
使用 \sphinxcode{\sphinxupquote{make}} 命令进行编译。

\end{enumerate}

\sphinxAtStartPar
以下是 CMake 的一些基本概念：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
CMakeLists.txt 文件：CMakeLists.txt 是 CMake 项目的核心配置文件，它包含了项目的名称、源文件、目标文件等信息。

\item {} 
\sphinxAtStartPar
源目录和构建目录：源目录是项目源代码的根目录，而构建目录是指生成构建系统文件的目录。CMake 建议将构建目录与源目录分离，以便于保持源目录的干净和整洁。

\item {} 
\sphinxAtStartPar
CMake 命令：CMake 使用命令来定义项目的构建过程。CMake 命令可以用来定义项目的名称、源文件、编译器选项、链接选项等信息。

\item {} 
\sphinxAtStartPar
变量：变量在 CMake 中用于存储和传递值。CMake 支持三种类型的变量：字符串变量、列表变量和缓存变量。

\item {} 
\sphinxAtStartPar
宏：宏是一种定义重复代码的方式。在 CMake 中，可以使用宏来定义和调用函数。

\item {} 
\sphinxAtStartPar
模块：CMake 模块是一组可重用的 CMake 命令和函数，它们可以在多个项目中共享和使用。

\item {} 
\sphinxAtStartPar
CMake 的常用命令和函数：常用命令和函数包括 add\_executable、add\_library、target\_link\_libraries、include\_directories、find\_package 等等。

\end{enumerate}

\sphinxAtStartPar
cmake 的处理过程如下：

\sphinxAtStartPar
\sphinxincludegraphics{{cmake-flow}.png}

\sphinxAtStartPar
可以 cmake 是一种项目构建的生成工具，不但用与 make 生成 \sphinxcode{\sphinxupquote{makefile}}，同时可以和其他构建工具，如 ninja，gradle 等一同工作。


\subsection{Cmake 快速入门与相关书籍}
\label{\detokenize{dev-board/clion:id9}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://cmake.org}{:link:官方参考文档}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dev-board/cmake::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{:link:Cmake 快速入门}}}}

\item {} 
\sphinxAtStartPar
相关书籍推荐
\begin{itemize}
\item {} 
\sphinxAtStartPar
《CMake 实践指南》 作者：熊英飞、彭泽源

\sphinxAtStartPar
该书内容详实，从 CMake 基础语法、常用命令、函数和变量到实际项目实践都有涉及，适合初学者入门以及实际项目开发者参考。

\item {} 
\sphinxAtStartPar
《跟我一起写 \sphinxcode{\sphinxupquote{Makefile}}》作者：韩天峰

\sphinxAtStartPar
该书介绍了 \sphinxcode{\sphinxupquote{Makefile}} 的基本语法和使用方法，同时也有对比 CMake 的介绍。对于初学者来说，可用来作为入门的学习资料。

\item {} 
\sphinxAtStartPar
《CMake 入门实战》作者：李海峰

\sphinxAtStartPar
该书内容包括 CMake 的基本语法、变量和函数、项目构建、跨平台构建等方面，并配有大量实战案例，适合实际项目开发者参考。

\item {} 
\sphinxAtStartPar
《深入浅出 CMake》作者：李泽阳

\sphinxAtStartPar
该书从 CMake 的基础语法和常用命令入手，深入探讨了 CMake 的内部机制和实现原理，适合对 CMake 深入理解和研究的开发者参考。

\end{itemize}

\end{itemize}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{Clion}} 项目结构}
\label{\detokenize{dev-board/clion:id10}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CLion}} 项目结构与其他 C 和 C++ 项目结构非常相似，但有一些特定于 \sphinxcode{\sphinxupquote{CLion}} 的功能。

\sphinxAtStartPar
在 \sphinxcode{\sphinxupquote{CLion}} 中，一个项目包含以下内容：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
项目文件夹：包含项目文件、源代码和其他文件。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CMakeLists.txt}} 文件：\sphinxcode{\sphinxupquote{CLion}} 使用 CMake 构建系统来管理项目构建。CMakeLists.txt` 文件描述了项目的构建过程。它指定源代码文件、可执行文件的名称和位置、库的名称和位置等。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.idea}} 文件夹：包含 \sphinxcode{\sphinxupquote{CLion}} 的项目配置文件。这些文件包括编译器选项、代码样式设置、调试设置等。这个文件夹是可选的，如果不存在，\sphinxcode{\sphinxupquote{CLion}} 会在打开项目时自动生成它。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bin}} 文件夹：包含编译后的可执行文件。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{build}} 文件夹：包含构建系统生成的临时文件和中间文件。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{include}} 文件夹：包含项目使用的头文件。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lib}} 文件夹：包含项目使用的库文件。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{src}} 文件夹：包含项目的源代码文件。

\end{enumerate}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CLion}} 的项目结构可以根据项目的需要进行调整和扩展。例如，可以在项目中添加子目录，将源文件分组为不同的目录，或者将库和头文件分开放置。

\sphinxAtStartPar
假设有一个名为 \sphinxcode{\sphinxupquote{MyProject}} 的 C++ 项目，该项目包含以下文件和文件夹：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MyProject/}}：项目文件夹。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MyProject/CMakeLists.txt}}：描述项目构建过程的 CMake 文件。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MyProject/.idea/}}：\sphinxcode{\sphinxupquote{CLion}} 的项目配置文件夹。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MyProject/bin/}}：包含可执行文件。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MyProject/build/}}：包含构建系统生成的临时文件和中间文件。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MyProject/include/}}：包含头文件。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MyProject/lib/}}：包含库文件。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MyProject/src/}}：包含源代码文件。

\end{itemize}

\sphinxAtStartPar
下面是一个示例 \sphinxcode{\sphinxupquote{**CMakeLists.txt**}}文件，它描述了一个简单的 \sphinxcode{\sphinxupquote{MyProject}} 项目的构建过程：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cmake\PYGZus{}minimum\PYGZus{}required}\PYG{p}{(}\PYG{l+s}{VERSION}\PYG{+w}{ }\PYG{l+s}{3.10}\PYG{p}{)}

\PYG{n+nb}{project}\PYG{p}{(}\PYG{l+s}{MyProject}\PYG{p}{)}

\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{CMAKE\PYGZus{}CXX\PYGZus{}STANDARD}\PYG{+w}{ }\PYG{l+s}{11}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 指定源文件}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{SOURCE\PYGZus{}FILES}
\PYG{+w}{    }\PYG{l+s}{src/main.cpp}
\PYG{+w}{    }\PYG{l+s}{src/foo.cpp}
\PYG{+w}{    }\PYG{l+s}{src/bar.cpp}
\PYG{p}{)}

\PYG{c}{\PYGZsh{} 指定头文件}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{HEADER\PYGZus{}FILES}
\PYG{+w}{    }\PYG{l+s}{include/foo.h}
\PYG{+w}{    }\PYG{l+s}{include/bar.h}
\PYG{p}{)}

\PYG{c}{\PYGZsh{} 添加可执行文件}
\PYG{n+nb}{add\PYGZus{}executable}\PYG{p}{(}\PYG{l+s}{MyProject}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{SOURCE\PYGZus{}FILES}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{HEADER\PYGZus{}FILES}\PYG{o}{\PYGZcb{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 指定库文件路径}
\PYG{n+nb}{link\PYGZus{}directories}\PYG{p}{(}\PYG{l+s}{lib}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 指定需要链接的库}
\PYG{n+nb}{target\PYGZus{}link\PYGZus{}libraries}\PYG{p}{(}\PYG{l+s}{MyProject}\PYG{+w}{ }\PYG{l+s}{libfoo.a}\PYG{+w}{ }\PYG{l+s}{libbar.a}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
在上面的示例中，\sphinxcode{\sphinxupquote{CMakeLists.txt}} 文件指定了项目的源代码文件和头文件。它还定义了一个可执行文件 \sphinxcode{\sphinxupquote{MyProject}}，它由源代码文件和头文件组成。项目中使用的库文件位于 \sphinxcode{\sphinxupquote{lib/}} 文件夹中。通过使用 \sphinxcode{\sphinxupquote{link\_directories()}} 和 \sphinxcode{\sphinxupquote{target\_link\_libraries()}} 函数，可以将库文件链接到可执行文件中。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CLion}} 会读取这个 \sphinxcode{\sphinxupquote{CMakeLists.txt}} 文件，并根据它来构建项目。 \sphinxcode{\sphinxupquote{CLion}} 还会自动创建一个 \sphinxcode{\sphinxupquote{.idea}} 文件夹，并在其中生成一些配置文件。当您打开 \sphinxcode{\sphinxupquote{MyProject}} 项目时，\sphinxcode{\sphinxupquote{CLion}} 会读取这些配置文件，并应用它们来设置项目的编译器选项、代码样式设置、调试设置等。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{clion}} 的图形化过程我们将在 esp\sphinxhyphen{}idf 中，以及具体实验内容中一并介绍。

\sphinxstepscope


\section{:link:Cmake 速成}
\label{\detokenize{dev-board/cmake:link-cmake}}\label{\detokenize{dev-board/cmake::doc}}\begin{quote}

\sphinxAtStartPar
以下内容节选自网络文章。
\end{quote}


\subsection{什么是 CMake?}
\label{\detokenize{dev-board/cmake:cmake}}
\sphinxAtStartPar
你或许听过好几种 Make 工具，例如 GNU Make ，QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。CMake 就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等 {[}1{]}。在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
写 CMake 配置文件 CMakeLists.txt 。

\item {} 
\sphinxAtStartPar
执行命令 \sphinxcode{\sphinxupquote{cmake PATH}} 或者 \sphinxcode{\sphinxupquote{ccmake PATH}} 生成 Makefile（\sphinxcode{\sphinxupquote{ccmake}} 和 \sphinxcode{\sphinxupquote{cmake}} 的区别在于前者提供了一个交互式的界面）。其中， \sphinxcode{\sphinxupquote{PATH}} 是 CMakeLists.txt 所在的目录。

\item {} 
\sphinxAtStartPar
使用 \sphinxcode{\sphinxupquote{make}} 命令进行编译。

\end{enumerate}


\subsection{入门案例：单个源文件}
\label{\detokenize{dev-board/cmake:id1}}
\sphinxAtStartPar
本节对应的源代码所在目录：
\begin{quote}

\sphinxAtStartPar
\sphinxhref{https://link.zhihu.com/?target=https\%3A//github.com/wzpan/cmake-demo/tree/master/Demo1}{https://github.com/wzpan/cmake\sphinxhyphen{}demo/tree/master/Demo1}
\end{quote}

\sphinxAtStartPar
对于简单的项目，只需要写几行代码就可以了。例如，假设现在我们的项目中只有一个源文件 main.cc ，该程序的用途是计算一个数的指数幂。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{ }\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{ * power \PYGZhy{} Calculate the power of number.}
\PYG{c+cm}{ * @param base: Base value.}
\PYG{c+cm}{ * @param exponent: Exponent value.}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * @return base raised to the power exponent.}
\PYG{c+cm}{ */}
\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n+nf}{power}\PYG{p}{(}\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{base}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{exponent}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{base}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{exponent}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{exponent}\PYG{p}{;}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{base}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{argc}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{argc}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Usage: \PYGZpc{}s base exponent }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{base}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{atof}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{exponent}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{atoi}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{power}\PYG{p}{(}\PYG{n}{base}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{exponent}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}g \PYGZca{} \PYGZpc{}d is \PYGZpc{}g}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{base}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{exponent}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{编写 CMakeLists.txt}
\label{\detokenize{dev-board/cmake:cmakelists-txt}}
\sphinxAtStartPar
首先编写 CMakeLists.txt 文件，并保存在与 \sphinxhref{https://link.zhihu.com/?target=http\%3A//main.cc}{http://main.cc} 源文件同个目录下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} CMake 最低版本号要求}
\PYG{n+nb}{cmake\PYGZus{}minimum\PYGZus{}required} \PYG{p}{(}\PYG{l+s}{VERSION}\PYG{+w}{ }\PYG{l+s}{2.8}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 项目信息}
\PYG{n+nb}{project} \PYG{p}{(}\PYG{l+s}{Demo1}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 指定生成目标}
\PYG{n+nb}{add\PYGZus{}executable}\PYG{p}{(}\PYG{l+s}{Demo}\PYG{+w}{ }\PYG{l+s}{main.cc}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 \sphinxcode{\sphinxupquote{\#}} 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。对于上面的 CMakeLists.txt 文件，依次出现了几个命令：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cmake\_minimum\_required}}：指定运行此配置文件所需的 CMake 的最低版本；

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{project}}：参数值是 \sphinxcode{\sphinxupquote{Demo1}}，该命令表示项目的名称是 \sphinxcode{\sphinxupquote{Demo1}} 。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{add\_executable}}：将名为 main.cc 的源文件编译成一个名称为 Demo 的可执行文件。

\end{enumerate}


\subsubsection{编译项目}
\label{\detokenize{dev-board/cmake:id2}}
\sphinxAtStartPar
之后，在当前目录执行 \sphinxcode{\sphinxupquote{cmake .}} ，得到 Makefile 后再使用 \sphinxcode{\sphinxupquote{make}} 命令编译得到 Demo1 可执行文件。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}ehome@xman Demo1\PYG{o}{]}\PYGZdl{} cmake .
\PYGZhy{}\PYGZhy{} The C compiler identification is GNU \PYG{l+m}{4}.8.2
\PYGZhy{}\PYGZhy{} The CXX compiler identification is GNU \PYG{l+m}{4}.8.2
\PYGZhy{}\PYGZhy{} Check \PYG{k}{for} working C compiler: /usr/sbin/cc
\PYGZhy{}\PYGZhy{} Check \PYG{k}{for} working C compiler: /usr/sbin/cc \PYGZhy{}\PYGZhy{} works
\PYGZhy{}\PYGZhy{} Detecting C compiler ABI info
\PYGZhy{}\PYGZhy{} Detecting C compiler ABI info \PYGZhy{} \PYG{k}{done}
\PYGZhy{}\PYGZhy{} Check \PYG{k}{for} working CXX compiler: /usr/sbin/c++
\PYGZhy{}\PYGZhy{} Check \PYG{k}{for} working CXX compiler: /usr/sbin/c++ \PYGZhy{}\PYGZhy{} works
\PYGZhy{}\PYGZhy{} Detecting CXX compiler ABI info
\PYGZhy{}\PYGZhy{} Detecting CXX compiler ABI info \PYGZhy{} \PYG{k}{done}
\PYGZhy{}\PYGZhy{} Configuring \PYG{k}{done}
\PYGZhy{}\PYGZhy{} Generating \PYG{k}{done}
\PYGZhy{}\PYGZhy{} Build files have been written to: /home/ehome/Documents/programming/C/power/Demo1
\PYG{o}{[}ehome@xman Demo1\PYG{o}{]}\PYGZdl{} make
Scanning dependencies of target Demo
\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]} Building C object CMakeFiles/Demo.dir/main.cc.o
Linking C executable Demo
\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]} Built target Demo
\PYG{o}{[}ehome@xman Demo1\PYG{o}{]}\PYGZdl{} ./Demo \PYG{l+m}{5} \PYG{l+m}{4}
\PYG{l+m}{5} \PYGZca{} \PYG{l+m}{4} is \PYG{l+m}{625}
\PYG{o}{[}ehome@xman Demo1\PYG{o}{]}\PYGZdl{} ./Demo \PYG{l+m}{7} \PYG{l+m}{3}
\PYG{l+m}{7} \PYGZca{} \PYG{l+m}{3} is \PYG{l+m}{343}
\PYG{o}{[}ehome@xman Demo1\PYG{o}{]}\PYGZdl{} ./Demo \PYG{l+m}{2} \PYG{l+m}{10}
\PYG{l+m}{2} \PYGZca{} \PYG{l+m}{10} is \PYG{l+m}{1024}
\end{sphinxVerbatim}


\subsection{多个源文件}
\label{\detokenize{dev-board/cmake:id3}}

\subsubsection{同一目录，多个源文件}
\label{\detokenize{dev-board/cmake:id4}}
\sphinxAtStartPar
本小节对应的源代码所在目录：
\begin{quote}

\sphinxAtStartPar
\sphinxhref{https://link.zhihu.com/?target=https\%3A//github.com/wzpan/cmake-demo/tree/master/Demo2}{https://github.com/wzpan/cmake\sphinxhyphen{}demo/tree/master/Demo2}
\end{quote}

\sphinxAtStartPar
上面的例子只有单个源文件。现在假如把 \sphinxcode{\sphinxupquote{power}} 函数单独写进一个名为 \sphinxcode{\sphinxupquote{MathFunctions.c}} 的源文件里，使得这个工程变成如下的形式：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{.}\PYG{o}{/}\PYG{n}{Demo2}
\PYG{+w}{    }\PYG{o}{|}
\PYG{+w}{    }\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{.}\PYG{n}{cc}
\PYG{+w}{    }\PYG{o}{|}
\PYG{+w}{    }\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{MathFunctions}\PYG{p}{.}\PYG{n}{cc}
\PYG{+w}{    }\PYG{o}{|}
\PYG{+w}{    }\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{MathFunctions}\PYG{p}{.}\PYG{n}{h}
\end{sphinxVerbatim}

\sphinxAtStartPar
这个时候，CMakeLists.txt 可以改成如下的形式：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} CMake 最低版本号要求}
\PYG{n+nb}{cmake\PYGZus{}minimum\PYGZus{}required} \PYG{p}{(}\PYG{l+s}{VERSION}\PYG{+w}{ }\PYG{l+s}{2.8}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 项目信息}
\PYG{n+nb}{project} \PYG{p}{(}\PYG{l+s}{Demo2}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 指定生成目标}
\PYG{n+nb}{add\PYGZus{}executable}\PYG{p}{(}\PYG{l+s}{Demo}\PYG{+w}{ }\PYG{l+s}{main.cc}\PYG{+w}{ }\PYG{l+s}{MathFunctions.cc}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
唯一的改动只是在 \sphinxcode{\sphinxupquote{add\_executable}} 命令中增加了一个 \sphinxcode{\sphinxupquote{MathFunctions.cc}} 源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 \sphinxcode{\sphinxupquote{aux\_source\_directory}} 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{aux\PYGZus{}source\PYGZus{}directory}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{dir}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{n}{variable}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
因此，可以修改 CMakeLists.txt 如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ CMake 最低版本号要求}
\PYG{n}{cmake\PYGZus{}minimum\PYGZus{}required}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{VERSION}\PYG{+w}{ }\PYG{l+m+mf}{2.8}\PYG{p}{)}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ 项目信息}
\PYG{n}{project}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{Demo2}\PYG{p}{)}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ 查找当前目录下的所有源文件}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ 并将名称保存到 DIR\PYGZus{}SRCS 变量}
\PYG{n}{aux\PYGZus{}source\PYGZus{}directory}\PYG{p}{(}\PYG{p}{.}\PYG{+w}{ }\PYG{n}{DIR\PYGZus{}SRCS}\PYG{p}{)}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ 指定生成目标}
\PYG{n}{add\PYGZus{}executable}\PYG{p}{(}\PYG{n}{Demo}\PYG{+w}{ }\PYG{n}{\PYGZdl{}}\PYG{p}{\PYGZob{}}\PYG{n}{DIR\PYGZus{}SRCS}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
这样，CMake 会将当前目录所有源文件的文件名赋值给变量 \sphinxcode{\sphinxupquote{DIR\_SRCS}} ，再指示变量 \sphinxcode{\sphinxupquote{DIR\_SRCS}} 中的源文件需要编译成一个名称为 Demo 的可执行文件。


\subsubsection{多个目录，多个源文件}
\label{\detokenize{dev-board/cmake:id5}}
\sphinxAtStartPar
本小节对应的源代码所在目录：
\begin{quote}

\sphinxAtStartPar
\sphinxhref{https://link.zhihu.com/?target=https\%3A//github.com/wzpan/cmake-demo/tree/master/Demo3}{https://github.com/wzpan/cmake\sphinxhyphen{}demo/tree/master/Demo3}
\end{quote}

\sphinxAtStartPar
现在进一步将 MathFunctions.h 和 \sphinxhref{https://link.zhihu.com/?target=http\%3A//MathFunctions.cc}{http://MathFunctions.cc} 文件移动到 math 目录下。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{.}\PYG{o}{/}\PYG{n}{Demo3}
\PYG{+w}{    }\PYG{o}{|}
\PYG{+w}{    }\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{.}\PYG{n}{cc}
\PYG{+w}{    }\PYG{o}{|}
\PYG{+w}{    }\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{math}\PYG{o}{/}
\PYG{+w}{          }\PYG{o}{|}
\PYG{+w}{          }\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{MathFunctions}\PYG{p}{.}\PYG{n}{cc}
\PYG{+w}{          }\PYG{o}{|}
\PYG{+w}{          }\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{MathFunctions}\PYG{p}{.}\PYG{n}{h}
\end{sphinxVerbatim}

\sphinxAtStartPar
对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。根目录中的 CMakeLists.txt ：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} CMake 最低版本号要求}
\PYG{n+nb}{cmake\PYGZus{}minimum\PYGZus{}required} \PYG{p}{(}\PYG{l+s}{VERSION}\PYG{+w}{ }\PYG{l+s}{2.8}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 项目信息}
\PYG{n+nb}{project} \PYG{p}{(}\PYG{l+s}{Demo3}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 查找当前目录下的所有源文件}
\PYG{c}{\PYGZsh{} 并将名称保存到 DIR\PYGZus{}SRCS 变量}
\PYG{n+nb}{aux\PYGZus{}source\PYGZus{}directory}\PYG{p}{(}\PYG{l+s}{.}\PYG{+w}{ }\PYG{l+s}{DIR\PYGZus{}SRCS}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 添加 math 子目录}
\PYG{n+nb}{add\PYGZus{}subdirectory}\PYG{p}{(}\PYG{l+s}{math}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 指定生成目标}
\PYG{n+nb}{add\PYGZus{}executable}\PYG{p}{(}\PYG{l+s}{Demo}\PYG{+w}{ }\PYG{l+s}{main.cc}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 添加链接库}
\PYG{n+nb}{target\PYGZus{}link\PYGZus{}libraries}\PYG{p}{(}\PYG{l+s}{Demo}\PYG{+w}{ }\PYG{l+s}{MathFunctions}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
该文件添加了下面的内容: 第 3 行，使用命令 \sphinxcode{\sphinxupquote{add\_subdirectory}} 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理 。第 6 行，使用命令 \sphinxcode{\sphinxupquote{target\_link\_libraries}} 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。子目录中的 CMakeLists.txt：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 查找当前目录下的所有源文件}
\PYG{c}{\PYGZsh{} 并将名称保存到 DIR\PYGZus{}LIB\PYGZus{}SRCS 变量}
\PYG{n+nb}{aux\PYGZus{}source\PYGZus{}directory}\PYG{p}{(}\PYG{l+s}{.}\PYG{+w}{ }\PYG{l+s}{DIR\PYGZus{}LIB\PYGZus{}SRCS}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 生成链接库}
\PYG{n+nb}{add\PYGZus{}library} \PYG{p}{(}\PYG{l+s}{MathFunctions}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{DIR\PYGZus{}LIB\PYGZus{}SRCS}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
在该文件中使用命令 \sphinxcode{\sphinxupquote{add\_library}} 将 src 目录中的源文件编译为静态链接库。


\subsection{自定义编译选项}
\label{\detokenize{dev-board/cmake:id6}}
\sphinxAtStartPar
本节对应的源代码所在目录：
\begin{quote}

\sphinxAtStartPar
\sphinxhref{https://link.zhihu.com/?target=https\%3A//github.com/wzpan/cmake-demo/tree/master/Demo4}{https://github.com/wzpan/cmake\sphinxhyphen{}demo/tree/master/Demo4}
\end{quote}

\sphinxAtStartPar
CMake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。例如，可以将 MathFunctions 库设为一个可选的库，如果该选项为 \sphinxcode{\sphinxupquote{ON}} ，就使用该库定义的数学函数来进行运算。否则就调用标准库中的数学函数库。


\subsubsection{修改 CMakeLists 文件}
\label{\detokenize{dev-board/cmake:cmakelists}}
\sphinxAtStartPar
我们要做的第一步是在顶层的 CMakeLists.txt 文件中添加该选项：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} CMake 最低版本号要求}
\PYG{n+nb}{cmake\PYGZus{}minimum\PYGZus{}required} \PYG{p}{(}\PYG{l+s}{VERSION}\PYG{+w}{ }\PYG{l+s}{2.8}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 项目信息}
\PYG{n+nb}{project} \PYG{p}{(}\PYG{l+s}{Demo4}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 加入一个配置头文件，用于处理 CMake 对源码的设置}
\PYG{n+nb}{configure\PYGZus{}file} \PYG{p}{(}
\PYG{+w}{  }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}/config.h.in\PYGZdq{}}
\PYG{+w}{  }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}BINARY\PYGZus{}DIR\PYGZcb{}/config.h\PYGZdq{}}
\PYG{+w}{  }\PYG{p}{)}

\PYG{c}{\PYGZsh{} 是否使用自己的 MathFunctions 库}
\PYG{n+nb}{option} \PYG{p}{(}\PYG{l+s}{USE\PYGZus{}MYMATH}
\PYG{+w}{       }\PYG{l+s+s2}{\PYGZdq{}Use provided math implementation\PYGZdq{}}\PYG{+w}{ }\PYG{l+s}{ON}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 是否加入 MathFunctions 库}
\PYG{n+nb}{if} \PYG{p}{(}\PYG{l+s}{USE\PYGZus{}MYMATH}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{include\PYGZus{}directories} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}/math\PYGZdq{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{add\PYGZus{}subdirectory} \PYG{p}{(}\PYG{l+s}{math}\PYG{p}{)}
\PYG{+w}{  }\PYG{n+nb}{set} \PYG{p}{(}\PYG{l+s}{EXTRA\PYGZus{}LIBS}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{EXTRA\PYGZus{}LIBS}\PYG{o}{\PYGZcb{}}\PYG{+w}{ }\PYG{l+s}{MathFunctions}\PYG{p}{)}
\PYG{n+nb}{endif} \PYG{p}{(}\PYG{l+s}{USE\PYGZus{}MYMATH}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 查找当前目录下的所有源文件}
\PYG{c}{\PYGZsh{} 并将名称保存到 DIR\PYGZus{}SRCS 变量}
\PYG{n+nb}{aux\PYGZus{}source\PYGZus{}directory}\PYG{p}{(}\PYG{l+s}{.}\PYG{+w}{ }\PYG{l+s}{DIR\PYGZus{}SRCS}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 指定生成目标}
\PYG{n+nb}{add\PYGZus{}executable}\PYG{p}{(}\PYG{l+s}{Demo}\PYG{+w}{ }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{DIR\PYGZus{}SRCS}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\PYG{n+nb}{target\PYGZus{}link\PYGZus{}libraries} \PYG{p}{(}\PYG{l+s}{Demo}\PYG{+w}{  }\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{EXTRA\PYGZus{}LIBS}\PYG{o}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
其中：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
第 7 行的 \sphinxcode{\sphinxupquote{configure\_file}} 命令用于加入一个配置头文件 config.h ，这个文件由 CMake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。

\item {} 
\sphinxAtStartPar
第 13 行的 \sphinxcode{\sphinxupquote{option}} 命令添加了一个 \sphinxcode{\sphinxupquote{USE\_MYMATH}} 选项，并且默认值为 \sphinxcode{\sphinxupquote{ON}} 。

\item {} 
\sphinxAtStartPar
第 17 行根据 \sphinxcode{\sphinxupquote{USE\_MYMATH}} 变量的值来决定是否使用我们自己编写的 MathFunctions 库。

\end{enumerate}


\subsubsection{修改 http://main.cc 文件}
\label{\detokenize{dev-board/cmake:http-main-cc}}
\sphinxAtStartPar
之后修改 \sphinxhref{https://link.zhihu.com/?target=http\%3A//main.cc}{http://main.cc} 文件，让其根据 \sphinxcode{\sphinxupquote{USE\_MYMATH}} 的预定义值来决定是否调用标准库还是 MathFunctions 库：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}config.h\PYGZdq{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef USE\PYGZus{}MYMATH}
\PYG{+w}{  }\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}math/MathFunctions.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{+w}{  }\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}math.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}


\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{argc}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{argc}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Usage: \PYGZpc{}s base exponent }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{base}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{atof}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{exponent}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{atoi}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef USE\PYGZus{}MYMATH}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Now we use our own Math library. }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{power}\PYG{p}{(}\PYG{n}{base}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{exponent}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Now we use the standard library. }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pow}\PYG{p}{(}\PYG{n}{base}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{exponent}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}g \PYGZca{} \PYGZpc{}d is \PYGZpc{}g}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{base}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{exponent}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{编写 http://config.h.in 文件}
\label{\detokenize{dev-board/cmake:http-config-h-in}}
\sphinxAtStartPar
上面的程序值得注意的是第 2 行，这里引用了一个 config.h 文件，这个文件预定义了 \sphinxcode{\sphinxupquote{USE\_MYMATH}} 的值。但我们并不直接编写这个文件，为了方便从 CMakeLists.txt 中导入配置，我们编写一个 config.h.in 文件，内容如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine USE\PYGZus{}MYMATH}
\end{sphinxVerbatim}

\sphinxAtStartPar
这样 CMake 会自动根据 CMakeLists 配置文件中的设置自动生成 config.h 文件。


\subsubsection{编译项目}
\label{\detokenize{dev-board/cmake:id7}}
\sphinxAtStartPar
现在编译一下这个项目，为了便于交互式的选择该变量的值，可以使用 \sphinxcode{\sphinxupquote{ccmake}} 命令（也可以使用 \sphinxcode{\sphinxupquote{cmake \sphinxhyphen{}i}} 命令，该命令会提供一个会话式的交互式配置界面）：

\sphinxAtStartPar


\sphinxAtStartPar
CMake 的交互式配置界面

\sphinxAtStartPar
CMake 的交互式配置界面从中可以找到刚刚定义的 \sphinxcode{\sphinxupquote{USE\_MYMATH}} 选项，按键盘的方向键可以在不同的选项窗口间跳转，按下 \sphinxcode{\sphinxupquote{enter}} 键可以修改该选项。修改完成后可以按下 \sphinxcode{\sphinxupquote{c}} 选项完成配置，之后再按 \sphinxcode{\sphinxupquote{g}} 键确认生成 Makefile 。ccmake 的其他操作可以参考窗口下方给出的指令提示。我们可以试试分别将 \sphinxcode{\sphinxupquote{USE\_MYMATH}} 设为 \sphinxcode{\sphinxupquote{ON}} 和 \sphinxcode{\sphinxupquote{OFF}} 得到的结果：


\subsubsection{USE\_MYMATH 为 ON}
\label{\detokenize{dev-board/cmake:use-mymath-on}}
\sphinxAtStartPar
运行结果：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}ehome@xman Demo4\PYG{o}{]}\PYGZdl{} ./Demo
Now we use our own MathFunctions library.
 \PYG{l+m}{7} \PYGZca{} \PYG{n+nv}{3} \PYG{o}{=} \PYG{l+m}{343}.000000
 \PYG{l+m}{10} \PYGZca{} \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{100000}.000000
 \PYG{l+m}{2} \PYGZca{} \PYG{n+nv}{10} \PYG{o}{=} \PYG{l+m}{1024}.000000
\end{sphinxVerbatim}

\sphinxAtStartPar
此时 config.h 的内容为：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define USE\PYGZus{}MYMATH}
\end{sphinxVerbatim}


\subsubsection{USE\_MYMATH 为 OFF}
\label{\detokenize{dev-board/cmake:use-mymath-off}}
\sphinxAtStartPar
运行结果：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}ehome@xman Demo4\PYG{o}{]}\PYGZdl{} ./Demo
Now we use the standard library.
 \PYG{l+m}{7} \PYGZca{} \PYG{n+nv}{3} \PYG{o}{=} \PYG{l+m}{343}.000000
 \PYG{l+m}{10} \PYGZca{} \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{100000}.000000
 \PYG{l+m}{2} \PYGZca{} \PYG{n+nv}{10} \PYG{o}{=} \PYG{l+m}{1024}.000000
\end{sphinxVerbatim}

\sphinxAtStartPar
此时 config.h 的内容为：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* \PYGZsh{}undef USE\PYGZus{}MYMATH */}
\end{sphinxVerbatim}


\subsection{安装和测试}
\label{\detokenize{dev-board/cmake:id8}}
\sphinxAtStartPar
本节对应的源代码所在目录：
\begin{quote}

\sphinxAtStartPar
\sphinxhref{https://link.zhihu.com/?target=https\%3A//github.com/wzpan/cmake-demo/tree/master/Demo5}{https://github.com/wzpan/cmake\sphinxhyphen{}demo/tree/master/Demo5}
\end{quote}

\sphinxAtStartPar
CMake 也可以指定安装规则，以及添加测试。这两个功能分别可以通过在产生 Makefile 后使用 \sphinxcode{\sphinxupquote{make install}} 和 \sphinxcode{\sphinxupquote{make test}} 来执行。在以前的 GNU Makefile 里，你可能需要为此编写 \sphinxcode{\sphinxupquote{install}} 和 \sphinxcode{\sphinxupquote{test}} 两个伪目标和相应的规则，但在 CMake 里，这样的工作同样只需要简单的调用几条命令。


\subsubsection{定制安装规则}
\label{\detokenize{dev-board/cmake:id9}}
\sphinxAtStartPar
首先先在 math/CMakeLists.txt 文件里添加下面两行：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 指定 MathFunctions 库的安装路径}
\PYG{n+nb}{install} \PYG{p}{(}\PYG{l+s}{TARGETS}\PYG{+w}{ }\PYG{l+s}{MathFunctions}\PYG{+w}{ }\PYG{l+s}{DESTINATION}\PYG{+w}{ }\PYG{l+s}{bin}\PYG{p}{)}
\PYG{n+nb}{install} \PYG{p}{(}\PYG{l+s}{FILES}\PYG{+w}{ }\PYG{l+s}{MathFunctions.h}\PYG{+w}{ }\PYG{l+s}{DESTINATION}\PYG{+w}{ }\PYG{l+s}{include}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
指明 MathFunctions 库的安装路径。之后同样修改根目录的 CMakeLists 文件，在末尾添加下面几行：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 指定安装路径}
\PYG{n+nb}{install} \PYG{p}{(}\PYG{l+s}{TARGETS}\PYG{+w}{ }\PYG{l+s}{Demo}\PYG{+w}{ }\PYG{l+s}{DESTINATION}\PYG{+w}{ }\PYG{l+s}{bin}\PYG{p}{)}
\PYG{n+nb}{install} \PYG{p}{(}\PYG{l+s}{FILES}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}PROJECT\PYGZus{}BINARY\PYGZus{}DIR\PYGZcb{}/config.h\PYGZdq{}}
\PYG{+w}{         }\PYG{l+s}{DESTINATION}\PYG{+w}{ }\PYG{l+s}{include}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
通过上面的定制，生成的 Demo 文件和 MathFunctions 函数库 libMathFunctions.o 文件将会被复制到 \sphinxcode{\sphinxupquote{/usr/local/bin}} 中，而 MathFunctions.h 和生成的 config.h 文件则会被复制到 \sphinxcode{\sphinxupquote{/usr/local/include}} 中。我们可以验证一下（顺带一提的是，这里的 \sphinxcode{\sphinxupquote{/usr/local/}} 是默认安装到的根目录，可以通过修改 \sphinxcode{\sphinxupquote{CMAKE\_INSTALL\_PREFIX}} 变量的值来指定这些文件应该拷贝到哪个根目录）：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}ehome@xman Demo5\PYG{o}{]}\PYGZdl{} sudo make install
\PYG{o}{[} \PYG{l+m}{50}\PYGZpc{}\PYG{o}{]} Built target MathFunctions
\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]} Built target Demo
Install the project...
\PYGZhy{}\PYGZhy{} Install configuration: \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
\PYGZhy{}\PYGZhy{} Installing: /usr/local/bin/Demo
\PYGZhy{}\PYGZhy{} Installing: /usr/local/include/config.h
\PYGZhy{}\PYGZhy{} Installing: /usr/local/bin/libMathFunctions.a
\PYGZhy{}\PYGZhy{} Up\PYGZhy{}to\PYGZhy{}date: /usr/local/include/MathFunctions.h
\PYG{o}{[}ehome@xman Demo5\PYG{o}{]}\PYGZdl{} ls /usr/local/bin
Demo  libMathFunctions.a
\PYG{o}{[}ehome@xman Demo5\PYG{o}{]}\PYGZdl{} ls /usr/local/include
config.h  MathFunctions.h
\end{sphinxVerbatim}


\subsubsection{为工程添加测试}
\label{\detokenize{dev-board/cmake:id10}}
\sphinxAtStartPar
添加测试同样很简单。CMake 提供了一个称为 CTest 的测试工具。我们要做的只是在项目根目录的 CMakeLists 文件中调用一系列的 \sphinxcode{\sphinxupquote{add\_test}} 命令。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 启用测试}
\PYG{n+nb}{enable\PYGZus{}testing}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 测试程序是否成功运行}
\PYG{n+nb}{add\PYGZus{}test} \PYG{p}{(}\PYG{l+s}{test\PYGZus{}run}\PYG{+w}{ }\PYG{l+s}{Demo}\PYG{+w}{ }\PYG{l+s}{5}\PYG{+w}{ }\PYG{l+s}{2}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 测试帮助信息是否可以正常提示}
\PYG{n+nb}{add\PYGZus{}test} \PYG{p}{(}\PYG{l+s}{test\PYGZus{}usage}\PYG{+w}{ }\PYG{l+s}{Demo}\PYG{p}{)}
\PYG{n+nb}{set\PYGZus{}tests\PYGZus{}properties} \PYG{p}{(}\PYG{l+s}{test\PYGZus{}usage}
\PYG{+w}{  }\PYG{l+s}{PROPERTIES}\PYG{+w}{ }\PYG{l+s}{PASS\PYGZus{}REGULAR\PYGZus{}EXPRESSION}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Usage: .* base exponent\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 测试 5 的平方}
\PYG{n+nb}{add\PYGZus{}test} \PYG{p}{(}\PYG{l+s}{test\PYGZus{}5\PYGZus{}2}\PYG{+w}{ }\PYG{l+s}{Demo}\PYG{+w}{ }\PYG{l+s}{5}\PYG{+w}{ }\PYG{l+s}{2}\PYG{p}{)}

\PYG{n+nb}{set\PYGZus{}tests\PYGZus{}properties} \PYG{p}{(}\PYG{l+s}{test\PYGZus{}5\PYGZus{}2}
\PYG{+w}{ }\PYG{l+s}{PROPERTIES}\PYG{+w}{ }\PYG{l+s}{PASS\PYGZus{}REGULAR\PYGZus{}EXPRESSION}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}is 25\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 测试 10 的 5 次方}
\PYG{n+nb}{add\PYGZus{}test} \PYG{p}{(}\PYG{l+s}{test\PYGZus{}10\PYGZus{}5}\PYG{+w}{ }\PYG{l+s}{Demo}\PYG{+w}{ }\PYG{l+s}{10}\PYG{+w}{ }\PYG{l+s}{5}\PYG{p}{)}

\PYG{n+nb}{set\PYGZus{}tests\PYGZus{}properties} \PYG{p}{(}\PYG{l+s}{test\PYGZus{}10\PYGZus{}5}
\PYG{+w}{ }\PYG{l+s}{PROPERTIES}\PYG{+w}{ }\PYG{l+s}{PASS\PYGZus{}REGULAR\PYGZus{}EXPRESSION}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}is 100000\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} 测试 2 的 10 次方}
\PYG{n+nb}{add\PYGZus{}test} \PYG{p}{(}\PYG{l+s}{test\PYGZus{}2\PYGZus{}10}\PYG{+w}{ }\PYG{l+s}{Demo}\PYG{+w}{ }\PYG{l+s}{2}\PYG{+w}{ }\PYG{l+s}{10}\PYG{p}{)}

\PYG{n+nb}{set\PYGZus{}tests\PYGZus{}properties} \PYG{p}{(}\PYG{l+s}{test\PYGZus{}2\PYGZus{}10}
\PYG{+w}{ }\PYG{l+s}{PROPERTIES}\PYG{+w}{ }\PYG{l+s}{PASS\PYGZus{}REGULAR\PYGZus{}EXPRESSION}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}is 1024\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
上面的代码包含了四个测试。第一个测试 \sphinxcode{\sphinxupquote{test\_run}} 用来测试程序是否成功运行并返回 0 值。剩下的三个测试分别用来测试 5 的 平方、10 的 5 次方、2 的 10 次方是否都能得到正确的结果。其中 \sphinxcode{\sphinxupquote{PASS\_REGULAR\_EXPRESSION}} 用来测试输出是否包含后面跟着的字符串。让我们看看测试的结果：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}ehome@xman Demo5\PYG{o}{]}\PYGZdl{} make \PYG{n+nb}{test}
Running tests...
Test project /home/ehome/Documents/programming/C/power/Demo5
    Start \PYG{l+m}{1}: test\PYGZus{}run
\PYG{l+m}{1}/4 Test \PYG{c+c1}{\PYGZsh{}1: test\PYGZus{}run .........................   Passed    0.00 sec}
    Start \PYG{l+m}{2}: test\PYGZus{}5\PYGZus{}2
\PYG{l+m}{2}/4 Test \PYG{c+c1}{\PYGZsh{}2: test\PYGZus{}5\PYGZus{}2 .........................   Passed    0.00 sec}
    Start \PYG{l+m}{3}: test\PYGZus{}10\PYGZus{}5
\PYG{l+m}{3}/4 Test \PYG{c+c1}{\PYGZsh{}3: test\PYGZus{}10\PYGZus{}5 ........................   Passed    0.00 sec}
    Start \PYG{l+m}{4}: test\PYGZus{}2\PYGZus{}10
\PYG{l+m}{4}/4 Test \PYG{c+c1}{\PYGZsh{}4: test\PYGZus{}2\PYGZus{}10 ........................   Passed    0.00 sec}

\PYG{l+m}{100}\PYGZpc{} tests passed, \PYG{l+m}{0} tests failed out of \PYG{l+m}{4}

Total Test \PYG{n+nb}{time} \PYG{o}{(}real\PYG{o}{)} \PYG{o}{=}   \PYG{l+m}{0}.01 sec
\end{sphinxVerbatim}

\sphinxAtStartPar
如果要测试更多的输入数据，像上面那样一个个写测试用例未免太繁琐。这时可以通过编写宏来实现：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ 定义一个宏，用来简化测试工作}
\PYG{n}{macro}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{do\PYGZus{}test}\PYG{+w}{ }\PYG{n}{arg1}\PYG{+w}{ }\PYG{n}{arg2}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{)}
\PYG{+w}{  }\PYG{n}{add\PYGZus{}test}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{test\PYGZus{}\PYGZdl{}}\PYG{p}{\PYGZob{}}\PYG{n}{arg1}\PYG{p}{\PYGZcb{}}\PYG{n}{\PYGZus{}\PYGZdl{}}\PYG{p}{\PYGZob{}}\PYG{n}{arg2}\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{Demo}\PYG{+w}{ }\PYG{n}{\PYGZdl{}}\PYG{p}{\PYGZob{}}\PYG{n}{arg1}\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{\PYGZdl{}}\PYG{p}{\PYGZob{}}\PYG{n}{arg2}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{+w}{  }\PYG{n}{set\PYGZus{}tests\PYGZus{}properties}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{test\PYGZus{}\PYGZdl{}}\PYG{p}{\PYGZob{}}\PYG{n}{arg1}\PYG{p}{\PYGZcb{}}\PYG{n}{\PYGZus{}\PYGZdl{}}\PYG{p}{\PYGZob{}}\PYG{n}{arg2}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{PROPERTIES}\PYG{+w}{ }\PYG{n}{PASS\PYGZus{}REGULAR\PYGZus{}EXPRESSION}\PYG{+w}{ }\PYG{n}{\PYGZdl{}}\PYG{p}{\PYGZob{}}\PYG{n}{result}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{endmacro}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{do\PYGZus{}test}\PYG{p}{)}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ 使用该宏进行一系列的数据测试}
\PYG{n}{do\PYGZus{}test}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{is 25}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{do\PYGZus{}test}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{is 100000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{do\PYGZus{}test}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{is 1024}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
关于 CTest 的更详细的用法可以通过 \sphinxcode{\sphinxupquote{man 1 ctest}} 参考 CTest 的文档。


\subsection{支持 gdb}
\label{\detokenize{dev-board/cmake:gdb}}
\sphinxAtStartPar
让 CMake 支持 gdb 的设置也很容易，只需要指定 \sphinxcode{\sphinxupquote{Debug}} 模式下开启 \sphinxcode{\sphinxupquote{\sphinxhyphen{}g}} 选项：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{CMAKE\PYGZus{}BUILD\PYGZus{}TYPE}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Debug\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}DEBUG}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}ENV\PYGZob{}CXXFLAGS\PYGZcb{} \PYGZhy{}O0 \PYGZhy{}Wall \PYGZhy{}g \PYGZhy{}ggdb\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{set}\PYG{p}{(}\PYG{l+s}{CMAKE\PYGZus{}CXX\PYGZus{}FLAGS\PYGZus{}RELEASE}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}ENV\PYGZob{}CXXFLAGS\PYGZcb{} \PYGZhy{}O3 \PYGZhy{}Wall\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
之后可以直接对生成的程序使用 gdb 来调试。


\subsection{添加环境检查}
\label{\detokenize{dev-board/cmake:id11}}
\sphinxAtStartPar
本节对应的源代码所在目录：
\begin{quote}

\sphinxAtStartPar
\sphinxhref{https://link.zhihu.com/?target=https\%3A//github.com/wzpan/cmake-demo/tree/master/Demo6}{https://github.com/wzpan/cmake\sphinxhyphen{}demo/tree/master/Demo6}
\end{quote}

\sphinxAtStartPar
有时候可能要对系统环境做点检查，例如要使用一个平台相关的特性的时候。在这个例子中，我们检查系统是否自带 pow 函数。如果带有 pow 函数，就使用它；否则使用我们定义的 power 函数。


\subsubsection{添加 CheckFunctionExists 宏}
\label{\detokenize{dev-board/cmake:checkfunctionexists}}
\sphinxAtStartPar
首先在顶层 CMakeLists 文件中添加 CheckFunctionExists.cmake 宏，并调用 \sphinxcode{\sphinxupquote{check\_function\_exists}} 命令测试链接器是否能够在链接阶段找到 \sphinxcode{\sphinxupquote{pow}} 函数。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 检查系统是否支持 pow 函数}
\PYG{n+nb}{include} \PYG{p}{(}\PYG{o}{\PYGZdl{}\PYGZob{}}\PYG{n+nv}{CMAKE\PYGZus{}ROOT}\PYG{o}{\PYGZcb{}}\PYG{l+s}{/Modules/CheckFunctionExists.cmake}\PYG{p}{)}
\PYG{n+nb}{check\PYGZus{}function\PYGZus{}exists} \PYG{p}{(}\PYG{l+s}{pow}\PYG{+w}{ }\PYG{l+s}{HAVE\PYGZus{}POW}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
将上面这段代码放在 \sphinxcode{\sphinxupquote{configure\_file}} 命令前。


\subsubsection{预定义相关宏变量}
\label{\detokenize{dev-board/cmake:id12}}
\sphinxAtStartPar
接下来修改 \sphinxhref{https://link.zhihu.com/?target=http\%3A//config.h.in}{http://config.h.in} 文件，预定义相关的宏变量。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// does the platform provide pow function?}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cmakedefine HAVE\PYGZus{}POW}
\end{sphinxVerbatim}


\subsubsection{在代码中使用宏和函数}
\label{\detokenize{dev-board/cmake:id13}}
\sphinxAtStartPar
最后一步是修改 \sphinxhref{https://link.zhihu.com/?target=http\%3A//main.cc}{http://main.cc} ，在代码中使用宏和函数：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef HAVE\PYGZus{}POW}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Now we use the standard library. }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pow}\PYG{p}{(}\PYG{n}{base}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{exponent}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Now we use our own Math library. }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{power}\PYG{p}{(}\PYG{n}{base}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{exponent}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}


\subsection{添加版本号}
\label{\detokenize{dev-board/cmake:id14}}
\sphinxAtStartPar
本节对应的源代码所在目录：
\begin{quote}

\sphinxAtStartPar
\sphinxhref{https://link.zhihu.com/?target=https\%3A//github.com/wzpan/cmake-demo/tree/master/Demo7}{https://github.com/wzpan/cmake\sphinxhyphen{}demo/tree/master/Demo7}
\end{quote}

\sphinxAtStartPar
给项目添加和维护版本号是一个好习惯，这样有利于用户了解每个版本的维护情况，并及时了解当前所用的版本是否过时，或是否可能出现不兼容的情况。首先修改顶层 CMakeLists 文件，在 \sphinxcode{\sphinxupquote{project}} 命令之后加入如下两行：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set} \PYG{p}{(}\PYG{l+s}{Demo\PYGZus{}VERSION\PYGZus{}MAJOR}\PYG{+w}{ }\PYG{l+s}{1}\PYG{p}{)}
\PYG{n+nb}{set} \PYG{p}{(}\PYG{l+s}{Demo\PYGZus{}VERSION\PYGZus{}MINOR}\PYG{+w}{ }\PYG{l+s}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
分别指定当前的项目的主版本号和副版本号。之后，为了在代码中获取版本信息，我们可以修改 \sphinxhref{https://link.zhihu.com/?target=http\%3A//config.h.in}{http://config.h.in} 文件，添加两个预定义变量：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// the configured options and settings for Tutorial}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define Demo\PYGZus{}VERSION\PYGZus{}MAJOR @Demo\PYGZus{}VERSION\PYGZus{}MAJOR@}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define Demo\PYGZus{}VERSION\PYGZus{}MINOR @Demo\PYGZus{}VERSION\PYGZus{}MINOR@}
\end{sphinxVerbatim}

\sphinxAtStartPar
这样就可以直接在代码中打印版本信息了：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}math.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}config.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}math/MathFunctions.h\PYGZdq{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{argc}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{argc}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// print version info}
\PYG{+w}{        }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}s Version \PYGZpc{}d.\PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{            }\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
\PYG{+w}{            }\PYG{n}{Demo\PYGZus{}VERSION\PYGZus{}MAJOR}\PYG{p}{,}
\PYG{+w}{            }\PYG{n}{Demo\PYGZus{}VERSION\PYGZus{}MINOR}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Usage: \PYGZpc{}s base exponent }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{base}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{atof}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{exponent}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{atoi}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if defined (HAVE\PYGZus{}POW)}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Now we use the standard library. }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pow}\PYG{p}{(}\PYG{n}{base}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{exponent}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Now we use our own Math library. }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{power}\PYG{p}{(}\PYG{n}{base}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{exponent}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}g \PYGZca{} \PYGZpc{}d is \PYGZpc{}g}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{base}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{exponent}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{生成安装包}
\label{\detokenize{dev-board/cmake:id15}}
\sphinxAtStartPar
本节对应的源代码所在目录：
\begin{quote}

\sphinxAtStartPar
\sphinxhref{https://link.zhihu.com/?target=https\%3A//github.com/wzpan/cmake-demo/tree/master/Demo8}{https://github.com/wzpan/cmake\sphinxhyphen{}demo/tree/master/Demo8}
\end{quote}

\sphinxAtStartPar
本节将学习如何配置生成各种平台上的安装包，包括二进制安装包和源码安装包。为了完成这个任务，我们需要用到 CPack ，它同样也是由 CMake 提供的一个工具，专门用于打包。首先在顶层的 CMakeLists.txt 文件尾部添加下面几行：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} 构建一个 CPack 安装包}
\PYG{n+nb}{include} \PYG{p}{(}\PYG{l+s}{InstallRequiredSystemLibraries}\PYG{p}{)}
\PYG{n+nb}{set} \PYG{p}{(}\PYG{l+s}{CPACK\PYGZus{}RESOURCE\PYGZus{}FILE\PYGZus{}LICENSE}
\PYG{+w}{  }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}CMAKE\PYGZus{}CURRENT\PYGZus{}SOURCE\PYGZus{}DIR\PYGZcb{}/License.txt\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{set} \PYG{p}{(}\PYG{l+s}{CPACK\PYGZus{}PACKAGE\PYGZus{}VERSION\PYGZus{}MAJOR}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}Demo\PYGZus{}VERSION\PYGZus{}MAJOR\PYGZcb{}\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{set} \PYG{p}{(}\PYG{l+s}{CPACK\PYGZus{}PACKAGE\PYGZus{}VERSION\PYGZus{}MINOR}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}\PYGZdl{}\PYGZob{}Demo\PYGZus{}VERSION\PYGZus{}MINOR\PYGZcb{}\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{include} \PYG{p}{(}\PYG{l+s}{CPack}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
上面的代码做了以下几个工作：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
导入 InstallRequiredSystemLibraries 模块，以便之后导入 CPack 模块；

\item {} 
\sphinxAtStartPar
设置一些 CPack 相关变量，包括版权信息和版本信息，其中版本信息用了上一节定义的版本号；

\item {} 
\sphinxAtStartPar
导入 CPack 模块。

\end{enumerate}

\sphinxAtStartPar
接下来的工作是像往常一样构建工程，并执行 \sphinxcode{\sphinxupquote{cpack}} 命令。
\begin{itemize}
\item {} 
\sphinxAtStartPar
生成二进制安装包：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cpack \PYGZhy{}C CPackConfig.cmake
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
生成源码安装包

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cpack \PYGZhy{}C CPackSourceConfig.cmake
\end{sphinxVerbatim}

\sphinxAtStartPar
我们可以试一下。在生成项目后，执行 \sphinxcode{\sphinxupquote{cpack \sphinxhyphen{}C CPackConfig.cmake}} 命令：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}ehome@xman Demo8\PYG{o}{]}\PYGZdl{} cpack \PYGZhy{}C CPackSourceConfig.cmake
CPack: Create package using STGZ
CPack: Install projects
CPack: \PYGZhy{} Run preinstall target \PYG{k}{for}: Demo8
CPack: \PYGZhy{} Install project: Demo8
CPack: Create package
CPack: \PYGZhy{} package: /home/ehome/Documents/programming/C/power/Demo8/Demo8\PYGZhy{}1.0.1\PYGZhy{}Linux.sh generated.
CPack: Create package using TGZ
CPack: Install projects
CPack: \PYGZhy{} Run preinstall target \PYG{k}{for}: Demo8
CPack: \PYGZhy{} Install project: Demo8
CPack: Create package
CPack: \PYGZhy{} package: /home/ehome/Documents/programming/C/power/Demo8/Demo8\PYGZhy{}1.0.1\PYGZhy{}Linux.tar.gz generated.
CPack: Create package using TZ
CPack: Install projects
CPack: \PYGZhy{} Run preinstall target \PYG{k}{for}: Demo8
CPack: \PYGZhy{} Install project: Demo8
CPack: Create package
CPack: \PYGZhy{} package: /home/ehome/Documents/programming/C/power/Demo8/Demo8\PYGZhy{}1.0.1\PYGZhy{}Linux.tar.Z generated.
\end{sphinxVerbatim}

\sphinxAtStartPar
此时会在该目录下创建 3 个不同格式的二进制包文件：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}ehome@xman Demo8\PYG{o}{]}\PYGZdl{} ls Demo8\PYGZhy{}*
Demo8\PYGZhy{}1.0.1\PYGZhy{}Linux.sh  Demo8\PYGZhy{}1.0.1\PYGZhy{}Linux.tar.gz  Demo8\PYGZhy{}1.0.1\PYGZhy{}Linux.tar.Z
\end{sphinxVerbatim}

\sphinxAtStartPar
这 3 个二进制包文件所包含的内容是完全相同的。我们可以执行其中一个。此时会出现一个由 CPack 自动生成的交互式安装界面：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}ehome@xman Demo8\PYG{o}{]}\PYGZdl{} sh Demo8\PYGZhy{}1.0.1\PYGZhy{}Linux.sh
Demo8 Installer Version: \PYG{l+m}{1}.0.1, Copyright \PYG{o}{(}c\PYG{o}{)} Humanity
This is a self\PYGZhy{}extracting archive.
The archive will be extracted to: /home/ehome/Documents/programming/C/power/Demo8

If you want to stop extracting, please press \PYGZlt{}ctrl\PYGZhy{}C\PYGZgt{}.
The MIT License \PYG{o}{(}MIT\PYG{o}{)}

Copyright \PYG{o}{(}c\PYG{o}{)} \PYG{l+m}{2013} Joseph Pan\PYG{o}{(}http://hahack.com\PYG{o}{)}

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files \PYG{o}{(}the \PYG{l+s+s2}{\PYGZdq{}Software\PYGZdq{}}\PYG{o}{)}, to deal \PYG{k}{in}
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to \PYG{k}{do} so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included \PYG{k}{in} all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED \PYG{l+s+s2}{\PYGZdq{}AS IS\PYGZdq{}}, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


Do you accept the license? \PYG{o}{[}yN\PYG{o}{]}:
y
By default the Demo8 will be installed \PYG{k}{in}:
  \PYG{l+s+s2}{\PYGZdq{}/home/ehome/Documents/programming/C/power/Demo8/Demo8\PYGZhy{}1.0.1\PYGZhy{}Linux\PYGZdq{}}
Do you want to include the subdirectory Demo8\PYGZhy{}1.0.1\PYGZhy{}Linux?
Saying no will install \PYG{k}{in}: \PYG{l+s+s2}{\PYGZdq{}/home/ehome/Documents/programming/C/power/Demo8\PYGZdq{}} \PYG{o}{[}Yn\PYG{o}{]}:
y

Using target directory: /home/ehome/Documents/programming/C/power/Demo8/Demo8\PYGZhy{}1.0.1\PYGZhy{}Linux
Extracting, please wait...

Unpacking finished successfully
\end{sphinxVerbatim}

\sphinxAtStartPar
完成后提示安装到了 Demo8\sphinxhyphen{}1.0.1\sphinxhyphen{}Linux 子目录中，我们可以进去执行该程序：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}ehome@xman Demo8\PYG{o}{]}\PYGZdl{} ./Demo8\PYGZhy{}1.0.1\PYGZhy{}Linux/bin/Demo \PYG{l+m}{5} \PYG{l+m}{2}
Now we use our own Math library.
\PYG{l+m}{5} \PYGZca{} \PYG{l+m}{2} is \PYG{l+m}{25}
\end{sphinxVerbatim}

\sphinxAtStartPar
关于 CPack 的更详细的用法可以通过 \sphinxcode{\sphinxupquote{man 1 cpack}} 参考 CPack 的文档。


\subsection{项目迁移}
\label{\detokenize{dev-board/cmake:id16}}
\sphinxAtStartPar
CMake 可以很轻松地构建出在适合各个平台执行的工程环境。而如果当前的工程环境不是 CMake ，而是基于某个特定的平台，是否可以迁移到 CMake 呢？答案是可能的。下面针对几个常用的平台，列出了它们对应的迁移方案。


\subsubsection{autotools}
\label{\detokenize{dev-board/cmake:autotools}}\begin{itemize}
\item {} 
\sphinxAtStartPar
am2cmake 可以将 autotools 系的项目转换到 CMake，这个工具的一个成功案例是 KDE 。

\item {} 
\sphinxAtStartPar
Alternative Automake2CMake 可以转换使用 automake 的 KDevelop 工程项目。

\item {} 
\sphinxAtStartPar
Converting autoconf tests

\end{itemize}


\subsubsection{qmake}
\label{\detokenize{dev-board/cmake:qmake}}\begin{itemize}
\item {} 
\sphinxAtStartPar
qmake converter 可以转换使用 QT 的 qmake 的工程。

\end{itemize}


\subsubsection{Visual Studio}
\label{\detokenize{dev-board/cmake:visual-studio}}\begin{itemize}
\item {} 
\sphinxAtStartPar
vcproj2cmake.rb 可以根据 Visual Studio 的工程文件（后缀名是 \sphinxcode{\sphinxupquote{.vcproj}} 或 \sphinxcode{\sphinxupquote{.vcxproj}}）生成 CMakeLists.txt 文件。

\item {} 
\sphinxAtStartPar
vcproj2cmake.ps1 vcproj2cmake 的 PowerShell 版本。

\item {} 
\sphinxAtStartPar
folders4cmake 根据 Visual Studio 项目文件生成相应的 “source\_group” 信息，这些信息可以很方便的在 CMake 脚本中使用。支持 Visual Studio 9/10 工程文件。

\end{itemize}


\subsubsection{CMakeLists.txt 自动推导}
\label{\detokenize{dev-board/cmake:id17}}\begin{itemize}
\item {} 
\sphinxAtStartPar
gencmake 根据现有文件推导 CMakeLists.txt 文件。

\item {} 
\sphinxAtStartPar
CMakeListGenerator 应用一套文件和目录分析创建出完整的 CMakeLists.txt 文件。仅支持 Win32 平台。

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
原文参考：https://github.com/wzpan/cmake\PYGZhy{}demo/tree/master/Demo1
http://www.cmake.org/cmake/help/cmake2.4docs.html
http://www.cmake.org/cmake/help/cmake\PYGZus{}tutorial.html
\end{sphinxVerbatim}

\sphinxstepscope


\section{ESP\sphinxhyphen{}IDF SDK 基础}
\label{\detokenize{dev-board/esp-idf:esp-idf-sdk}}\label{\detokenize{dev-board/esp-idf::doc}}
\sphinxAtStartPar
ESP\sphinxhyphen{}IDF 是乐鑫官方的物联网开发框架，适用于 ESP32、ESP32\sphinxhyphen{}S、ESP32\sphinxhyphen{}C 和 ESP32\sphinxhyphen{}H 系列 SoC。它基于 C/C++ 语言提供了一个自给自足的 SDK，方便用户在这些平台上开发通用应用程序。ESP\sphinxhyphen{}IDF 目前已服务支持数以亿计的物联网设备，并已开发构建了多种物联网产品，例如照明、消费电子大小家电、支付终端、工控等各类物联网设备。


\subsection{特点}
\label{\detokenize{dev-board/esp-idf:id1}}

\subsubsection{免费开源}
\label{\detokenize{dev-board/esp-idf:id2}}
\sphinxAtStartPar
ESP\sphinxhyphen{}IDF 相关资源已在 GitHub 上免费开放。用户可在 Apache 2.0 许可下以源代码形式获取 ESP\sphinxhyphen{}IDF 的大多数组件，或通过兼容许可证获取第三方组件。


\subsubsection{功能丰富的软件组件}
\label{\detokenize{dev-board/esp-idf:id3}}
\sphinxAtStartPar
ESP\sphinxhyphen{}IDF 集成了大量的软件组件，包括 RTOS、外设驱动程序、网络栈、多种协议实现技术以及常见应用程序的使用助手。它提供了典型应用程序所需的大部分构建块，用户在开发应用时只需专注于业务逻辑即可。 ESP\sphinxhyphen{}IDF 不仅具有免费开源的开发工具，还支持 Eclipse 和 VSCode 等 IDE，确保其易于开发人员使用。


\subsubsection{丰富的文档和示例资源}
\label{\detokenize{dev-board/esp-idf:id4}}
\sphinxAtStartPar
ESP\sphinxhyphen{}IDF 提供详尽的软件组件使用和设计文档，有助于开发人员充分理解 ESP\sphinxhyphen{}IDF 功能，并从中挑选最适合构建其应用程序的模块。ESP\sphinxhyphen{}IDF 包含 100 多个示例，详细说明了其组件及硬件外设的功能和用法。它们经过了严格的测试和维护，是用户开启应用开发的有效参考。


\subsection{软件组件及功能}
\label{\detokenize{dev-board/esp-idf:id5}}
\sphinxAtStartPar
ESP\sphinxhyphen{}IDF在FreeRTOS的基础上进行了深度的定制，增加了wifi 以及 bluetooth的能力，同时继承了网络协议栈，文件系统，外设驱动，安全加密并提供了用于开发的API应用接口。以下是esp\sphinxhyphen{}idf的软件组件和功能图

\sphinxAtStartPar
\sphinxincludegraphics{{espidf-components}.png}


\subsubsection{RTOS内核}
\label{\detokenize{dev-board/esp-idf:rtos}}
\sphinxAtStartPar
FreeRTOS 内核已进行优化，可支持多核，具有基于功能的堆分配器。


\subsubsection{标准编程接口}
\label{\detokenize{dev-board/esp-idf:id6}}
\sphinxAtStartPar
包含 POSIX 线程和其他 POSIX API、BSD 套接字、线程安全的 C/C++ 标准库，支持虚拟文件系统。


\subsubsection{外设驱动程序}
\label{\detokenize{dev-board/esp-idf:id7}}
\sphinxAtStartPar
包含 SPI，I2C，UART，GPIO，I2S，ADC，DAC，电容触摸板，定时器，LED 和电机 PWM，RMT，脉冲计数器，CAN/TWAI，SD/eMMC/SDIO 主机和 SDIO 从机，以太网驱动器。


\subsubsection{wi\sphinxhyphen{}fi}
\label{\detokenize{dev-board/esp-idf:wi-fi}}
\sphinxAtStartPar
Wi\sphinxhyphen{}Fi 驱动程序已通过 Wi\sphinxhyphen{}Fi Alliance 认证，支持 WPA3、Wi\sphinxhyphen{}Fi Mesh 协议、ESP\sphinxhyphen{}NOW 点对点协议、ESP\sphinxhyphen{}LR 远程协议、嗅探模式和 SmartConfig 配置协议。


\subsubsection{经典蓝牙和低功耗蓝牙}
\label{\detokenize{dev-board/esp-idf:id8}}
\sphinxAtStartPar
包含蓝牙控制器和两个主机栈：Bluedroid（双模）和 NimBLE（仅低功耗蓝牙），支持符合标准的 Bluetooth LE Mesh，所有组件均通过蓝牙 SIG 认证。


\subsubsection{网络协议栈}
\label{\detokenize{dev-board/esp-idf:id9}}
\sphinxAtStartPar
用于 IPv4 和 IPv6 连接的 LwIP TCP/IP 栈，DHCP 客户端和服务器，TLS 客户端和服务器（最高 1.2 版本），HTTP 客户端和服务器，HTTP2 客户端，WebSocket 客户端，MQTT，mDNS，CoAP，ModBus，SNTP，SMTP。


\subsubsection{电源管理}
\label{\detokenize{dev-board/esp-idf:id10}}
\sphinxAtStartPar
适用于 MCU 低功耗模式以及 Wi\sphinxhyphen{}Fi、蓝牙低功耗模式的电源管理框架；动态频率调节，支持 ULP（超低功耗）协处理器。


\subsubsection{存储}
\label{\detokenize{dev-board/esp-idf:id11}}
\sphinxAtStartPar
具备分区管理器、容错和日志结构的键值存储 (NVS)，支持加密、FAT 和 SPIFFS 文件系统


\subsubsection{安全性}
\label{\detokenize{dev-board/esp-idf:id12}}
\sphinxAtStartPar
具备受硬件支持的安全性能，如 Flash 加密和安全启动，为 RSA、SHA 和 AES 提供加密加速器支持、以及 libsodium 和 micro\sphinxhyphen{}ecc 加密库。


\subsubsection{网络配置}
\label{\detokenize{dev-board/esp-idf:id13}}
\sphinxAtStartPar
使用 Bluetooth LE、Wi\sphinxhyphen{}Fi 和其他带外机制的设备加载统一配置框架。


\subsubsection{构建系统}
\label{\detokenize{dev-board/esp-idf:id14}}
\sphinxAtStartPar
基于 CMake 的构建系统，支持外部组件和外部应用项目。


\subsubsection{开发工具}
\label{\detokenize{dev-board/esp-idf:id15}}
\sphinxAtStartPar
包含 GCC 交叉工具链、基于 OpenOCD 的 JTAG 调试器、静态和动态足迹分析、内存泄漏检测器、核心转储崩溃分析器、兼容 Segger SystemView 工具的实时跟踪、Flash 和 eFuse 编程器、设备制造工具。


\subsubsection{IDE支持}
\label{\detokenize{dev-board/esp-idf:ide}}
\sphinxAtStartPar
ESP\sphinxhyphen{}IDF 项目支持 Microsoft VS Code 插件和 Eclipse IDE 插件。本手册采用terninal+Clion开发。


\subsection{接口API开发的必备基础知识}
\label{\detokenize{dev-board/esp-idf:api}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/memory-types.html}{存储器类型}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/external-ram.html}{片外RAM}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/partition-tables.html}{分区表}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/startup.html}{应用程序启动流程}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/bootloader.html}{引导加载程序}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/build-system.html}{构建系统}

\end{itemize}

\sphinxAtStartPar
更多内容请参看：


\subsection{API开发参考}
\label{\detokenize{dev-board/esp-idf:id16}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/index.html}{API 指南}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-reference/index.html}{API参考}

\end{itemize}

\sphinxstepscope


\chapter{STM32实验篇}
\label{\detokenize{exp-stm32/index:stm32}}\label{\detokenize{exp-stm32/index::doc}}
\sphinxstepscope


\section{IDE环境搭建}
\label{\detokenize{exp-stm32/ide-setup:ide}}\label{\detokenize{exp-stm32/ide-setup::doc}}
\sphinxAtStartPar
Keil 操作简单，容易上手，而且可以很方便地进行调试，但这种比较古老的 IDE（ UI、编译速度、代码补全等方面）显然是不太讨如今追求颜值和实际开发体验的同学们喜欢的（大概:clown\_face::clown\_face:）。用过:link: \sphinxhref{https://www.jetbrains.com/}{Jetbrains} 系 IDE（例如PyCharm）的同学肯定会被它强大的代码补全、界面风格、各种插件、流畅性等众多优点所吸引，毫无疑问这些是能够极大提高开发效率的。而其中的 CLion 就是专门面向 C/C++ 开发的跨平台 IDE。本篇文章将介绍如何把 STM32 的开发环境部署到 CLion 中。

\sphinxAtStartPar
代码的话普遍用的都是 ST 的标准库，然后自己开发逻辑部分，或者在一些方便的地方直接操作寄存器。直接操作寄存器能提高代码的执行效率，但是很难移植，为此， ST 开发了一款可以快速 demo 的平台 STM32CubeMX ，通过这个软件配合 ST 的 HAL 库，可以快速的搭建工程，并能生成跨芯片平台的工程。HAL 库更容易移植，应用起来更加方便，ST 也正在加大对HAL库的支持，并渐渐放弃标准库。因此，掌握 HAL 库的使用是很有必要的。


\subsection{实验目的}
\label{\detokenize{exp-stm32/ide-setup:id1}}
\sphinxAtStartPar
搭建 Ubuntu20.04 系统下 STM32CubeMX + CLion 开发环境


\subsection{准备工作}
\label{\detokenize{exp-stm32/ide-setup:id2}}
\sphinxAtStartPar
STM32CubeMX 安装包、CLion 安装包
\begin{quote}

\sphinxAtStartPar
:exclamation: 注意

\sphinxAtStartPar
如果想自行尝试在虚拟机中搭建完整的开发环境，要先正确配置虚拟机，例如进行换源等操作。另外，还需要一个 CLion 账号，可以在官网通过学生邮箱或者学信网信息申请一年免费使用。
\end{quote}


\subsubsection{硬件}
\label{\detokenize{exp-stm32/ide-setup:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
物联网实验箱

\item {} 
\sphinxAtStartPar
能运行 Ubuntu20.04 的PC

\end{itemize}


\subsubsection{软件}
\label{\detokenize{exp-stm32/ide-setup:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Ubuntu20.04 镜像文件

\item {} 
\sphinxAtStartPar
STM32CubeMX

\item {} 
\sphinxAtStartPar
VMware

\item {} 
\sphinxAtStartPar
CLion

\end{itemize}


\subsection{相关电路原理}
\label{\detokenize{exp-stm32/ide-setup:id5}}
\sphinxAtStartPar
LED2 的一端接 GND，另一端接 STM32 的 GPIO，当 GPIO 设置为高电平时，灯亮，反之，灯灭。

\sphinxAtStartPar
\sphinxincludegraphics{{image-202207281546069911}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-202207281547100071}.png}


\subsection{引脚定义与相关API}
\label{\detokenize{exp-stm32/ide-setup:api}}\begin{itemize}
\item {} 
\sphinxAtStartPar
引脚定义：LED2 与 STM32 的 PB14 相连

\item {} 
\sphinxAtStartPar
相关 API：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Set or clear the selected data port bit.}
\PYG{c+cm}{  *}
\PYG{c+cm}{  * @note   This function uses GPIOx\PYGZus{}BSRR and GPIOx\PYGZus{}BRR registers to allow atomic read/modify}
\PYG{c+cm}{  *         accesses. In this way, there is no risk of an IRQ occurring between}
\PYG{c+cm}{  *         the read and the modify access.}
\PYG{c+cm}{  *}
\PYG{c+cm}{  * @param  GPIOx where x can be (A..H) to select the GPIO peripheral for STM32L4 family}
\PYG{c+cm}{  * @param  GPIO\PYGZus{}Pin specifies the port bit to be written.}
\PYG{c+cm}{  *         This parameter can be any combination of GPIO\PYGZus{}Pin\PYGZus{}x where x can be (0..15).}
\PYG{c+cm}{  * @param  PinState specifies the value to be written to the selected bit.}
\PYG{c+cm}{  *         This parameter can be one of the GPIO\PYGZus{}PinState enum values:}
\PYG{c+cm}{  *            @arg GPIO\PYGZus{}PIN\PYGZus{}RESET: to clear the port pin}
\PYG{c+cm}{  *            @arg GPIO\PYGZus{}PIN\PYGZus{}SET: to set the port pin}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}WritePin}\PYG{p}{(}\PYG{n}{GPIO\PYGZus{}TypeDef}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{GPIOx}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}Pin}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PinState}\PYG{+w}{ }\PYG{n}{PinState}\PYG{p}{)}
\PYG{+w}{    }
\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief This function provides minimum delay (in milliseconds) based}
\PYG{c+cm}{  *        on variable incremented.}
\PYG{c+cm}{  * @note In the default implementation , SysTick timer is the source of time base.}
\PYG{c+cm}{  *       It is used to generate interrupts at regular time intervals where uwTick}
\PYG{c+cm}{  *       is incremented.}
\PYG{c+cm}{  * @note This function is declared as \PYGZus{}\PYGZus{}weak to be overwritten in case of other}
\PYG{c+cm}{  *       implementations in user file.}
\PYG{c+cm}{  * @param Delay  specifies the delay time length, in milliseconds.}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{n}{\PYGZus{}\PYGZus{}weak}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}Delay}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{Delay}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{实验步骤}
\label{\detokenize{exp-stm32/ide-setup:id6}}

\subsubsection{安装openocd}
\label{\detokenize{exp-stm32/ide-setup:openocd}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt install openocd
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
:exclamation: 注意

\sphinxAtStartPar
Ubuntu 的 apt 源里可以安装 openocd，但是版本是0.10，不支持 stlink V3，我们实验箱中的开发板上板载stlink V2，如果同学们以后要用 stlink V3，需要从源码编译安装 openocd 的最新版本，具体步骤请自行了解
\end{quote}


\subsubsection{安装arm编译器}
\label{\detokenize{exp-stm32/ide-setup:arm}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt install gcc\PYGZhy{}arm\PYGZhy{}none\PYGZhy{}eabi
\end{sphinxVerbatim}


\subsubsection{安装STM32CubeMX}
\label{\detokenize{exp-stm32/ide-setup:stm32cubemx}}\begin{itemize}
\item {} 
\sphinxAtStartPar
下载地址：在:link: \sphinxhref{https://www.st.com/zh/development-tools/stm32cubemx.html}{官网下载地址} 下载 Linux 版本

\item {} 
\sphinxAtStartPar
安装过程网上很多，不再一一赘述



\end{itemize}


\subsubsection{安装CLion}
\label{\detokenize{exp-stm32/ide-setup:clion}}\begin{itemize}
\item {} 
\sphinxAtStartPar
下载地址：:link:\sphinxhref{https://www.jetbrains.com/zh-cn/clion/download/\#section=linux}{官网下载地址}

\item {} 
\sphinxAtStartPar
CLion 现在也以 snap 软件包的形式提供。如果您使用 Ubuntu 16.04 或更高版本，可以使用命令行安装

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo snap install clion \PYGZhy{}\PYGZhy{}classic
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
安装Chinese插件和Serial Port Monitor插件

\end{itemize}




\subsubsection{新建工程}
\label{\detokenize{exp-stm32/ide-setup:id7}}

\paragraph{STM32CubeMX创建工程}
\label{\detokenize{exp-stm32/ide-setup:id8}}\begin{itemize}
\item {} 
\sphinxAtStartPar
打开 STM32CubeMX （位于/home/lmx/STM32CubeMX ），点击\sphinxstylestrong{ACCESS TO BOARD SELECTOR}（实验箱中的是 ST 官方的开发板）

\item {} 
\sphinxAtStartPar
选择 \sphinxstylestrong{B\sphinxhyphen{}L475E\sphinxhyphen{}IOT01A1} 开发板，点击\sphinxstylestrong{Start Project}，弹出的对话框中选择 \sphinxstylestrong{Yes}（即初始化外设为默认模式）

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728142047277}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
在新弹出的界面中点击 \sphinxstylestrong{Project Manager}，输入工程名称以及工程路径（建议新建如图工程路径），并选择为\sphinxstylestrong{STM32CubeIDE}，其余保持默认

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728143322945}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
在 \sphinxstylestrong{Code Generator} 中进行如下配置，点击 \sphinxstylestrong{GENERATE CODE} 生成工程

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728143443974}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
在弹出的对话框中点击 \sphinxstylestrong{Close} 关闭对话框

\end{itemize}
\begin{quote}

\sphinxAtStartPar
:exclamation: 注意

\sphinxAtStartPar
在实际开发中，我们可能会需要修改 STM32 的配置（Pinout \& Configuration、Clock Configuration等），在每次修改完点 \sphinxstylestrong{GENERATE CODE} 之后，弹窗直接点Close，Clion里面会自动更新文件。
\end{quote}


\paragraph{CLion配置}
\label{\detokenize{exp-stm32/ide-setup:id9}}\begin{itemize}
\item {} 
\sphinxAtStartPar
打开CLion（Ubuntu 桌面左下角），\sphinxstylestrong{打开}工程

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728150617206}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
选择在 STM32CubeMX 创建的工程（.ioc 文件），点击\sphinxstylestrong{确定}

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728150735497}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
在弹出的对话框中点击\sphinxstylestrong{作为项目打开}

\item {} 
\sphinxAtStartPar
在弹出的选择面板配置文件对话框中点击\sphinxstylestrong{复制到项目并使用}

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728151322888}.png}
\begin{quote}

\sphinxAtStartPar
.cfg 文件用于设置仿真器的类型和接口、指定Flash大小、芯片类型、下载速度等，内容如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} This is a ST NUCLEO L476RG board with a single STM32L476RGT6 chip.}
\PYG{c+c1}{\PYGZsh{} http://www.st.com/web/catalog/tools/FM116/SC959/SS1532/LN1847/PF261636}

\PYG{n}{source} \PYG{p}{[}\PYG{n}{find} \PYG{n}{interface}\PYG{o}{/}\PYG{n}{stlink}\PYG{o}{\PYGZhy{}}\PYG{n}{v2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{n}{cfg}\PYG{p}{]}

\PYG{n}{transport} \PYG{n}{select} \PYG{n}{hla\PYGZus{}swd}

\PYG{n}{source} \PYG{p}{[}\PYG{n}{find} \PYG{n}{target}\PYG{o}{/}\PYG{n}{stm32l4x}\PYG{o}{.}\PYG{n}{cfg}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} use hardware reset}
\PYG{n}{reset\PYGZus{}config} \PYG{n}{srst\PYGZus{}only} \PYG{n}{srst\PYGZus{}nogate}
\end{sphinxVerbatim}

\sphinxAtStartPar
文件中描述的开发板为 ST NUCLEO L476RG board，与我们实际使用的开发板不同，但是该文件主要针对仿真器的类型，两块开发板的仿真器都是 stlink，因此可以通用。默认的 .cfg 文件没有设置下载速度等，感兴趣的同学请自行了解:slightly\_smiling\_face:
\end{quote}


\subsubsection{成为点灯大师}
\label{\detokenize{exp-stm32/ide-setup:id10}}
\sphinxAtStartPar
在学习 STM32 标准库，ZigBee，ESP32，Linux开发板，FPGA的时候，我们的第一个Demo肯定是点灯。因此，我们通过点亮LED灯来测试辛苦配置好的环境是否能用\textasciitilde{}
\begin{itemize}
\item {} 
\sphinxAtStartPar
原理分析：在硬件原理图中，我们可以看到 LED2 连接到 STM32 的 PB14 引脚上，且另一边接 GND，因此，我们只需将 PB14 设置为高电平即可点亮 LED 灯

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-202207281546069911}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-202207281547100071}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
代码编写：在 main.c 文件中的编写以下代码

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728155706418}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE BEGIN WHILE */}
\PYG{+w}{  }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+cm}{/* USER CODE END WHILE */}

\PYG{+w}{    }\PYG{c+cm}{/* USER CODE BEGIN 3 */}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}WritePin}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}14}\PYG{p}{,}\PYG{n}{SET}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}Delay}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}WritePin}\PYG{p}{(}\PYG{n}{GPIOB}\PYG{p}{,}\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}14}\PYG{p}{,}\PYG{n}{RESET}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}Delay}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE END 3 */}
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
:exclamation: 注意

\sphinxAtStartPar
通过STM32CubeMX生成的工程必须在特定的位置编写自己的代码，例如上述代码编写在 /* USER CODE BEGIN 3 */  和

\sphinxAtStartPar
/* USER CODE END 3 */ 之间，防止在我们修改完STM32 的配置（Pinout \& Configuration、Clock Configuration 等），点 \sphinxstylestrong{GENERATE CODE} 之后，STM32CubeMX 把不在这些位置编写的用户代码清空。
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
连接 PC 与开发板，编译并下载程序（从左到右分别为只编译、编译并下载、调试）

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728161544516}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
编译下载成功

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728162437874}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728162113884}.png}

\sphinxAtStartPar
至此，环境配置已经完成，以后就可以愉快地进行 STM32 开发了。相比于在 keil 下用标准库开发，使用 STM32CubeMX + CLion 是不是非常方便快捷呢！

\sphinxstepscope


\section{基本调试流程}
\label{\detokenize{exp-stm32/debug-flow:id1}}\label{\detokenize{exp-stm32/debug-flow::doc}}
\sphinxAtStartPar
有时候我们辛辛苦苦写好的程序可能会运行崩溃，或不符合预期💢💢或者单纯地想要去查看一些变量，而 CLion 里面是支持全功能的单步断点调试的，也能在代码里直接观察变量的值，非常方便\textasciitilde{}


\subsection{实验目的}
\label{\detokenize{exp-stm32/debug-flow:id2}}
\sphinxAtStartPar
掌握 CLion IDE 的基本调试流程


\subsection{准备工作}
\label{\detokenize{exp-stm32/debug-flow:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
完成 IDE 环境搭建

\item {} 
\sphinxAtStartPar
Ubuntu 中安装 openocd

\end{itemize}


\subsubsection{硬件}
\label{\detokenize{exp-stm32/debug-flow:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
物联网实验箱

\item {} 
\sphinxAtStartPar
能运行 Ubuntu20.04 的PC

\end{itemize}


\subsubsection{软件}
\label{\detokenize{exp-stm32/debug-flow:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Ubuntu20.04 镜像文件

\item {} 
\sphinxAtStartPar
STM32CubeMX

\item {} 
\sphinxAtStartPar
VMware

\item {} 
\sphinxAtStartPar
CLion

\end{itemize}


\subsection{相关电路原理}
\label{\detokenize{exp-stm32/debug-flow:id6}}
\sphinxAtStartPar
LED2 的一端接 GND，另一端接 STM32 的 GPIO，当 GPIO 设置为高电平时，灯亮，反之，灯灭。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728154606991}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728154710007}.png}


\subsection{引脚定义与相关API}
\label{\detokenize{exp-stm32/debug-flow:api}}\begin{itemize}
\item {} 
\sphinxAtStartPar
引脚定义：LED2 与 STM32 的 PB14 相连

\item {} 
\sphinxAtStartPar
相关 API：与 IDE环境搭建 章节相同

\end{itemize}


\subsection{实验步骤}
\label{\detokenize{exp-stm32/debug-flow:id7}}
\sphinxAtStartPar
在 IDE 环境搭建章节中，我们新建了一个工程，这一章节就利用这个工程来完成基本调试流程


\subsubsection{断点调试}
\label{\detokenize{exp-stm32/debug-flow:id8}}\begin{itemize}
\item {} 
\sphinxAtStartPar
打开工程，用 USB 线连接 STM32 与 PC，程序与上一章节保持一致

\item {} 
\sphinxAtStartPar
在此处打上断点后，点击右上角开始调试

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729092711991}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729093427714}.png}
\begin{quote}

\sphinxAtStartPar
:exclamation: 注意

\sphinxAtStartPar
在 keil 中，是先开始调试，再打断点，而在 CLion 中，需要先打断点，再开始调试，这一点需要注意，顺序不小心错了的同学会出现如图情况，解决方法是退出调试（点击右上角的红色正方形按钮），打上断点，再开始调试。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729093743221}.png}
\end{quote}


\subsubsection{变量观察}
\label{\detokenize{exp-stm32/debug-flow:id9}}\begin{itemize}
\item {} 
\sphinxAtStartPar
在此处打上断点后开始调试，程序就会运行到此处

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729094623896}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
点击步入后，会跳转到该函数内部，可观察变量的值

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729094820051}.png}

\sphinxAtStartPar
至此，基本调试流程已介绍完成，更详细的关于断点调试、变量观察、GDB、内存视图等功能请自行了解。

\sphinxstepscope


\section{外设与传感器}
\label{\detokenize{exp-stm32/peripherals-and-sensors:id1}}\label{\detokenize{exp-stm32/peripherals-and-sensors::doc}}
\sphinxAtStartPar
常见的STM32外设有 GPIO、TIM、USART、ADC、DAC、SPI、I2C、EXIT、RTC、SysTIck、WDG、DMA、FLASH、FSMC 等。

\sphinxAtStartPar
B\sphinxhyphen{}L475E\sphinxhyphen{}IOT01A 上板载许多传感器，包括但不限于以下传感器（更具体描述的请参考 ST 官方文档 :clap:）：
\begin{itemize}
\item {} 
\sphinxAtStartPar
用于相对湿度和温度测量的电容式数字传感器（HTS221）

\item {} 
\sphinxAtStartPar
高性能3轴磁力计（LIS3MDL）

\item {} 
\sphinxAtStartPar
3D加速度计和3D陀螺仪（LSM6DSL）

\item {} 
\sphinxAtStartPar
260\sphinxhyphen{}1260 hPa绝对数字输出气压计（LPS22HB）

\end{itemize}

\sphinxAtStartPar
在上一章节，我们使用 STM32 的 GPIO 点亮了 LED 灯，在后续章节，我们会利用 STM32 的串口来与 LoRa 节点通信。因此，本章节我们将学习如何使用 STM32 的 UART（USART 与 UART的区别请自行了解）与 I2C 外设，以及如何获取以 I2C 为通信方式的传感器数据。


\subsection{实验目的}
\label{\detokenize{exp-stm32/peripherals-and-sensors:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
实现 UART 阻塞式发送数据以及重定向 printf() 函数

\item {} 
\sphinxAtStartPar
实现 UART 中断式接收数据

\item {} 
\sphinxAtStartPar
实现 I2C 接收传感器数据

\end{itemize}


\subsection{准备工作}
\label{\detokenize{exp-stm32/peripherals-and-sensors:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
CLion 中安装 Serial Port Monitor 插件

\end{itemize}


\subsubsection{硬件}
\label{\detokenize{exp-stm32/peripherals-and-sensors:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
物联网实验箱

\item {} 
\sphinxAtStartPar
USB 数据线

\end{itemize}


\subsubsection{软件}
\label{\detokenize{exp-stm32/peripherals-and-sensors:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
CLion

\item {} 
\sphinxAtStartPar
STM32CubeMX

\end{itemize}


\subsection{相关电路原理}
\label{\detokenize{exp-stm32/peripherals-and-sensors:id6}}\begin{itemize}
\item {} 
\sphinxAtStartPar
STM32 与 USB STLINK 接口

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729112306980}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729112414977}.png}
\begin{quote}

\sphinxAtStartPar
:exclamation: 注意

\sphinxAtStartPar
开发板上一共有两片 STM32，其中一片是 STM32F103，另一片是 STM32L475，其中 STM32F103 里烧录了 stlink 固件，是作为仿真器来使用的。那这个时候好（hào）事儿的同学就会有疑问了，你这原理图上 STM32L4 的串口1怎么是 PB6 和 PB7 ，STM32 的串口1不是 PA9 和 PA10 吗？:thinking:其实是因为如果以开发板为模板生成工程的话，在默认的配置里，是把 PB6 和 PB7 重映射为串口1的，而 PA9，PA10 默认配置为 OTG 功能，打开 .ioc 文件就可以发现。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729113356237}.png}
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
STM32 与 I2C 传感器接口

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729105520689}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729110116832}.png}

\sphinxAtStartPar
结合两张图可以看出，这四个传感器都与 STM32 的 I2C2 相连，即STM32 的 PB10 和 PB11。除此之外，每一个传感器的 INT 或 DRDY 引脚连接到 STM32 的 GPIO 上（有关 I2C 的主从模式、中断和非中断模式请自行了解）。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729111403881}.png}


\subsection{引脚定义与相关API}
\label{\detokenize{exp-stm32/peripherals-and-sensors:api}}

\subsubsection{UART实验引脚定义与相关API}
\label{\detokenize{exp-stm32/peripherals-and-sensors:uartapi}}\begin{itemize}
\item {} 
\sphinxAtStartPar
引脚定义

\end{itemize}

\sphinxAtStartPar
PB6 配置为 TX 引脚，PB7 配置为 RX 引脚
\begin{itemize}
\item {} 
\sphinxAtStartPar
相关API

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief Receive an amount of data in interrupt mode.}
\PYG{c+cm}{  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1\PYGZhy{}M0 = 01),}
\PYG{c+cm}{  *         the received data is handled as a set of u16. In this case, Size must indicate the number}
\PYG{c+cm}{  *         of u16 available through pData.}
\PYG{c+cm}{  * @param huart UART handle.}
\PYG{c+cm}{  * @param pData Pointer to data buffer (u8 or u16 data elements).}
\PYG{c+cm}{  * @param Size  Amount of data elements (u8 or u16) to be received.}
\PYG{c+cm}{  * @retval HAL status}
\PYG{c+cm}{  */}
\PYG{n}{HAL\PYGZus{}StatusTypeDef}\PYG{+w}{ }\PYG{n+nf}{HAL\PYGZus{}UART\PYGZus{}Receive\PYGZus{}IT}\PYG{p}{(}\PYG{n}{UART\PYGZus{}HandleTypeDef}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{huart}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{pData}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{Size}\PYG{p}{)}


\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief Send an amount of data in blocking mode.}
\PYG{c+cm}{  * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1\PYGZhy{}M0 = 01),}
\PYG{c+cm}{  *         the sent data is handled as a set of u16. In this case, Size must indicate the number}
\PYG{c+cm}{  *         of u16 provided through pData.}
\PYG{c+cm}{  * @note When FIFO mode is enabled, writing a data in the TDR register adds one}
\PYG{c+cm}{  *       data to the TXFIFO. Write operations to the TDR register are performed}
\PYG{c+cm}{  *       when TXFNF flag is set. From hardware perspective, TXFNF flag and}
\PYG{c+cm}{  *       TXE are mapped on the same bit\PYGZhy{}field.}
\PYG{c+cm}{  * @param huart   UART handle.}
\PYG{c+cm}{  * @param pData   Pointer to data buffer (u8 or u16 data elements).}
\PYG{c+cm}{  * @param Size    Amount of data elements (u8 or u16) to be sent.}
\PYG{c+cm}{  * @param Timeout Timeout duration.}
\PYG{c+cm}{  * @retval HAL status}
\PYG{c+cm}{  */}
\PYG{n}{HAL\PYGZus{}StatusTypeDef}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Transmit}\PYG{p}{(}\PYG{n}{UART\PYGZus{}HandleTypeDef}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{huart}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{pData}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{Size}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{Timeout}\PYG{p}{)}


\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief This function provides minimum delay (in milliseconds) based}
\PYG{c+cm}{  *        on variable incremented.}
\PYG{c+cm}{  * @note In the default implementation , SysTick timer is the source of time base.}
\PYG{c+cm}{  *       It is used to generate interrupts at regular time intervals where uwTick}
\PYG{c+cm}{  *       is incremented.}
\PYG{c+cm}{  * @note This function is declared as \PYGZus{}\PYGZus{}weak to be overwritten in case of other}
\PYG{c+cm}{  *       implementations in user file.}
\PYG{c+cm}{  * @param Delay  specifies the delay time length, in milliseconds.}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{n}{\PYGZus{}\PYGZus{}weak}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}Delay}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{Delay}\PYG{p}{)}


\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief Return the UART handle state.}
\PYG{c+cm}{  * @param  huart Pointer to a UART\PYGZus{}HandleTypeDef structure that contains}
\PYG{c+cm}{  *               the configuration information for the specified UART.}
\PYG{c+cm}{  * @retval HAL state}
\PYG{c+cm}{  */}
\PYG{n}{HAL\PYGZus{}UART\PYGZus{}StateTypeDef}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}GetState}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}HandleTypeDef}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{huart}\PYG{p}{)}


\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Rx Transfer completed callback.}
\PYG{c+cm}{  * @param  huart UART handle.}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{n}{\PYGZus{}\PYGZus{}weak}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}RxCpltCallback}\PYG{p}{(}\PYG{n}{UART\PYGZus{}HandleTypeDef}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{huart}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{c+cm}{/* Prevent unused argument(s) compilation warning */}
\PYG{+w}{  }\PYG{n}{UNUSED}\PYG{p}{(}\PYG{n}{huart}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/* NOTE : This function should not be modified, when the callback is needed,}
\PYG{c+cm}{            the HAL\PYGZus{}UART\PYGZus{}RxCpltCallback can be implemented in the user file.}
\PYG{c+cm}{   */}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{I2C实验引脚定义与相关API}
\label{\detokenize{exp-stm32/peripherals-and-sensors:i2capi}}\begin{itemize}
\item {} 
\sphinxAtStartPar
引脚定义

\end{itemize}

\sphinxAtStartPar
PB10 配置为 SCL引脚，PB11 配置为 SDA引脚
\begin{itemize}
\item {} 
\sphinxAtStartPar
相关API

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{  * @功能  串口显示 LPS22HB pressure sensor 的值}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{Pressure\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @功能  串口显示 HTS221 humidity sensor 的值}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{Humidity\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @功能  串口显示 HTS221 temperature sensor 的值}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{Temperature\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @功能  串口显示 LSM6DSL accelerometer sensor 的值}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{Accelero\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @功能  串口显示 LIS3MDL gyroscope sensor 的值}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{Gyro\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @功能  串口显示 LIS3MDL magnetometer sensor 的值}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{Magneto\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{实验步骤}
\label{\detokenize{exp-stm32/peripherals-and-sensors:id7}}

\subsubsection{UART与电脑通信}
\label{\detokenize{exp-stm32/peripherals-and-sensors:uart}}

\paragraph{STM32CubeMX创建工程}
\label{\detokenize{exp-stm32/peripherals-and-sensors:stm32cubemx}}\begin{itemize}
\item {} 
\sphinxAtStartPar
在 \sphinxstylestrong{Pinout \& Configuration} 中使能 USART1 的中断，\sphinxstylestrong{Mode}为 \sphinxstylestrong{Asynchronous}（异步方式，简称UART）

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729134653395}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
配置完点击 \sphinxstylestrong{GENERATE CODE} 生成工程

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220805093724262}.png}


\paragraph{代码编写及运行结果}
\label{\detokenize{exp-stm32/peripherals-and-sensors:id8}}

\subparagraph{UART阻塞式发送数据}
\label{\detokenize{exp-stm32/peripherals-and-sensors:id9}}
\sphinxAtStartPar
在 main.c 中编写以下代码，编写完成后点击右上角的绿色三角形编译并下载程序，串口终端打印出hello world!

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729142245276}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Transmit}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hello world!}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{14}\PYG{p}{,}\PYG{l+m+mh}{0xffff}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{HAL\PYGZus{}Delay}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }\PYG{c+c1}{//延时一秒}
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
:exclamation: 注意

\sphinxAtStartPar
Serial Monitor 各个按键和选项的功能请自行了解，由于串口波特率默认配置为115200，因此在这里也需要把 Baudrate 设置为115200，Port name 要选择为对应的端口。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729143242927}.png}
\end{quote}


\subparagraph{重定向printf()函数}
\label{\detokenize{exp-stm32/peripherals-and-sensors:printf}}
\sphinxAtStartPar
printf 是指格式化输出函数，主要功能是向标准输出设备按规定格式输出信息。printf 是C语言标准库函数，定义于头文件 <stdio.h>，输出的字符串除了可以是字母、数字、空格和一些数字符号以外，还可以使用一些转义字符表示特殊的含义 。

\sphinxAtStartPar
学习标准库的时候，在 \sphinxstylestrong{Keil} 里面为了使用printf函数我们需要重定向fputc函数：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{fputc}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{ch}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{FILE}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{f}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Transmit}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{ch}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{ch}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
其中的 FILE 定义在 stdio.h 头文件中，所以需要在项目中包含这个头文件，但是经过测试发现，Keil 里面包含的是 MDK\textbackslash{}ARM\textbackslash{}ARMCC\textbackslash{}include 这个目录下的stdio.h，而在 Clion 中是不会链接到这个文件的。因此如果在 CLion 中也按之前的方法进行重定向，会发现 printf 没有任何输出。在 CLion 中链接的是 GNU\sphinxhyphen{}Tools\sphinxhyphen{}ARM\sphinxhyphen{}Embedded\textbackslash{}arm\sphinxhyphen{}none\sphinxhyphen{}eabi\textbackslash{}include里面的stdio.h，如果仍然想使用 printf 函数功能，则需要进行如下操作：
\begin{itemize}
\item {} 
\sphinxAtStartPar
在\textasciitilde{}/Core/Src/usart.c中添加以下代码

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN 1 */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}\PYGZus{}GNUC\PYGZus{}\PYGZus{}}
\PYG{c+cm}{/* With GCC/RAISONANCE, small printf (option LD Linker\PYGZhy{}\PYGZgt{}Libraries\PYGZhy{}\PYGZgt{}Small printf}
\PYG{c+cm}{   set to \PYGZsq{}Yes\PYGZsq{}) calls \PYGZus{}\PYGZus{}io\PYGZus{}putchar() */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PUTCHAR\PYGZus{}PROTOTYPE int \PYGZus{}\PYGZus{}io\PYGZus{}putchar(int ch)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PUTCHAR\PYGZus{}PROTOTYPE int fputc(int ch, FILE *f)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* \PYGZus{}\PYGZus{}GNUC\PYGZus{}\PYGZus{} */}
\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Retargets the C library printf function to the USART.}
\PYG{c+cm}{  * @param  None}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{n}{PUTCHAR\PYGZus{}PROTOTYPE}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+cm}{/* Place your implementation of fputc here */}
\PYG{+w}{    }\PYG{c+cm}{/* e.g. write a character to the EVAL\PYGZus{}COM1 and Loop until the end of transmission */}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Transmit}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{ch}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0xFFFF}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{	}\PYG{c+c1}{//HAL\PYGZus{}UART\PYGZus{}Transmit(\PYGZam{}huart2, (uint8\PYGZus{}t *)\PYGZam{}ch, 1, 0xFFFF);	//串口2}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{ch}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/* USER CODE END 1 */}
\end{sphinxVerbatim}

\sphinxAtStartPar
可以发现，这段代码最终也是调用 HAL\_UART\_Transmit()，因此这里的 printf() 也是阻塞式发送数据。
\begin{itemize}
\item {} 
\sphinxAtStartPar
在\textasciitilde{}/Core/Src/main.c中添加头文件

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN Includes */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stdio.h\PYGZdq{}}
\PYG{c+cm}{/* USER CODE END Includes */}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
在\textasciitilde{}/Core/Src/main.c的 while(1) 循环中添加以下代码

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN 3 */}
\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hello, pansiwen!(\PYGZsh{}\PYGZca{}.\PYGZca{}\PYGZsh{})}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//必须要以\PYGZbs{}r\PYGZbs{}n结尾}
\PYG{n}{HAL\PYGZus{}Delay}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
编译下载程序后，终端打印出字符串，非常方便 :watermelon:！

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729164151875}.png}


\subparagraph{UART中断式接收数据}
\label{\detokenize{exp-stm32/peripherals-and-sensors:id10}}
\sphinxAtStartPar
因为中断接收函数 HAL\_UART\_Receive\_IT() 只能触发一次接收中断，所以我们需要在中断回调函数中再调用一次中断接收函数

\sphinxAtStartPar
具体流程：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
初始化串口（相关调用代码已经通过 STM32CubeMX 自动生成）

\item {} 
\sphinxAtStartPar
在 main 中第一次调用接收中断函数

\item {} 
\sphinxAtStartPar
进入接收中断，接收完数据  进入中断回调函数

\item {} 
\sphinxAtStartPar
修改 HAL\_UART\_RxCpltCallback() 中断回调函数，处理接收的数据

\item {} 
\sphinxAtStartPar
回调函数中要调用一次 HAL\_UART\_Receive\_IT() 函数，使得程序可以重新触发接收中断

\end{enumerate}

\sphinxAtStartPar
函数流程图：

\sphinxAtStartPar
HAL\_UART\_Receive\_IT(中断接收函数) :point\_right::point\_right: USART1\_IRQHandler(中断服务函数) :point\_right::point\_right: HAL\_UART\_IRQHandler(中断处理函数) :point\_right::point\_right: UART\_Receive\_IT(接收函数) :point\_right::point\_right: HAL\_UART\_RxCpltCallback(中断回调函数)

\sphinxAtStartPar
HAL\_UART\_RxCpltCallback() 函数就是用户要重写在main.c里的回调函数。（关于回调函数的定义请自行了解）
\begin{itemize}
\item {} 
\sphinxAtStartPar
main.c 文件中添加需要的 c 库头文件，定义变量

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Private includes \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* USER CODE BEGIN Includes */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stdio.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}string.h\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define RXBUFFERSIZE  256     }\PYG{c+c1}{//最大接收字节数}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{RxBuffer}\PYG{p}{[}\PYG{n}{RXBUFFERSIZE}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{//接收数据}
\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{aRxBuffer}\PYG{p}{;}\PYG{+w}{			}\PYG{c+c1}{//接收中断缓冲}
\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{		}\PYG{c+c1}{//接收缓冲计数}
\PYG{c+cm}{/* USER CODE END Includes */}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
在 mian.c 文件中的 main() 主函数里的串口初始化后，while() 循环开始前，先调用一次 HAL\_UART\_Receive\_IT() 中断接收函数

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN 2 */}
\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Receive\PYGZus{}IT}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{aRxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cm}{/* USER CODE END 2 */}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
在 main.c 文件下方添加 HAL\_UART\_RxCpltCallback() 中断回调函数

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN 4 */}
\PYG{c+c1}{//可接收不定长度的数据，以\PYGZbs{}r\PYGZbs{}n为结束位，收到的数据存在RxBuffer中}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{HAL\PYGZus{}UART\PYGZus{}RxCpltCallback}\PYG{p}{(}\PYG{n}{UART\PYGZus{}HandleTypeDef}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{huart}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+cm}{/* Prevent unused argument(s) compilation warning */}
\PYG{+w}{    }\PYG{n}{UNUSED}\PYG{p}{(}\PYG{n}{huart}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+cm}{/* NOTE: This function Should not be modified, when the callback is needed,}
\PYG{c+cm}{             the HAL\PYGZus{}UART\PYGZus{}TxCpltCallback could be implemented in the user file}
\PYG{c+cm}{     */}

\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{+w}{  }\PYG{c+c1}{//溢出判断}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{memset}\PYG{p}{(}\PYG{n}{RxBuffer}\PYG{p}{,}\PYG{l+m+mh}{0x00}\PYG{p}{,}\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{RxBuffer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Transmit}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{数据溢出}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mh}{0xFFFF}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{else}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{RxBuffer}\PYG{p}{[}\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{aRxBuffer}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{//接收数据转存}
\PYG{+w}{		}\PYG{c+c1}{//0x0A 是 \PYGZbs{}r 的 ASCII码，0x0D 是 \PYGZbs{}n 的 ASCII码}
\PYG{+w}{        }\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{RxBuffer}\PYG{p}{[}\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mh}{0x0A}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{n}{RxBuffer}\PYG{p}{[}\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{l+m+mi}{\PYGZhy{}2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mh}{0x0D}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{c+c1}{//判断结束位，以\PYGZbs{}r\PYGZbs{}n结尾为一组数据}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Transmit}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{RxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{p}{,}\PYG{l+m+mh}{0xFFFF}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//将收到的信息发送出去}
\PYG{+w}{            }\PYG{k}{while}\PYG{p}{(}\PYG{n}{HAL\PYGZus{}UART\PYGZus{}GetState}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}STATE\PYGZus{}BUSY\PYGZus{}TX}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//检测UART发送结束}
\PYG{+w}{            }\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{memset}\PYG{p}{(}\PYG{n}{RxBuffer}\PYG{p}{,}\PYG{l+m+mh}{0x00}\PYG{p}{,}\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{RxBuffer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//清空数组}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Receive\PYGZus{}IT}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{aRxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{//再次调用中断接收函数}
\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/* USER CODE END 4 */}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
编译下载程序后，在终端输入想要发送给 STM32 的字符串，点击 \sphinxstylestrong{Send}

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729170953171}.png}
\begin{quote}

\sphinxAtStartPar
:exclamation:注意

\sphinxAtStartPar
要在 CLion的 SerialMonitor 中，右边选择 Both NL \& CR，即自动添加回车换行，也可以在要发送的字符串后面添加 \textbackslash{}r\textbackslash{}n，例如：123\textbackslash{}r\textbackslash{}n
\end{quote}


\subsubsection{I2C获取传感器数据}
\label{\detokenize{exp-stm32/peripherals-and-sensors:i2c}}

\paragraph{STM32CubeMX创建工程}
\label{\detokenize{exp-stm32/peripherals-and-sensors:id11}}\begin{itemize}
\item {} 
\sphinxAtStartPar
创建过程与:link:UART与电脑通信部分一致

\item {} 
\sphinxAtStartPar
在工程中完成:link:重定向printf()函数部分

\end{itemize}
\begin{quote}

\sphinxAtStartPar
:exclamation:注意

\sphinxAtStartPar
在这一步同学们通常会有三种选择，一是直接用上面完成的工程，二是完全新创建一个工程，三是复制一份上面的工程，然后编辑复制后的工程。如果是第三种情况，可能会有编译错误问题，解决方法：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
如果移动了工程文件夹或者复制了工程文件夹，最好打开.ioc文件重新 \sphinxstylestrong{Generate} 一下再编译，可以解决很多错误

\item {} 
\sphinxAtStartPar
遇到任何 CMake 相关的报错，一般是由于缓存没有更新引起的，可以在 CLion 中选 \sphinxstylestrong{工具\sphinxhyphen{}CMake\sphinxhyphen{}重置缓存并重新加载项目} 即可解决:ok\_hand:。

\end{enumerate}
\end{quote}


\paragraph{代码编写及运行结果}
\label{\detokenize{exp-stm32/peripherals-and-sensors:id12}}\begin{itemize}
\item {} 
\sphinxAtStartPar
添加 BSP 源文件

\end{itemize}

\sphinxAtStartPar
在工程中新建\textasciitilde{}/sensor\_test/Drivers/BSP文件夹，将/home/lmx/STM32Cube/Repository/STM32Cube\_FW\_L4\_V1.17.2/Drivers/BSP中的B\sphinxhyphen{}L475E\sphinxhyphen{}IOT01和Components文件夹复制到新建的文件夹中。
\begin{itemize}
\item {} 
\sphinxAtStartPar
添加对应头文件和函数

\end{itemize}

\sphinxAtStartPar
在工程中的 \textasciitilde{}Core/Inc/main.h 文件夹中添加用到的头文件和函数

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Includes \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32l4xx\PYGZus{}hal.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32l475e\PYGZus{}iot01.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32l475e\PYGZus{}iot01\PYGZus{}accelero.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32l475e\PYGZus{}iot01\PYGZus{}magneto.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32l475e\PYGZus{}iot01\PYGZus{}gyro.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32l475e\PYGZus{}iot01\PYGZus{}tsensor.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32l475e\PYGZus{}iot01\PYGZus{}psensor.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32l475e\PYGZus{}iot01\PYGZus{}hsensor.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32l475e\PYGZus{}iot01\PYGZus{}qspi.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cm}{/* Private includes \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}



\PYG{c+cm}{/* Exported functions prototypes \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{QSPI\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{QSPI\PYGZus{}MemoryMapped\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Temperature\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Humidity\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Pressure\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Gyro\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Magneto\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Accelero\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n+nf}{Serial\PYGZus{}Scanf}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Error\PYGZus{}Handler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/* USER CODE BEGIN EFP */}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
修改工程目录下的 CMakeLists.txt 文件

\end{itemize}

\sphinxAtStartPar
在文件最后增加以下代码，然后 \sphinxstylestrong{点击重新加载变更}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{include\PYGZus{}directories}\PYG{p}{(}
\PYG{+w}{        }\PYG{l+s}{Drivers/BSP/B\PYGZhy{}L475E\PYGZhy{}IOT01}
\PYG{+w}{        }\PYG{l+s}{Drivers/BSP/Components/Common}
\PYG{+w}{        }\PYG{l+s}{//}\PYG{+w}{ }\PYG{l+s}{其他include目录}
\PYG{+w}{        }\PYG{l+s}{//}\PYG{+w}{ }\PYG{l+s}{需要哪个外设就包含进去，例如用于相对湿度和温度测量的电容式数字传感器：Drivers/BSP/Components/hts221}
\PYG{p}{)}


\PYG{n+nb}{file}\PYG{p}{(}\PYG{l+s}{GLOB\PYGZus{}RECURSE}\PYG{+w}{ }\PYG{l+s}{SOURCES}
\PYG{+w}{        }\PYG{l+s+s2}{\PYGZdq{}Drivers/BSP/B\PYGZhy{}L475E\PYGZhy{}IOT01/*.*\PYGZdq{}}
\PYG{+w}{        }\PYG{l+s+s2}{\PYGZdq{}Drivers/BSP/Components/Common/*.*\PYGZdq{}}
\PYG{+w}{        }\PYG{l+s}{//}\PYG{+w}{ }\PYG{l+s}{*.*表示通配符，也就是这个文件夹里的所有文件都会被编译}
\PYG{+w}{        }\PYG{l+s}{//}\PYG{+w}{ }\PYG{l+s}{需要哪个外设就包含进去，例如用于相对湿度和温度测量的电容式数字传感器：}\PYG{l+s+s2}{\PYGZdq{}Drivers/BSP/Components/hts221/*.*\PYGZdq{}}
\PYG{+w}{        }\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
:exclamation: 注意

\sphinxAtStartPar
在 Keil 中，我们需要哪个 .c 或 .h文件，通常是直接添加进工程文件夹中，然后在软件的图形化界面中手动选择即可。在 CLion 是基于 CMake 来管理项目的，组织编译规则都是基于 CMakeLists.txt 文件。如果熟悉 CMake 会觉得很方便很强大，不熟悉的也没事，CLion 会自动生成 CMakeLists.txt 文件，基本不需要额外修改什么，只需要知道怎么在这个文件里面添加源码目录和 include 文件夹的路径就行了（感兴趣的同学可以自行了解 CMake 以及 CMake 与Makefile 的区别和联系:smiley:）。
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
添加 \textasciitilde{}User/sensor.c 文件

\end{itemize}

\sphinxAtStartPar
在实际开发中，为了方便管理，通常将完全由用户编写的代码独立成一个文件夹，新建\textasciitilde{}/sensor\_test/User 文件夹，在该文件夹中新建 sensor.c 文件。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
新建 User 目录

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801135833074}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
新建 .c 文件

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801135926264}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
选择 .c 文件，输入名称，取消勾选

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801140131115}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
sensor.c 文件中输入以下代码

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Includes \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}main.h\PYGZdq{}}

\PYG{c+cm}{/* Private typedef \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* Private define \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* Private macro \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* Private variables \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{k+kt}{int16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{pDataXYZ}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{float}\PYG{+w}{ }\PYG{n}{pGyroDataXYZ}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* Private function prototypes \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* Private functions \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Test of LPS22HB pressure sensor.}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Pressure\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{float}\PYG{+w}{ }\PYG{n}{press\PYGZus{}value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}PSENSOR\PYGZus{}Init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{press\PYGZus{}value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{BSP\PYGZus{}PSENSOR\PYGZus{}ReadPressure}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{PRESSURE is = \PYGZpc{}.2f mBar }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{press\PYGZus{}value}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Test of HTS221 humidity sensor.}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Humidity\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{float}\PYG{+w}{ }\PYG{n}{humidity\PYGZus{}value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}HSENSOR\PYGZus{}Init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{humidity\PYGZus{}value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{BSP\PYGZus{}HSENSOR\PYGZus{}ReadHumidity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HUMIDITY is = \PYGZpc{}.2f \PYGZpc{}\PYGZpc{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{humidity\PYGZus{}value}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Test of HTS221 and LPS22HB temperature sensors.}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Temperature\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{float}\PYG{+w}{ }\PYG{n}{temp\PYGZus{}value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}TSENSOR\PYGZus{}Init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef USE\PYGZus{}LPS22HB\PYGZus{}TEMP}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{*** Type n or N to get a first Temperature data from LPS22HB sensor ***}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else }\PYG{c+cm}{/* USE\PYGZus{}HTS221\PYGZus{}TEMP */}
\PYG{+w}{    }\PYG{c+c1}{//printf(\PYGZdq{}\PYGZbs{}n*** Type n or N to get a first Temperature data from HTS221 sensor ***\PYGZbs{}n\PYGZbs{}n\PYGZdq{});}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{+w}{    }\PYG{c+c1}{//printf(\PYGZdq{}\PYGZbs{}n*** Type q or Q to quit Temperature Test ***\PYGZbs{}n\PYGZbs{}n\PYGZdq{});}
\PYG{+w}{    }\PYG{n}{temp\PYGZus{}value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{BSP\PYGZus{}TSENSOR\PYGZus{}ReadTemp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TEMPERATURE is = \PYGZpc{}.2f }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{temp\PYGZus{}value}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Test of LSM6DSL accelerometer sensor.}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Accelero\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}ACCELERO\PYGZus{}Init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}ACCELERO\PYGZus{}AccGetXYZ}\PYG{p}{(}\PYG{n}{pDataXYZ}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ACCELERO\PYGZus{}X = \PYGZpc{}d }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pDataXYZ}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ACCELERO\PYGZus{}Y = \PYGZpc{}d }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pDataXYZ}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ACCELERO\PYGZus{}Z = \PYGZpc{}d }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pDataXYZ}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Test of LIS3MDL gyroscope sensor.}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Gyro\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}GYRO\PYGZus{}Init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}GYRO\PYGZus{}GetXYZ}\PYG{p}{(}\PYG{n}{pGyroDataXYZ}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GYRO\PYGZus{}X = \PYGZpc{}.2f }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pGyroDataXYZ}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GYRO\PYGZus{}Y = \PYGZpc{}.2f }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pGyroDataXYZ}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GYRO\PYGZus{}Z = \PYGZpc{}.2f }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pGyroDataXYZ}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Test of LIS3MDL magnetometer sensor.}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Magneto\PYGZus{}Test}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}MAGNETO\PYGZus{}Init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}MAGNETO\PYGZus{}GetXYZ}\PYG{p}{(}\PYG{n}{pDataXYZ}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MAGNETO\PYGZus{}X = \PYGZpc{}d }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pDataXYZ}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MAGNETO\PYGZus{}Y = \PYGZpc{}d }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pDataXYZ}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MAGNETO\PYGZus{}Z = \PYGZpc{}d }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pDataXYZ}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
修改 CMakeLists.txt 文件

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801140745026}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
\sphinxAtStartPar
修改 main.c 文件

\end{enumerate}

\sphinxAtStartPar
在while() 循环中添加以下代码

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN 3 */}
\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.......................}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Temperature\PYGZus{}Test}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Humidity\PYGZus{}Test}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Pressure\PYGZus{}Test}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Magneto\PYGZus{}Test}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Gyro\PYGZus{}Test}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Accelero\PYGZus{}Test}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{HAL\PYGZus{}Delay}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
编译下载程序后，打开 Serial Monitor 终端

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801141751640}.png}

\sphinxAtStartPar
可适当晃动实验箱，让数据明显变化:smirk:。

\sphinxstepscope


\section{BLE低功耗蓝牙实验}
\label{\detokenize{exp-stm32/ble/index:ble}}\label{\detokenize{exp-stm32/ble/index::doc}}
\sphinxAtStartPar
content here


\subsection{BLE简介}
\label{\detokenize{exp-stm32/ble/index:id1}}
\sphinxAtStartPar
content here


\subsection{实验内容}
\label{\detokenize{exp-stm32/ble/index:id2}}
\sphinxAtStartPar
本节包含两个实验，分别为：

\sphinxstepscope


\subsubsection{GATT}
\label{\detokenize{exp-stm32/ble/ble-gatt:gatt}}\label{\detokenize{exp-stm32/ble/ble-gatt::doc}}
\sphinxAtStartPar
内容\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}


\paragraph{实验目的}
\label{\detokenize{exp-stm32/ble/ble-gatt:id1}}
\sphinxAtStartPar
内容\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}


\paragraph{准备工作}
\label{\detokenize{exp-stm32/ble/ble-gatt:id2}}
\sphinxAtStartPar
内容\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}


\subparagraph{硬件}
\label{\detokenize{exp-stm32/ble/ble-gatt:id3}}
\sphinxAtStartPar
内容\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}


\subparagraph{软件}
\label{\detokenize{exp-stm32/ble/ble-gatt:id4}}
\sphinxAtStartPar
内容\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}


\paragraph{相关电路原理}
\label{\detokenize{exp-stm32/ble/ble-gatt:id5}}
\sphinxAtStartPar
内容\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}


\paragraph{引脚定义与相关API}
\label{\detokenize{exp-stm32/ble/ble-gatt:api}}
\sphinxAtStartPar
内容\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}


\paragraph{实验步骤}
\label{\detokenize{exp-stm32/ble/ble-gatt:id6}}
\sphinxAtStartPar
内容\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{include} 
\end{sphinxVerbatim}

\sphinxstepscope


\subsubsection{BLE点对点(P2P)通信}
\label{\detokenize{exp-stm32/ble/ble-p2p:ble-p2p}}\label{\detokenize{exp-stm32/ble/ble-p2p::doc}}
\sphinxstepscope


\subsubsection{Profiles}
\label{\detokenize{exp-stm32/ble/Profiles:profiles}}\label{\detokenize{exp-stm32/ble/Profiles::doc}}\begin{quote}

\sphinxAtStartPar
:exclamation: 注意

\sphinxAtStartPar
本文主要参考以下文档：

\sphinxAtStartPar
:link: \sphinxhref{https://www.st.com/content/ccc/resource/technical/document/application\_note/a3/2e/0f/af/25/96/4d/5d/DM00155171.pdf/files/DM00155171.pdf/jcr:content/translations/en.DM00155171.pdf}{Overview of the BLE Profiles application for X\sphinxhyphen{}CUBE\sphinxhyphen{}BLE1}

\sphinxAtStartPar
:link: \sphinxhref{https://www.st.com/content/ccc/resource/technical/document/user\_manual/b3/37/62/19/ea/9f/48/4d/DM00169392.pdf/files/DM00169392.pdf/jcr:content/translations/en.DM00169392.pdf}{Getting started with the X\sphinxhyphen{}CUBE\sphinxhyphen{}BLE1 Bluetooth Low Energy software expansion for STM32Cube}
\end{quote}

\sphinxAtStartPar
本章节完成与 \sphinxstylestrong{BLE Profiles} 相关的实验，而在 BLE 开发过程中，需要先了解两个协议：GAP（Generic Access Profile）和 GATT  (Generic Attribute Profile) ，中文名分别是\sphinxstylestrong{通用访问协议}和\sphinxstylestrong{通用属性协议}。这两个协议都隶属于整个蓝牙协议中的Host层，直接关系到应用层开发，两个协议分别负责连接前数据广播和连接后的数据传输，更详细的说明请自行搜索了解。低功耗蓝牙协议栈框架如图所示：



\sphinxAtStartPar
BLE Profiles 应用程序支持 BLE peripheral 和 central roles，支持的 slave profiles 包括：

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220902161416654}.png}


\paragraph{实验目的}
\label{\detokenize{exp-stm32/ble/Profiles:id1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
学习蓝牙的Profiles

\end{itemize}


\paragraph{准备工作}
\label{\detokenize{exp-stm32/ble/Profiles:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
手机安装有 ST BLE Sensor 和ST BLE Profile软件

\item {} 
\sphinxAtStartPar
STM32CubeMX 中安装 X\sphinxhyphen{}CUBE\sphinxhyphen{}BLE1 软件包，安装方式如下：

\end{itemize}






\subparagraph{硬件}
\label{\detokenize{exp-stm32/ble/Profiles:id3}}
\sphinxAtStartPar
实验箱、手机、PC


\subparagraph{软件}
\label{\detokenize{exp-stm32/ble/Profiles:id4}}
\sphinxAtStartPar
ST BLE Sensor、ST BLE Profile、CLion、STM32CubeMX


\paragraph{相关电路原理}
\label{\detokenize{exp-stm32/ble/Profiles:id5}}
\sphinxAtStartPar
蓝牙模块使用的是开发板的SPI3接口


\paragraph{引脚定义与相关API}
\label{\detokenize{exp-stm32/ble/Profiles:api}}
\sphinxAtStartPar
内容\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}\textasciitilde{}


\paragraph{实验步骤}
\label{\detokenize{exp-stm32/ble/Profiles:id6}}

\subparagraph{STM32CubeMX创建工程}
\label{\detokenize{exp-stm32/ble/Profiles:stm32cubemx}}
\sphinxAtStartPar
主要流程与前面的实验相同，不同之处在于要选择使用 X\sphinxhyphen{}CUBE\sphinxhyphen{}BLE1 包，配置 SPI 引脚
\begin{itemize}
\item {} 
\sphinxAtStartPar
选择 X\sphinxhyphen{}CUBE\sphinxhyphen{}BLE1 包

\end{itemize}

\sphinxAtStartPar
点击 \sphinxstylestrong{Select Components}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220902203244703}.png}

\sphinxAtStartPar
配置如图所示，右边是相关文档说明，点击 \sphinxstylestrong{Ok}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20230303225306939}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
配置引脚

\end{itemize}

\sphinxAtStartPar
左侧出现 Software Packs 选项，配置如图所示

\sphinxAtStartPar
\sphinxincludegraphics{{image-20230303225622228}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
修改 SPI3 的参数，按照官方文档说明，Data Size 配置为 8 Bits，Baud Rate 不超过 8.0 MBits/s

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220902203839943}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
最后生成工程

\end{itemize}


\subparagraph{代码编写及运行结果}
\label{\detokenize{exp-stm32/ble/Profiles:id7}}\begin{itemize}
\item {} 
\sphinxAtStartPar
先测试工程是否能正常运行，这需要用到ST BLE Sensor软件。代码烧录后，打开软件，可以搜索出BlueNRG

\end{itemize}


\begin{itemize}
\item {} 
\sphinxAtStartPar
连接后出现以下界面，就说明配置正确，这样子就把需要用到的协议栈添加到了工程中，这就实现了一个profiles

\end{itemize}



\sphinxAtStartPar
\sphinxincludegraphics{{image-20230303231225116}.png}


\subparagraph{HR Profiles的实现}
\label{\detokenize{exp-stm32/ble/Profiles:hr-profiles}}
\sphinxAtStartPar
除此之外，蓝牙还有其他profiles，例如HID、HR、HT等，接下来尝试移植HR Profiles（即心率）。


\subparagraph{STM32 LL库}
\label{\detokenize{exp-stm32/ble/Profiles:stm32-ll}}
\sphinxAtStartPar
由于官方的BLE例程中用到了LL库，因此，在移植其余Profiles前，需要大概了解一下LL库。
\begin{quote}

\sphinxAtStartPar
LL库旨在提供快速轻巧的面向专家的层，其比 HAL 库更接近硬件。 与 HAL 相反，LL API 不是提供给优化访问不是关键功能的外围设备或需要繁重的软件配置和/或复杂的上层协议栈（例如 FSMC，USB 或 SDMMC）。
在设计上，LL 库的 API 旨在用于独立模式或与 HAL 库结合使用。不过它们不能与 HAL库同时用于相同的外设实例。如果您将 LL api 用于特定的外设实例，那么您仍然可以将 HAL api 用于其他外设实例。注意，LL api可能会覆盖一些寄存器，这些寄存器的内容被映射到 HAL 句柄中。
\end{quote}

\sphinxAtStartPar
在用cubemx生成的工程中，会自动包含LL库的头文件，如图：

\sphinxAtStartPar
\sphinxincludegraphics{{image-20230304142916442}.png}


\subparagraph{开始移植}
\label{\detokenize{exp-stm32/ble/Profiles:id8}}
\sphinxAtStartPar
了解这些后，我们来看看官方例程，路径为：\textasciitilde{}/STM32Cube/Repository/STM32Cube\_FW\_L4\_V1.17.2/Projects/B\sphinxhyphen{}L475E\sphinxhyphen{}IOT01A/Applications/BLE/HeartRate

\sphinxAtStartPar
这个例程展示了如何使用BLE组件的HeartRate Profiles。
\begin{quote}

\sphinxAtStartPar
需要注意的是，由于这个例程不是用cubemx生成的（年代久远的例程），因此不能用clion打开。
\end{quote}

\sphinxAtStartPar
在该例程中，用到的关键函数如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{  }\PYG{c+cm}{/**}
\PYG{c+cm}{   * Configure the RTC}
\PYG{c+cm}{   */}
\PYG{+w}{  }\PYG{n}{Init\PYGZus{}RTC}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{                              }\PYG{c+cm}{/**\PYGZlt{} Initialize the RTC IP */}
\PYG{+w}{  }\PYG{n}{HW\PYGZus{}TS\PYGZus{}Init}\PYG{p}{(}\PYG{n}{hw\PYGZus{}ts\PYGZus{}InitMode\PYGZus{}Full}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{hrtc}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }\PYG{c+cm}{/**\PYGZlt{} Initialize the TimerServer */}
\PYG{c+c1}{//.............}

\PYG{+w}{    }\PYG{c+cm}{/**}
\PYG{c+cm}{   * It shall be registered before calling HR\PYGZus{}Init()}
\PYG{c+cm}{   */}
\PYG{+w}{  }\PYG{n}{SCH\PYGZus{}RegTask}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{CFG\PYGZus{}IdleTask\PYGZus{}MeasReq}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{HRSAPP\PYGZus{}Measurement}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{SCH\PYGZus{}RegTask}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{CFG\PYGZus{}IdleTask\PYGZus{}HciAsynchEvt}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{TL\PYGZus{}BLE\PYGZus{}HCI\PYGZus{}UserEvtProc}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{SCH\PYGZus{}RegTask}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{CFG\PYGZus{}IdleTask\PYGZus{}TlEvt}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{TL\PYGZus{}BLE\PYGZus{}R\PYGZus{}EvtProc}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{SCH\PYGZus{}RegTask}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{CFG\PYGZus{}IdleTask\PYGZus{}ConnMgr}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{HR\PYGZus{}AdvUpdate}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/**}
\PYG{c+cm}{   * BLE application start}
\PYG{c+cm}{   */}
\PYG{+w}{  }\PYG{n}{HR\PYGZus{}Init}\PYG{p}{(}\PYG{n}{HR\PYGZus{}Full}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//.............}

\PYG{+w}{  }\PYG{n}{SCH\PYGZus{}Run}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
移植过程省略。。。


\subparagraph{运行结果}
\label{\detokenize{exp-stm32/ble/Profiles:id9}}
\sphinxAtStartPar
下载程序后，打开手机的GPS和蓝牙，可搜索出HR\_L475\_IoT，连接后可看到以下现象。（注意，这个心率不是真正的心率，大家也可以想到的，因为所用的开发板上并没有心率传感器，这个心率只是用RTC生成的随机心率，实际使用的话，需要在代码中修改为心率传感器测得的心率）。



\sphinxstepscope


\section{NFC 写卡实验}
\label{\detokenize{exp-stm32/nfc:nfc}}\label{\detokenize{exp-stm32/nfc::doc}}
\sphinxAtStartPar
NFC是一种短距离的高频无线通信技术，允许电子设备之间进行非接触式点对点数据传输，详细说明还是自己参考维基百科吧\sphinxhref{https://en.wikipedia.org/wiki/Near-field\_communication}{Near\sphinxhyphen{}field communication(NFC)}


\subsection{实验目的}
\label{\detokenize{exp-stm32/nfc:id1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
NFC 向手机写 AAR NDEF 信息

\item {} 
\sphinxAtStartPar
NFC 向手机写 NDEF 信息

\end{itemize}


\subsection{准备工作}
\label{\detokenize{exp-stm32/nfc:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
有 NFC 功能的手机

\item {} 
\sphinxAtStartPar
手机安装 ST BLE Profile 软件

\end{itemize}
\begin{quote}

\sphinxAtStartPar
:exclamation: 注意

\sphinxAtStartPar
手机要开启 NFC，若最终的实验现象跟文档演示的不符，例如扫 NFC 后出现某个软件，则需要把该软件的 NFC 功能关闭，例如扫了之后出现京东 APP，则需把京东 APP 的 NFC 权限关闭。
\end{quote}


\subsubsection{硬件}
\label{\detokenize{exp-stm32/nfc:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
物联网实验箱

\item {} 
\sphinxAtStartPar
USB 数据线

\item {} 
\sphinxAtStartPar
mobile phone

\end{itemize}


\subsubsection{软件}
\label{\detokenize{exp-stm32/nfc:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
CLion

\item {} 
\sphinxAtStartPar
STM32CubeMX

\item {} 
\sphinxAtStartPar
ST BLE Profile.apk

\end{itemize}


\subsection{相关电路原理}
\label{\detokenize{exp-stm32/nfc:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
STM32 与 NFC 的硬件连接

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801154527029}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801155333108}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
STM32 与 USER 按键硬件连接

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801155006261}.png}


\subsection{引脚定义与相关API}
\label{\detokenize{exp-stm32/nfc:api}}\begin{itemize}
\item {} 
\sphinxAtStartPar
引脚定义

\end{itemize}

\sphinxAtStartPar
PE2 配置为 GPIO\_Output， PE4 配置为 GPIO\_Output，PB10 配置为 SCL引脚，PB11 配置为 SDA引脚
\begin{itemize}
\item {} 
\sphinxAtStartPar
相关API

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  This fonction write NDEF file from data given in the URI structure}
\PYG{c+cm}{  * @param  pURI : pointer on URI structure to prepare NDEF}
\PYG{c+cm}{  * @retval SUCCESS : NDEF URI stored}
\PYG{c+cm}{  * @retval ERROR : Not able to store NDEF URI}
\PYG{c+cm}{  */}
\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{TT4\PYGZus{}WriteURI}\PYG{p}{(}\PYG{n}{sURI\PYGZus{}Info}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{pURI}\PYG{p}{)}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  This fonction write NDEF file from data given in the SMS structure}
\PYG{c+cm}{  * @param  pSMS : pointer on SMS structure to prepare NDEF}
\PYG{c+cm}{  * @retval SUCCESS : NDEF SMS stored}
\PYG{c+cm}{  * @retval ERROR : Not able to store NDEF SMS}
\PYG{c+cm}{  */}
\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{TT4\PYGZus{}WriteSMS}\PYG{p}{(}\PYG{n}{sSMSInfo}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{pSMS}\PYG{p}{)}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  This fonction write NDEF file from data given in the eMail structure}
\PYG{c+cm}{  * @param  pEmailStruct : pointer on eMail structure to prepare NDEF}
\PYG{c+cm}{  * @retval SUCCESS : NDEF eMail stored}
\PYG{c+cm}{  * @retval ERROR : Not able to store NDEF eMail}
\PYG{c+cm}{  */}
\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{TT4\PYGZus{}WriteEmail}\PYG{p}{(}\PYG{n}{sEmailInfo}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{pEmailStruct}\PYG{p}{)}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  This fonction add AAR (Android Application Record) in the tag}
\PYG{c+cm}{  * @param  pAAR : pointer on structure that contain AAR information}
\PYG{c+cm}{  * @retval SUCCESS : AAR added}
\PYG{c+cm}{  * @retval ERROR : Not able to add AAR}
\PYG{c+cm}{  */}
\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{TT4\PYGZus{}AddAAR}\PYG{p}{(}\PYG{n}{sAARInfo}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{pAAR}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{实验步骤}
\label{\detokenize{exp-stm32/nfc:id6}}

\subsubsection{写NDEF信息}
\label{\detokenize{exp-stm32/nfc:ndef}}

\paragraph{STM32CubeMX创建工程}
\label{\detokenize{exp-stm32/nfc:stm32cubemx}}\begin{itemize}
\item {} 
\sphinxAtStartPar
以开发板为模板生成工程，保持默认设置，不修改任何引脚配置和时钟配置

\end{itemize}


\paragraph{代码编写及运行结果}
\label{\detokenize{exp-stm32/nfc:id7}}\begin{itemize}
\item {} 
\sphinxAtStartPar
添加需要的 .c 和 .h 文件

\end{itemize}

\sphinxAtStartPar
新建 User 文件夹，

\sphinxAtStartPar
将 \sphinxstylestrong{/home/lmx/STM32Cube/Repository/STM32Cube\_FW\_L4\_V1.17.2/Projects/B\sphinxhyphen{}L475E\sphinxhyphen{}IOT01A/Applications/NFC/Common} 路径下的

\sphinxAtStartPar
\sphinxstylestrong{M24SR} 和 \sphinxstylestrong{NDEF\_TagType4\_lib} 文件夹和

\sphinxAtStartPar
\sphinxstylestrong{/home/lmx/STM32Cube/Repository/STM32Cube\_FW\_L4\_V1.17.2/Projects/B\sphinxhyphen{}L475E\sphinxhyphen{}IOT01A/Applications/NFC/WriteTag/Inc} 路径下的

\sphinxAtStartPar
\sphinxstylestrong{nfc\_config.h}和 \sphinxstylestrong{VcardCSL1.h} 文件添加到新建的 \sphinxstylestrong{User} 文件夹下。

\sphinxAtStartPar
再将 \sphinxstylestrong{BSP} 文件夹添加到工程文件夹的 \sphinxstylestrong{\textasciitilde{}/Drivers} 目录下（这么长的路径都看晕了是吧:dizzy\_face::dizzy\_face:，熟悉命令行操作的同学话建议直接命令行解决）
\begin{quote}

\sphinxAtStartPar
顺便复习一下 Linux 的 cp 命令 ，cp 命令的基本格式如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[}root@localhost \PYGZti{}\PYG{o}{]}\PYG{c+c1}{\PYGZsh{} cp [选项] 源文件 目标文件}
\end{sphinxVerbatim}

\sphinxAtStartPar
选项：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhyphen{}a：相当于 \sphinxhyphen{}d、\sphinxhyphen{}p、\sphinxhyphen{}r 选项的集合，这几个选项我们一一介绍；

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}d：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接；

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}i：询问，如果目标文件已经存在，则会询问是否覆盖；

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}l：把目标文件建立为源文件的硬链接文件，而不是复制源文件；

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}s：把目标文件建立为源文件的软链接文件，而不是复制源文件；

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}p：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）；

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}r：递归复制，用于复制目录；

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}u：若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。

\end{itemize}

\sphinxAtStartPar
觉得太长的话，只需要记住常用的 \sphinxhyphen{}r，\sphinxhyphen{}a 选项就足够了，更详细的用法请自行了解。
\end{quote}

\sphinxAtStartPar
完成后是这样子的。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801170453558}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
修改 \textasciitilde{}/Core/Src/stm32l4xx\_it.c 文件

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
包含头文件

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN Includes */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32l475e\PYGZus{}iot01.h\PYGZdq{}}
\PYG{c+cm}{/* USER CODE END Includes */}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
添加中断服务程序

\end{enumerate}

\sphinxAtStartPar
若 EXTI15\_10\_IRQHandler 报错，把 stm32l4xx\_it.c 文件原来的 EXTI15\_10\_IRQHandler 函数整段删除

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN 1 */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EXTI4\PYGZus{}IRQHandler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}EXTI\PYGZus{}IRQHandler}\PYG{p}{(}\PYG{n}{NFC\PYGZus{}GPIO\PYGZus{}GPO\PYGZus{}PIN}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EXTI15\PYGZus{}10\PYGZus{}IRQHandler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}EXTI\PYGZus{}IRQHandler}\PYG{p}{(}\PYG{n}{USER\PYGZus{}BUTTON\PYGZus{}PIN}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/* USER CODE END 1 */}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
修改 \textasciitilde{}/Core/Inc/stm32l4xx\_it.h 文件

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN EFP */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EXTI15\PYGZus{}10\PYGZus{}IRQHandler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EXTI4\PYGZus{}IRQHandler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{     }\PYG{c+cm}{/* NFC Gpo pin */}
\PYG{c+cm}{/* USER CODE END EFP */}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
修改 main.c 文件

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
添加需要的头文件

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Private includes \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* USER CODE BEGIN Includes */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}string.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stdio.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stdbool.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stm32l475e\PYGZus{}iot01.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}lib\PYGZus{}TT4\PYGZus{}interface.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}m24sr.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}VcardCSL1.h\PYGZdq{}}
\PYG{c+cm}{/* USER CODE END Includes */}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
添加所需变量和函数声明

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Private typedef \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* USER CODE BEGIN PTD */}
\PYG{k}{typedef}\PYG{+w}{ }\PYG{k}{struct}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{void}\PYG{+w}{   }\PYG{p}{(}\PYG{o}{*}\PYG{n}{DemoFunc}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{DemoName}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{DemoIndex}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{n}{BSP\PYGZus{}DemoTypedef}\PYG{p}{;}

\PYG{c+cm}{/* USER CODE END PTD */}

\PYG{c+cm}{/* Private define \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* USER CODE BEGIN PD */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define COUNT\PYGZus{}OF\PYGZus{}EXAMPLE(x)    (sizeof(x)}\PYG{c+cp}{/}\PYG{c+cp}{sizeof(BSP\PYGZus{}DemoTypedef))}
\PYG{c+cm}{/* USER CODE END PD */}

\PYG{c+cm}{/* Private macro \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* USER CODE BEGIN PM */}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{AARwrite\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{URIwrite\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Vcardwrite\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Vcardwrite\PYGZus{}demo2}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{SMSwrite\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EMAILwrite\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Toggle\PYGZus{}Led2}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{freq}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{SystemClock\PYGZus{}Config}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cm}{/* USER CODE END PM */}

\PYG{c+cm}{/* Private variables \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}

\PYG{c+cm}{/* USER CODE BEGIN PV */}
\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{UserPressButton}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{DemoIndex}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{BSP\PYGZus{}DemoTypedef}\PYG{+w}{  }\PYG{n}{NFC\PYGZus{}examples}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}\PYG{n}{URIwrite\PYGZus{}demo}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{URI}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}\PYG{n}{SMSwrite\PYGZus{}demo}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SMS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}\PYG{n}{EMAILwrite\PYGZus{}demo}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{EMAIL}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}\PYG{n}{Vcardwrite\PYGZus{}demo}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{vCARD}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}\PYG{n}{Vcardwrite\PYGZus{}demo2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{vCARD2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{        }\PYG{c+c1}{//\PYGZob{}AARwrite\PYGZus{}demo, \PYGZdq{}AAR\PYGZdq{}, 5\PYGZcb{},}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cm}{/* Field to fill for the SMS demonstration */}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{PhoneNumber}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+33612345678}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{Message}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This SMS was generated automatically by tapping your phone near BM1297}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{Instruction}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This is an example of NFC generated SMS using BM1297 board}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+cm}{/* Field to fill for the Vcard demonstration */}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{FirstName}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Help Desk}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{Title}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Customer support}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{Org}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{STMicroelectronics}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{HomeAddress}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{WorkAddress}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{190 avenue Celestin Coq 13106 ROUSSET FRANCE}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{HomeTel}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{WorkTel}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{CellTel}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+33 6 11 22 33 44}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{HomeEmail}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{WorkEmail}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{customer.service@st.com }\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+cm}{/* Field to fill for the Email demonstration */}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{EmailAdd}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{customer.service@st.com}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{Subject}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{M24SR S/N 754FHFGJF46G329 WARRANTY}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{EmailMessage}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{this is a demonstration to illustrate an automatic warranty activation email}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{Information}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{automatic warranty}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+cm}{/* USER CODE END PV */}

\PYG{c+cm}{/* Private function prototypes \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{SystemClock\PYGZus{}Config}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cm}{/* USER CODE BEGIN PFP */}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{AARwrite\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cm}{/* USER CODE END PFP */}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
修改 mian() 函数

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE BEGIN 1 */}
\PYG{+w}{    }\PYG{n}{GPIO\PYGZus{}InitTypeDef}\PYG{+w}{  }\PYG{n}{gpioinitstruct}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE END 1 */}

\PYG{+w}{  }\PYG{c+cm}{/* MCU Configuration\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}

\PYG{+w}{  }\PYG{c+cm}{/* Reset of all peripherals, Initializes the Flash interface and the Systick. */}
\PYG{+w}{  }\PYG{n}{HAL\PYGZus{}Init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/* USER CODE BEGIN Init */}

\PYG{+w}{  }\PYG{c+cm}{/* USER CODE END Init */}

\PYG{+w}{  }\PYG{c+cm}{/* Configure the system clock */}
\PYG{+w}{  }\PYG{n}{SystemClock\PYGZus{}Config}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{  }\PYG{c+cm}{/* USER CODE BEGIN SysInit */}

\PYG{+w}{  }\PYG{c+cm}{/* USER CODE END SysInit */}

\PYG{+w}{  }\PYG{c+cm}{/* Initialize all configured peripherals */}
\PYG{+w}{  }\PYG{c+cm}{/*}
\PYG{c+cm}{  MX\PYGZus{}GPIO\PYGZus{}Init();}
\PYG{c+cm}{  MX\PYGZus{}DFSDM1\PYGZus{}Init();}
\PYG{c+cm}{  MX\PYGZus{}I2C2\PYGZus{}Init();}
\PYG{c+cm}{  MX\PYGZus{}QUADSPI\PYGZus{}Init();}
\PYG{c+cm}{  MX\PYGZus{}SPI3\PYGZus{}Init();}
\PYG{c+cm}{  MX\PYGZus{}USART1\PYGZus{}UART\PYGZus{}Init();}
\PYG{c+cm}{  MX\PYGZus{}USART3\PYGZus{}UART\PYGZus{}Init();}
\PYG{c+cm}{  MX\PYGZus{}USB\PYGZus{}OTG\PYGZus{}FS\PYGZus{}PCD\PYGZus{}Init();*/}
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE BEGIN 2 */}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}LED\PYGZus{}Init}\PYG{p}{(}\PYG{n}{LED2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{\PYGZus{}\PYGZus{}HAL\PYGZus{}RCC\PYGZus{}GPIOA\PYGZus{}CLK\PYGZus{}ENABLE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{gpioinitstruct}\PYG{p}{.}\PYG{n}{Pin}\PYG{+w}{   }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}5}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{gpioinitstruct}\PYG{p}{.}\PYG{n}{Mode}\PYG{+w}{  }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}MODE\PYGZus{}OUTPUT\PYGZus{}PP}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{gpioinitstruct}\PYG{p}{.}\PYG{n}{Pull}\PYG{+w}{  }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}NOPULL}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{gpioinitstruct}\PYG{p}{.}\PYG{n}{Speed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}SPEED\PYGZus{}FREQ\PYGZus{}HIGH}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}Init}\PYG{p}{(}\PYG{n}{GPIOA}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{gpioinitstruct}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}PB\PYGZus{}Init}\PYG{p}{(}\PYG{n}{BUTTON\PYGZus{}USER}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{BUTTON\PYGZus{}MODE\PYGZus{}EXTI}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{TT4\PYGZus{}Init}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{SUCCESS}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}LED\PYGZus{}On}\PYG{p}{(}\PYG{n}{LED2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE END 2 */}

\PYG{+w}{  }\PYG{c+cm}{/* Infinite loop */}
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE BEGIN WHILE */}
\PYG{+w}{  }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+cm}{/* USER CODE END WHILE */}

\PYG{+w}{    }\PYG{c+cm}{/* USER CODE BEGIN 3 */}
\PYG{+w}{      }\PYG{n}{UserPressButton}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{      }\PYG{n}{NFC\PYGZus{}examples}\PYG{p}{[}\PYG{n}{DemoIndex}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{p}{.}\PYG{n}{DemoFunc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{      }\PYG{c+cm}{/* Toggle LEDs (different speed between each Test) */}
\PYG{+w}{      }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{UserPressButton}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{Toggle\PYGZus{}Led2}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{o}{*}\PYG{p}{(}\PYG{n}{DemoIndex}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{      }\PYG{c+cm}{/* If all Demo has been already executed, Reset DemoIndex to restart BSP example*/}
\PYG{+w}{      }\PYG{k}{if}\PYG{p}{(}\PYG{n}{DemoIndex}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{COUNT\PYGZus{}OF\PYGZus{}EXAMPLE}\PYG{p}{(}\PYG{n}{NFC\PYGZus{}examples}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{      }\PYG{p}{\PYGZob{}}
\PYG{+w}{          }\PYG{n}{DemoIndex}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{      }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{p}{\PYGZcb{}}
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE END 3 */}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
在 mian.c 文件下面添加所需的函数定义

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN 4 */}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{URIwrite\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{sURI\PYGZus{}Info}\PYG{+w}{ }\PYG{n}{URI}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+cm}{/* Prepare URI NDEF message content */}
\PYG{+w}{    }\PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{URI}\PYG{p}{.}\PYG{n}{protocol}\PYG{p}{,}\PYG{n}{URI\PYGZus{}ID\PYGZus{}0x01\PYGZus{}STRING}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{URI}\PYG{p}{.}\PYG{n}{URI\PYGZus{}Message}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{st.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{strcpy}\PYG{p}{(}\PYG{n}{URI}\PYG{p}{.}\PYG{n}{Information}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+cm}{/* First write NDEF */}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{TT4\PYGZus{}WriteURI}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{URI}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{SUCCESS}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{SMSwrite\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ERROR}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sSMSInfo}\PYG{+w}{ }\PYG{n}{SMSStruct}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sSMSInfo}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{pSMSStruct}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{pSMSStruct}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{SMSStruct}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pSMSStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{PhoneNumber}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{PhoneNumber}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{PhoneNumber}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pSMSStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Message}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Message}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{Message}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pSMSStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Information}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Instruction}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{Instruction}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TT4\PYGZus{}WriteSMS}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{n}{pSMSStruct}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{status}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{SUCCESS}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{Error\PYGZus{}Handler}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EMAILwrite\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ERROR}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sEmailInfo}\PYG{+w}{ }\PYG{n}{EmailStruct}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sEmailInfo}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{pEmailStruct}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{pEmailStruct}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{EmailStruct}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pEmailStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{EmailAdd}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{EmailAdd}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{EmailAdd}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pEmailStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Subject}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Subject}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{Subject}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pEmailStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Message}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{EmailMessage}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{EmailMessage}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pEmailStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Information}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Information}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{Information}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TT4\PYGZus{}WriteEmail}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{n}{pEmailStruct}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{status}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{SUCCESS}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{Error\PYGZus{}Handler}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Vcardwrite\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ERROR}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+cm}{/* USee a NDEF file Vcard with a default Jpeg embedded */}
\PYG{+w}{    }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TT4\PYGZus{}WriteNDEF}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{o}{*}\PYG{p}{)}\PYG{n}{uVcardCSL1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{status}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{SUCCESS}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{Error\PYGZus{}Handler}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Vcardwrite\PYGZus{}demo2}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ERROR}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sVcardInfo}\PYG{+w}{ }\PYG{n}{VcardStruct}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sVcardInfo}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{pVcardStruct}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{pVcardStruct}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{VcardStruct}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pVcardStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{FirstName}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{FirstName}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{FirstName}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pVcardStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Title}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Title}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{Title}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pVcardStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Org}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Org}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{Org}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pVcardStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{HomeAddress}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{HomeAddress}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{HomeAddress}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pVcardStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{WorkAddress}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{WorkAddress}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{WorkAddress}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pVcardStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{HomeTel}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{HomeTel}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{HomeTel}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pVcardStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{WorkTel}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{WorkTel}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{WorkTel}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pVcardStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{CellTel}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{CellTel}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{CellTel}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pVcardStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{HomeEmail}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{HomeEmail}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{HomeEmail}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pVcardStruct}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{WorkEmail}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{WorkEmail}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{WorkEmail}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TT4\PYGZus{}WriteVcard}\PYG{+w}{ }\PYG{p}{(}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{VcardStruct}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{status}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{SUCCESS}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{Error\PYGZus{}Handler}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{AARwrite\PYGZus{}demo}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ERROR}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{NULL\PYGZus{}NDEF}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sAARInfo}\PYG{+w}{ }\PYG{n}{AAR\PYGZus{}struct}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sAARInfo}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{pAAR}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{pAAR}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{AAR\PYGZus{}struct}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+cm}{/* to set only AAR force NDEF size to 0 before */}
\PYG{+w}{    }\PYG{n}{TT4\PYGZus{}WriteNDEF}\PYG{p}{(}\PYG{n}{NULL\PYGZus{}NDEF}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{memcpy}\PYG{p}{(}\PYG{n}{pAAR}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{PakageName}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{com.stm.bluetoothlevalidation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{com.stm.bluetoothlevalidation}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}


\PYG{+w}{    }\PYG{c+cm}{/* Add AAR record */}
\PYG{+w}{    }\PYG{n}{status}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{TT4\PYGZus{}AddAAR}\PYG{p}{(}\PYG{n}{pAAR}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{status}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{SUCCESS}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{Error\PYGZus{}Handler}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Toggle LEDs}
\PYG{c+cm}{  * @param  None}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{Toggle\PYGZus{}Led2}\PYG{p}{(}\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{freq}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}LED\PYGZus{}Toggle}\PYG{p}{(}\PYG{n}{LED2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}Delay}\PYG{p}{(}\PYG{n}{freq}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/* Public functions \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief EXTI line detection callback.}
\PYG{c+cm}{  * @param GPIO\PYGZus{}Pin: Specifies the pins connected EXTI line}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{HAL\PYGZus{}GPIO\PYGZus{}EXTI\PYGZus{}Callback}\PYG{p}{(}\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}Pin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{GPIO\PYGZus{}Pin}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{NFC\PYGZus{}GPIO\PYGZus{}GPO\PYGZus{}PIN}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{M24SR\PYGZus{}GPO\PYGZus{}Callback}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{USER\PYGZus{}BUTTON\PYGZus{}PIN}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}Pin}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{BSP\PYGZus{}PB\PYGZus{}GetState}\PYG{p}{(}\PYG{n}{BUTTON\PYGZus{}USER}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{RESET}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{UserPressButton}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/* USER CODE END 4 */}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
修改 CMakeLists.txt 文件

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
在56行中添加 “User/\sphinxstyleemphasis{.}”

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{file}\PYG{p}{(}\PYG{l+s}{GLOB\PYGZus{}RECURSE}\PYG{+w}{ }\PYG{l+s}{SOURCES}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Core/*.*\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}Drivers/*.*\PYGZdq{}}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}User/*.*\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
在最下方添加以下代码

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{include\PYGZus{}directories}\PYG{p}{(}
\PYG{+w}{        }\PYG{l+s}{Drivers/BSP/B\PYGZhy{}L475E\PYGZhy{}IOT01}
\PYG{+w}{        }\PYG{l+s}{Drivers/BSP/Components/Common}
\PYG{+w}{        }\PYG{l+s}{Drivers/BSP/Components/m24sr}
\PYG{+w}{        }\PYG{l+s}{User}
\PYG{+w}{        }\PYG{l+s}{User/M24SR}
\PYG{+w}{        }\PYG{l+s}{User/NDEF\PYGZus{}TagType4\PYGZus{}lib}
\PYG{+w}{        }\PYG{l+s}{//}\PYG{+w}{ }\PYG{l+s}{其他include目录}
\PYG{+w}{        }\PYG{l+s}{//}\PYG{+w}{ }\PYG{l+s}{需要哪个外设就包含进去，例如用于相对湿度和温度测量的电容式数字传感器：Drivers/BSP/Components/hts221}
\PYG{p}{)}


\PYG{n+nb}{file}\PYG{p}{(}\PYG{l+s}{GLOB\PYGZus{}RECURSE}\PYG{+w}{ }\PYG{l+s}{SOURCES}
\PYG{+w}{        }\PYG{l+s+s2}{\PYGZdq{}Drivers/BSP/B\PYGZhy{}L475E\PYGZhy{}IOT01/*.*\PYGZdq{}}
\PYG{+w}{        }\PYG{l+s+s2}{\PYGZdq{}Drivers/BSP/Components/Common/*.*\PYGZdq{}}
\PYG{+w}{        }\PYG{l+s+s2}{\PYGZdq{}Drivers/BSP/Components/m24sr/*.*\PYGZdq{}}
\PYG{+w}{        }\PYG{l+s+s2}{\PYGZdq{}User/M24SR/*.*\PYGZdq{}}
\PYG{+w}{        }\PYG{l+s+s2}{\PYGZdq{}User/NDEF\PYGZus{}TagType4\PYGZus{}lib/*.*\PYGZdq{}}
\PYG{+w}{        }\PYG{l+s}{//}\PYG{+w}{ }\PYG{l+s}{*.*表示通配符，也就是这个文件夹里的所有文件都会被编译}
\PYG{+w}{        }\PYG{l+s}{//}\PYG{+w}{ }\PYG{l+s}{需要哪个外设就包含进去，例如用于相对湿度和温度测量的电容式数字传感器：}\PYG{l+s+s2}{\PYGZdq{}Drivers/BSP/Components/hts221/*.*\PYGZdq{}}
\PYG{+w}{        }\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
编译并运行后，定位到有错误的文件，具体为 nfc\_tt4\_wrapper\_template.h 和 nfc\_tt4\_wrapper\_template.c 文件，将两文件的内容全部删除

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220802091749716}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220802091825437}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
再次编译运行，这时候可以看到开发板上的 LD2 绿灯闪烁。手机开启 NFC，靠近开发板，第一次可以看到手机自动跳转到 ST 官网。每次按下开发板上的 USER 按键切换后，会写入不同的信息，有以下三种，手机都会有不同的情况。

\end{itemize}
\begin{quote}

\sphinxAtStartPar
This example writes a different message each time the USER BUTTON is pressed:
\begin{itemize}
\item {} 
\sphinxAtStartPar
URI:    the “www.st.com” website is opened by the browser

\item {} 
\sphinxAtStartPar
SMS:    an SMS is prepeaed on the smartphone and ready to be sent to +33612345678

\item {} 
\sphinxAtStartPar
EMAIL:  an email is prepeaed on the smartphone and ready to be sent to customer.service@st.com

\end{itemize}
\end{quote}




\subsubsection{写AAR NDEF信息}
\label{\detokenize{exp-stm32/nfc:aar-ndef}}
\sphinxAtStartPar
看到这里同学们就会有疑问了，这个 NDEF 和 AAR NDEF 有什么区别呢:confused:？其实 AAR NDEF 只是一种特殊的 NDEF，详细说明请自行了解。

\sphinxAtStartPar
:link:\sphinxhref{https://old.gototags.com/nfc/ndef/android-application/}{AAR NDEF介绍}


\paragraph{代码编写及运行结果}
\label{\detokenize{exp-stm32/nfc:id8}}\begin{itemize}
\item {} 
\sphinxAtStartPar
可以直接在 写NDEF信息 的基础上进行代码修改，将 NFC\_examples{[}{]} 修改为以下形式

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BSP\PYGZus{}DemoTypedef}\PYG{+w}{  }\PYG{n}{NFC\PYGZus{}examples}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{//\PYGZob{}URIwrite\PYGZus{}demo, \PYGZdq{}URI\PYGZdq{}, 0\PYGZcb{},}
\PYG{+w}{        }\PYG{c+c1}{//\PYGZob{}SMSwrite\PYGZus{}demo, \PYGZdq{}SMS\PYGZdq{}, 1\PYGZcb{},}
\PYG{+w}{        }\PYG{c+c1}{//\PYGZob{}EMAILwrite\PYGZus{}demo, \PYGZdq{}EMAIL\PYGZdq{}, 2\PYGZcb{},}
\PYG{+w}{        }\PYG{c+c1}{//\PYGZob{}Vcardwrite\PYGZus{}demo, \PYGZdq{}vCARD\PYGZdq{}, 3\PYGZcb{},}
\PYG{+w}{        }\PYG{c+c1}{//\PYGZob{}Vcardwrite\PYGZus{}demo2, \PYGZdq{}vCARD2\PYGZdq{}, 4\PYGZcb{},}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}\PYG{n}{AARwrite\PYGZus{}demo}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{AAR}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
手机自动打开 ST BLE Profile 软件（要提前安装在手机上，如果手机没有，会跳转到谷歌商城下载，考虑到网络原因，请提前用提供的 apk 安装）

\end{itemize}



\sphinxstepscope


\section{wifi实验}
\label{\detokenize{exp-stm32/wifi/index:wifi}}\label{\detokenize{exp-stm32/wifi/index::doc}}
\sphinxAtStartPar
content here


\subsection{WiFi简介}
\label{\detokenize{exp-stm32/wifi/index:id1}}
\sphinxAtStartPar
content here


\subsection{实验内容}
\label{\detokenize{exp-stm32/wifi/index:id2}}
\sphinxAtStartPar
本节包含两个实验，分别为：

\sphinxstepscope


\subsubsection{TCP over WiFi}
\label{\detokenize{exp-stm32/wifi/tcp-over-wifi:tcp-over-wifi}}\label{\detokenize{exp-stm32/wifi/tcp-over-wifi::doc}}
\sphinxAtStartPar
B\sphinxhyphen{}L475E\sphinxhyphen{}IOT01A 板载的 WiFi 模块为 ISM43362\sphinxhyphen{}M3G\sphinxhyphen{}L44，其内部集成了 TCP/IP 协议栈，只需简单的 AT 指令即可建立无线连接。ISM43362\sphinxhyphen{}M3G\sphinxhyphen{}L44 可通过 UART 或 SPI 接口与单片机通信。那这个时候同学们就会有疑问了:thinking:，平时在单片机上用的 WiFi 透传模块几乎都是 UART 的，这款为什么有个 SPI 接口呢？

\sphinxAtStartPar
众所周知啊，单片机高速 WiFi 通信传输，是难以实现的，原因一般在于：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
支持高速通信的 WiFi 模块，一般是 USB、SDIO、或PCIE 接口，这些接口一般出现在 Cortex\sphinxhyphen{}A 系列的芯片，大多数 Cortex\sphinxhyphen{}M 系列的普通单片机是没有这种接口的。

\item {} 
\sphinxAtStartPar
即使某些单片机提供了这些接口，单片机和 WiFi模块的通信编程也会变得非常复杂，并造成单片机选型的成本增加。

\item {} 
\sphinxAtStartPar
普通单片机因资源（性能和存储）有限，难以支持实用的、较好性能的单片机 WiFi 方案。

\end{enumerate}

\sphinxAtStartPar
所以，大多数用在单片机系统上的 WiFi 模块，要么是以 UART 为主的，只能做一些基本的低速控制命令的传输，或者费了九牛二虎之力，集成了 USB、 SDIO、或 PCIE 接口的 WIFI 模块，但效果也很一般，且造价昂贵。因此，在普通单片机上做高速 WiFi  通信（类似 ESP32 这种自带 WiFi 的芯片不在讨论范围内）是难以实现的，而通过 SPI 方式传输，就可以改变这种情况。原因在于 SPI 为全双工通信，传输速率可达几 Mbps，并且大部分单片机上都有 SPI 外设。


\paragraph{实验目的}
\label{\detokenize{exp-stm32/wifi/tcp-over-wifi:id1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
了解 SPI 通信协议

\item {} 
\sphinxAtStartPar
实现 TCP over WiFi

\end{itemize}


\paragraph{准备工作}
\label{\detokenize{exp-stm32/wifi/tcp-over-wifi:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
:iphone:安装 TCP Server 软件

\end{itemize}


\subparagraph{硬件}
\label{\detokenize{exp-stm32/wifi/tcp-over-wifi:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
物联网实验箱

\item {} 
\sphinxAtStartPar
USB 数据线

\item {} 
\sphinxAtStartPar
:iphone:

\end{itemize}


\subparagraph{软件}
\label{\detokenize{exp-stm32/wifi/tcp-over-wifi:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
CLion

\item {} 
\sphinxAtStartPar
STM32CubeMX

\item {} 
\sphinxAtStartPar
TCP Server

\end{itemize}


\paragraph{相关电路原理}
\label{\detokenize{exp-stm32/wifi/tcp-over-wifi:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
STM32 与 WiFi 模块的硬件连接

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220805114113309}.png}
\begin{quote}

\sphinxAtStartPar
:exclamation: 注意

\sphinxAtStartPar
开发板将 wifi 模块的 spi 和 uart 都引出来了，但官方的驱动代码默认使用 spi 通信，可以在程序中修改宏定义的值，从而使用 uart 通信，后面会讲在哪个文件里修改。
\end{quote}


\paragraph{引脚定义与相关API}
\label{\detokenize{exp-stm32/wifi/tcp-over-wifi:api}}\begin{itemize}
\item {} 
\sphinxAtStartPar
引脚定义

\item {} 
\sphinxAtStartPar
相关API

\end{itemize}


\paragraph{实验步骤}
\label{\detokenize{exp-stm32/wifi/tcp-over-wifi:id6}}

\subparagraph{STM32CubeMX创建工程}
\label{\detokenize{exp-stm32/wifi/tcp-over-wifi:stm32cubemx}}\begin{itemize}
\item {} 
\sphinxAtStartPar
以开发板为模板生成工程，保持默认设置，不修改任何引脚配置和时钟配置

\end{itemize}


\subparagraph{代码编写及运行结果}
\label{\detokenize{exp-stm32/wifi/tcp-over-wifi:id7}}\begin{itemize}
\item {} 
\sphinxAtStartPar
添加需要的源文件和板级支持包（BSP）

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
添加 BSP（步骤跟前面的章节相同），创建 \textasciitilde{}User/wifi 文件夹

\item {} 
\sphinxAtStartPar
将以下路径中的四个 .h 文件添加到新建的 \textasciitilde{}User/wifi 目录下，并将 es\_wifi\_conf\_template.h 的文件名修改为 es\_wifi\_conf.h \sphinxincludegraphics{{image-20220805143154915}.png}

\item {} 
\sphinxAtStartPar
将以下路径中的三个 .c 文件添加到新建的 \textasciitilde{}User/wifi 目录下\sphinxincludegraphics{{image-20220805143407206}.png}

\end{enumerate}

\sphinxAtStartPar
完成后是这样的

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220805144509757}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
修改 CMakeLists.txt 文件

\end{itemize}

\sphinxAtStartPar
第56行添加 User

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220805145141169}.png}

\sphinxAtStartPar
添加以下 include\_directories 和 file 路径

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{include\PYGZus{}directories}\PYG{p}{(}
\PYG{+w}{        }\PYG{l+s}{Drivers/BSP/B\PYGZhy{}L475E\PYGZhy{}IOT01}
\PYG{+w}{        }\PYG{l+s}{User/wifi}
\PYG{+w}{        }\PYG{l+s}{//}\PYG{+w}{ }\PYG{l+s}{其他include目录}
\PYG{p}{)}


\PYG{n+nb}{file}\PYG{p}{(}\PYG{l+s}{GLOB\PYGZus{}RECURSE}\PYG{+w}{ }\PYG{l+s}{SOURCES}
\PYG{+w}{        }\PYG{l+s+s2}{\PYGZdq{}User/wifi/*.*\PYGZdq{}}
\PYG{+w}{        }\PYG{l+s+s2}{\PYGZdq{}Drivers/BSP/B\PYGZhy{}L475E\PYGZhy{}IOT01/*.*\PYGZdq{}}
\PYG{+w}{        }\PYG{l+s}{//}\PYG{+w}{ }\PYG{l+s}{*.*表示通配符，也就是这个文件夹里的所有文件都会被编译}
\PYG{+w}{        }\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
修改 es\_wifi\_conf.h 文件，将原有的代码替换成以下代码

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/**}
\PYG{c+cm}{  ******************************************************************************}
\PYG{c+cm}{  * @file    es\PYGZus{}wifi\PYGZus{}conf.h}
\PYG{c+cm}{  * @author  MCD Application Team}
\PYG{c+cm}{  * @brief   ES\PYGZhy{}WIFI configuration.}
\PYG{c+cm}{  ******************************************************************************}
\PYG{c+cm}{  * @attention}
\PYG{c+cm}{  *}
\PYG{c+cm}{  * Copyright (c) 2017 STMicroelectronics.}
\PYG{c+cm}{  * All rights reserved.}
\PYG{c+cm}{  *}
\PYG{c+cm}{  * This software is licensed under terms that can be found in the LICENSE file}
\PYG{c+cm}{  * in the root directory of this software component.}
\PYG{c+cm}{  * If no LICENSE file comes with this software, it is provided AS\PYGZhy{}IS.}
\PYG{c+cm}{  *}
\PYG{c+cm}{  ******************************************************************************}
\PYG{c+cm}{  */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef ES\PYGZus{}WIFI\PYGZus{}CONF\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}CONF\PYGZus{}H}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}\PYGZus{}cplusplus}
\PYG{+w}{ }\PYG{k}{extern}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif  }

\PYG{c+c1}{//\PYGZsh{}define WIFI\PYGZus{}USE\PYGZus{}CMSIS\PYGZus{}OS}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef WIFI\PYGZus{}USE\PYGZus{}CMSIS\PYGZus{}OS}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}cmsis\PYGZus{}os.h\PYGZdq{}}

\PYG{k}{extern}\PYG{+w}{ }\PYG{n}{osMutexId}\PYG{+w}{ }\PYG{n}{es\PYGZus{}wifi\PYGZus{}mutex}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define LOCK\PYGZus{}SPI()              osMutexWait(spi\PYGZus{}mutex, 0)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define UNLOCK\PYGZus{}SPI()            osMutexRelease(spi\PYGZus{}mutex)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define LOCK\PYGZus{}WIFI()             osMutexWait(es\PYGZus{}wifi\PYGZus{}mutex, 0)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define UNLOCK\PYGZus{}WIFI()           osMutexRelease(es\PYGZus{}wifi\PYGZus{}mutex)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SEM\PYGZus{}SIGNAL(a)           osSemaphoreRelease(a)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SEM\PYGZus{}WAIT(a,timeout)     osSemaphoreWait(a,timeout)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SPI\PYGZus{}INTERFACE\PYGZus{}PRIO              configMAX\PYGZus{}SYSCALL\PYGZus{}INTERRUPT\PYGZus{}PRIORITY}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define LOCK\PYGZus{}WIFI()}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define UNLOCK\PYGZus{}WIFI()}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define LOCK\PYGZus{}SPI()}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define UNLOCK\PYGZus{}SPI()}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SEM\PYGZus{}SIGNAL(a)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SPI\PYGZus{}INTERFACE\PYGZus{}PRIO              0}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}MAX\PYGZus{}SSID\PYGZus{}NAME\PYGZus{}SIZE                  32}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}MAX\PYGZus{}PSWD\PYGZus{}NAME\PYGZus{}SIZE                  32}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}PRODUCT\PYGZus{}ID\PYGZus{}SIZE                     32}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}PRODUCT\PYGZus{}NAME\PYGZus{}SIZE                   32}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}FW\PYGZus{}REV\PYGZus{}SIZE                         24}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}API\PYGZus{}REV\PYGZus{}SIZE                        16}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}STACK\PYGZus{}REV\PYGZus{}SIZE                      16}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}RTOS\PYGZus{}REV\PYGZus{}SIZE                       16}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}DATA\PYGZus{}SIZE                           2000  }\PYG{c+cm}{/*Increased from 1400 to fit scan result.*/}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}MAX\PYGZus{}DETECTED\PYGZus{}AP                     10}
\PYG{+w}{   }
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}TIMEOUT                             30000}
\PYG{+w}{                                                    }
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}USE\PYGZus{}PING                            1}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}USE\PYGZus{}AWS                             0}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}USE\PYGZus{}FIRMWAREUPDATE                  0}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}USE\PYGZus{}WPS                             0}
\PYG{+w}{                                                    }
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}USE\PYGZus{}SPI                             1}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}USE\PYGZus{}UART                            (!ES\PYGZus{}WIFI\PYGZus{}USE\PYGZus{}SPI)}
\PYG{+w}{   }


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}\PYGZus{}cplusplus}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* ES\PYGZus{}WIFI\PYGZus{}CONF\PYGZus{}H */}
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
:exclamation: 注意

\sphinxAtStartPar
若要使用 uart 通信，可以通过 es\_wifi\_conf.h 文件中的宏定义修改

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}USE\PYGZus{}SPI                             1	}\PYG{c+c1}{// 1为SPI，0为uart}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define ES\PYGZus{}WIFI\PYGZus{}USE\PYGZus{}UART                            (!ES\PYGZus{}WIFI\PYGZus{}USE\PYGZus{}SPI)}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
如果修改为 uart 通信，编译的时候会报错，这时候就要修改 es\_wifi.c 文件，添加 \sphinxcode{\sphinxupquote{char *ptr;}}。很多官方的代码偶尔会有一些小错误，根据实际情况修改并编译成功就行了。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220805150940641}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220805150916024}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
修改 stm32l4xx\_it.c 文件，添加以下代码

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN 1 */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{EXTI1\PYGZus{}IRQHandler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}EXTI\PYGZus{}IRQHandler}\PYG{p}{(}\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/* USER CODE END 1 */}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
修改 main.c 文件，让手机和开发板连接上同一个wifi

\end{itemize}

\sphinxAtStartPar
手机连接 wifi 后，打开 TCP Server 软件，会出现手机 IP 地址，修改 mian.c 中的 IP 地址。



\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Update SSID and PASSWORD with own Access point settings */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SSID     \PYGZdq{}LMX\PYGZdq{}      }\PYG{c+c1}{//wifi名称}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PASSWORD \PYGZdq{}luo010607\PYGZdq{}    }\PYG{c+c1}{//wifi密码}

\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{RemoteIP}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{192}\PYG{p}{,}\PYG{l+m+mi}{168}\PYG{p}{,}\PYG{l+m+mi}{137}\PYG{p}{,}\PYG{l+m+mi}{32}\PYG{p}{\PYGZcb{}}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{//手机IP地址，注意是 , 不是 .}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
编译下载代码后，等待开发板连接上 wifi，然后点击 APP 的 \sphinxstylestrong{CREATE} 创建 TCP 连接

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
右上角出现提示，此时开发板与手机通过 wifi 进行 TCP 通信

\end{enumerate}


\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
手机发送”hello, pxh!”到单片机:grin:，单片机接收到（可通过串口查看单片机接收到的信息）并回复”Hello!”

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220805153035459}.png}

\sphinxstepscope


\subsubsection{HTTP over WiFi}
\label{\detokenize{exp-stm32/wifi/http-over-wifi:http-over-wifi}}\label{\detokenize{exp-stm32/wifi/http-over-wifi::doc}}
\sphinxAtStartPar
TCP 协议是传输层协议，主要解决数据如何在网络中传输，而 HTTP 是应用层协议，主要解决如何包装数据。本章节将在开发板上的 WiFi 模块（已集成 TCP 协议）的基础上实现 HTTP 协议，从而实现 Web 接收开发板发送的温度传感器的数据，开发板接收 Web 端发送的控制 LED 灯命令。


\paragraph{实验目的}
\label{\detokenize{exp-stm32/wifi/http-over-wifi:id1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
了解 TCP 和 HTTP 协议的区别和联系

\item {} 
\sphinxAtStartPar
实现 HTTP over WiFi

\end{itemize}


\paragraph{准备工作}
\label{\detokenize{exp-stm32/wifi/http-over-wifi:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
手机或PC端的任意浏览器

\end{itemize}


\subparagraph{硬件}
\label{\detokenize{exp-stm32/wifi/http-over-wifi:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
物联网实验箱

\item {} 
\sphinxAtStartPar
USB 数据线

\end{itemize}


\subparagraph{软件}
\label{\detokenize{exp-stm32/wifi/http-over-wifi:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
CLion

\item {} 
\sphinxAtStartPar
STM32CubeMX

\item {} 
\sphinxAtStartPar
手机或PC端的任意浏览器

\end{itemize}


\paragraph{相关电路原理}
\label{\detokenize{exp-stm32/wifi/http-over-wifi:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
WiFi模块、LED 灯、温度传感器的相关电路原理与前面相关章节一致

\end{itemize}


\paragraph{引脚定义与相关API}
\label{\detokenize{exp-stm32/wifi/http-over-wifi:api}}\begin{itemize}
\item {} 
\sphinxAtStartPar
引脚定义

\end{itemize}

\sphinxAtStartPar
WiFi模块、LED 灯、温度传感器的引脚定义与前面相关章节一致
\begin{itemize}
\item {} 
\sphinxAtStartPar
相关API

\end{itemize}


\paragraph{实验步骤}
\label{\detokenize{exp-stm32/wifi/http-over-wifi:id6}}

\subparagraph{STM32CubeMX创建工程}
\label{\detokenize{exp-stm32/wifi/http-over-wifi:stm32cubemx}}\begin{itemize}
\item {} 
\sphinxAtStartPar
以开发板为模板生成工程，保持默认设置，不修改任何引脚配置和时钟配置

\end{itemize}


\subparagraph{代码编写及运行结果}
\label{\detokenize{exp-stm32/wifi/http-over-wifi:id7}}\begin{itemize}
\item {} 
\sphinxAtStartPar
在 \sphinxstylestrong{TCP over WiFi} 章节的基础上，修改 mian.c 文件

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
相关宏定义

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Private define \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* USER CODE BEGIN PD */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SSID     \PYGZdq{}LMX\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PASSWORD \PYGZdq{}luo010607\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PORT           80}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define TERMINAL\PYGZus{}USE}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define WIFI\PYGZus{}WRITE\PYGZus{}TIMEOUT 10000}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define WIFI\PYGZus{}READ\PYGZus{}TIMEOUT  10000}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SOCKET                 0}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef  TERMINAL\PYGZus{}USE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define LOG(a) printf a}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define LOG(a)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+cm}{/* USER CODE END PD */}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
变量和函数声明

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Private variables \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* USER CODE BEGIN PV */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if defined (TERMINAL\PYGZus{}USE)}
\PYG{k}{extern}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}HandleTypeDef}\PYG{+w}{ }\PYG{n}{hDiscoUart}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* TERMINAL\PYGZus{}USE */}

\PYG{k}{static}\PYG{+w}{  }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{http}\PYG{p}{[}\PYG{l+m+mi}{1024}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{  }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{  }\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{  }\PYG{k+kt}{int}\PYG{+w}{     }\PYG{n}{LedState}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+cm}{/* Private function prototypes \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if defined (TERMINAL\PYGZus{}USE)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef \PYGZus{}\PYGZus{}GNUC\PYGZus{}\PYGZus{}}
\PYG{c+cm}{/* With GCC, small printf (option LD Linker\PYGZhy{}\PYGZgt{}Libraries\PYGZhy{}\PYGZgt{}Small printf}
\PYG{c+cm}{   set to \PYGZsq{}Yes\PYGZsq{}) calls \PYGZus{}\PYGZus{}io\PYGZus{}putchar() */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PUTCHAR\PYGZus{}PROTOTYPE int \PYGZus{}\PYGZus{}io\PYGZus{}putchar(int ch)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define PUTCHAR\PYGZus{}PROTOTYPE int fputc(int ch, FILE *f)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* \PYGZus{}\PYGZus{}GNUC\PYGZus{}\PYGZus{} */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* TERMINAL\PYGZus{}USE */}

\PYG{k}{static}\PYG{+w}{  }\PYG{n}{WIFI\PYGZus{}Status\PYGZus{}t}\PYG{+w}{ }\PYG{n+nf}{SendWebPage}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{ledIsOn}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{temperature}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{  }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{wifi\PYGZus{}server}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{  }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{wifi\PYGZus{}start}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{  }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{wifi\PYGZus{}connect}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{static}\PYG{+w}{  }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{WebServerProcess}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cm}{/* USER CODE END PV */}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
修改 mian() 函数

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE BEGIN 2 */}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}LED\PYGZus{}Init}\PYG{p}{(}\PYG{n}{LED2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+cm}{/* WIFI Web Server demonstration */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if defined (TERMINAL\PYGZus{}USE)}
\PYG{+w}{    }\PYG{c+cm}{/* Initialize all configured peripherals */}
\PYG{+w}{    }\PYG{n}{hDiscoUart}\PYG{p}{.}\PYG{n}{Instance}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{DISCOVERY\PYGZus{}COM1}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{hDiscoUart}\PYG{p}{.}\PYG{n}{Init}\PYG{p}{.}\PYG{n}{BaudRate}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{115200}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{hDiscoUart}\PYG{p}{.}\PYG{n}{Init}\PYG{p}{.}\PYG{n}{WordLength}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}WORDLENGTH\PYGZus{}8B}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{hDiscoUart}\PYG{p}{.}\PYG{n}{Init}\PYG{p}{.}\PYG{n}{StopBits}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}STOPBITS\PYGZus{}1}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{hDiscoUart}\PYG{p}{.}\PYG{n}{Init}\PYG{p}{.}\PYG{n}{Parity}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}PARITY\PYGZus{}NONE}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{hDiscoUart}\PYG{p}{.}\PYG{n}{Init}\PYG{p}{.}\PYG{n}{Mode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}MODE\PYGZus{}TX\PYGZus{}RX}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{hDiscoUart}\PYG{p}{.}\PYG{n}{Init}\PYG{p}{.}\PYG{n}{HwFlowCtl}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}HWCONTROL\PYGZus{}NONE}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{hDiscoUart}\PYG{p}{.}\PYG{n}{Init}\PYG{p}{.}\PYG{n}{OverSampling}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}OVERSAMPLING\PYGZus{}16}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{hDiscoUart}\PYG{p}{.}\PYG{n}{Init}\PYG{p}{.}\PYG{n}{OneBitSampling}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}ONE\PYGZus{}BIT\PYGZus{}SAMPLE\PYGZus{}DISABLE}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{hDiscoUart}\PYG{p}{.}\PYG{n}{AdvancedInit}\PYG{p}{.}\PYG{n}{AdvFeatureInit}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}ADVFEATURE\PYGZus{}NO\PYGZus{}INIT}\PYG{p}{;}


\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}COM\PYGZus{}Init}\PYG{p}{(}\PYG{n}{COM1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{hDiscoUart}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{BSP\PYGZus{}TSENSOR\PYGZus{}Init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{****** WIFI Web Server demonstration****** }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* TERMINAL\PYGZus{}USE */}

\PYG{+w}{    }\PYG{n}{wifi\PYGZus{}server}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE END 2 */}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
函数定义

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN 4 */}
\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Send HTML page}
\PYG{c+cm}{  * @param  None}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}

\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{wifi\PYGZus{}start}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{  }\PYG{n}{MAC\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+cm}{/*Initialize and use WIFI module */}
\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}Init}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{  }\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}OK}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ES\PYGZhy{}WIFI Initialized.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}GetMAC\PYGZus{}Address}\PYG{p}{(}\PYG{n}{MAC\PYGZus{}Addr}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}OK}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{} eS\PYGZhy{}WiFi module MAC Address : \PYGZpc{}02X:\PYGZpc{}02X:\PYGZpc{}02X:\PYGZpc{}02X:\PYGZpc{}02X:\PYGZpc{}02X}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{MAC\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{MAC\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{MAC\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{MAC\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{MAC\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{MAC\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{else}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{} ERROR : CANNOT get MAC address}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{else}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{wifi\PYGZus{}connect}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

\PYG{+w}{    }\PYG{n}{wifi\PYGZus{}start}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Connecting to \PYGZpc{}s , \PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{SSID}\PYG{p}{,}\PYG{n}{PASSWORD}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}Connect}\PYG{p}{(}\PYG{n}{SSID}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{PASSWORD}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}ECN\PYGZus{}WPA2\PYGZus{}PSK}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}OK}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}GetIP\PYGZus{}Address}\PYG{p}{(}\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}OK}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{} es\PYGZhy{}wifi module connected: got IP Address : \PYGZpc{}d.\PYGZpc{}d.\PYGZpc{}d.\PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
\PYG{+w}{                    }\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{else}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ERROR : es\PYGZhy{}wifi module CANNOT get IP address}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{else}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR : es\PYGZhy{}wifi module NOT connected}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{wifi\PYGZus{}server}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{StopServer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Running HTML Server test}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{wifi\PYGZus{}connect}\PYG{p}{(}\PYG{p}{)}\PYG{o}{!}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}


\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}OK}\PYG{o}{!}\PYG{o}{=}\PYG{n}{WIFI\PYGZus{}StartServer}\PYG{p}{(}\PYG{n}{SOCKET}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}TCP\PYGZus{}PROTOCOL}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{PORT}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR: Cannot start server.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Server is running and waiting for an HTTP  Client connection to \PYGZpc{}d.\PYGZpc{}d.\PYGZpc{}d.\PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{do}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{RemoteIP}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{RemotePort}\PYG{p}{;}


\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}OK}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}WaitServerConnection}\PYG{p}{(}\PYG{n}{SOCKET}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{n}{RemoteIP}\PYG{p}{,}\PYG{o}{\PYGZam{}}\PYG{n}{RemotePort}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Waiting connection to  \PYGZpc{}d.\PYGZpc{}d.\PYGZpc{}d.\PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{IP\PYGZus{}Addr}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{p}{\PYGZcb{}}

\PYG{+w}{        }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Client connected \PYGZpc{}d.\PYGZpc{}d.\PYGZpc{}d.\PYGZpc{}d:\PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{RemoteIP}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{RemoteIP}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{RemoteIP}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{n}{RemoteIP}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}\PYG{n}{RemotePort}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{StopServer}\PYG{o}{=}\PYG{n}{WebServerProcess}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{k}{if}\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}CloseServerConnection}\PYG{p}{(}\PYG{n}{SOCKET}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}OK}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR: failed to close current Server connection}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{while}\PYG{p}{(}\PYG{n}{StopServer}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}OK}\PYG{o}{!}\PYG{o}{=}\PYG{n}{WIFI\PYGZus{}StopServer}\PYG{p}{(}\PYG{n}{SOCKET}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ERROR: Cannot stop server.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Server is stop}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{WebServerProcess}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{temp}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{  }\PYG{n}{respLen}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{static}\PYG{+w}{   }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{resp}\PYG{p}{[}\PYG{l+m+mi}{1024}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{bool}\PYG{+w}{    }\PYG{n}{stopserver}\PYG{o}{=}\PYG{n+nb}{false}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}OK}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}ReceiveData}\PYG{p}{(}\PYG{n}{SOCKET}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{resp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{respLen}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}READ\PYGZus{}TIMEOUT}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{get \PYGZpc{}d byte from server}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{respLen}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{k}{if}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{respLen}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{p}{(}\PYG{n}{strstr}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{resp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GET}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{c+cm}{/* GET: put web page */}
\PYG{+w}{            }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{temp}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{BSP\PYGZus{}TSENSOR\PYGZus{}ReadTemp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{k}{if}\PYG{p}{(}\PYG{n}{SendWebPage}\PYG{p}{(}\PYG{n}{LedState}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{temp}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}OK}\PYG{p}{)}
\PYG{+w}{                }\PYG{p}{\PYGZob{}}
\PYG{+w}{                    }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{} ERROR : Cannot send web page}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                }\PYG{k}{else}
\PYG{+w}{                }\PYG{p}{\PYGZob{}}
\PYG{+w}{                    }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Send page after  GET command}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{p}{(}\PYG{n}{strstr}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{resp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{POST}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{c+cm}{/* POST: received info */}
\PYG{+w}{            }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Post request}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{                }\PYG{k}{if}\PYG{p}{(}\PYG{n}{strstr}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{resp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{radio}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                }\PYG{p}{\PYGZob{}}
\PYG{+w}{                    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{strstr}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{resp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{radio=0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                    }\PYG{p}{\PYGZob{}}
\PYG{+w}{                        }\PYG{n}{LedState}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{                        }\PYG{n}{BSP\PYGZus{}LED\PYGZus{}Off}\PYG{p}{(}\PYG{n}{LED2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                    }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{p}{(}\PYG{n}{strstr}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{resp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{radio=1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                    }\PYG{p}{\PYGZob{}}
\PYG{+w}{                        }\PYG{n}{LedState}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{                        }\PYG{n}{BSP\PYGZus{}LED\PYGZus{}On}\PYG{p}{(}\PYG{n}{LED2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                    }\PYG{n}{temp}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{BSP\PYGZus{}TSENSOR\PYGZus{}ReadTemp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                }\PYG{k}{if}\PYG{p}{(}\PYG{n}{strstr}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{resp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{stop\PYGZus{}server}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                }\PYG{p}{\PYGZob{}}
\PYG{+w}{                    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{strstr}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{resp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{stop\PYGZus{}server=0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                    }\PYG{p}{\PYGZob{}}
\PYG{+w}{                        }\PYG{n}{stopserver}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{                    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                    }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{p}{(}\PYG{n}{strstr}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{resp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{stop\PYGZus{}server=1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{                    }\PYG{p}{\PYGZob{}}
\PYG{+w}{                        }\PYG{n}{stopserver}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{                    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                }\PYG{n}{temp}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{BSP\PYGZus{}TSENSOR\PYGZus{}ReadTemp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{k}{if}\PYG{p}{(}\PYG{n}{SendWebPage}\PYG{p}{(}\PYG{n}{LedState}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{temp}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}OK}\PYG{p}{)}
\PYG{+w}{                }\PYG{p}{\PYGZob{}}
\PYG{+w}{                    }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZgt{} ERROR : Cannot send web page}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                }\PYG{k}{else}
\PYG{+w}{                }\PYG{p}{\PYGZob{}}
\PYG{+w}{                    }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Send Page after POST command}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{else}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{LOG}\PYG{p}{(}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Client close connection}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{stopserver}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Send HTML page}
\PYG{c+cm}{  * @param  None}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{k}{static}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}Status\PYGZus{}t}\PYG{+w}{ }\PYG{n+nf}{SendWebPage}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{ledIsOn}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{temperature}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{  }\PYG{n}{temp}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{SentDataLength}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{WIFI\PYGZus{}Status\PYGZus{}t}\PYG{+w}{ }\PYG{n}{ret}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+cm}{/* construct web page content */}
\PYG{+w}{    }\PYG{n}{strcpy}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HTTP/1.0 200 OK}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Content\PYGZhy{}Type: text/html}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Pragma: no\PYGZhy{}cache}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZlt{}html\PYGZgt{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZlt{}body\PYGZgt{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZlt{}title\PYGZgt{}STM32 Web Server\PYGZlt{}/title\PYGZgt{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZlt{}h2\PYGZgt{}InventekSys : Web Server using Es\PYGZhy{}Wifi with STM32\PYGZlt{}/h2\PYGZgt{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZlt{}br /\PYGZgt{}\PYGZlt{}hr\PYGZgt{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZlt{}p\PYGZgt{}\PYGZlt{}form method=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{POST}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{\PYGZgt{}\PYGZlt{}strong\PYGZgt{}Temp: \PYGZlt{}input type=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{text}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ value=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sprintf}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{temp}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{temperature}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{temp}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{\PYGZgt{} \PYGZlt{}sup\PYGZgt{}O\PYGZlt{}/sup\PYGZgt{}C}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{ledIsOn}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZlt{}p\PYGZgt{}\PYGZlt{}input type=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{radio}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ name=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{radio}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ value=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ \PYGZgt{}LED off}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZlt{}br\PYGZgt{}\PYGZlt{}input type=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{radio}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ name=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{radio}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ value=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ checked\PYGZgt{}LED on}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{else}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZlt{}p\PYGZgt{}\PYGZlt{}input type=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{radio}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ name=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{radio}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ value=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{0}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ checked\PYGZgt{}LED off}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZlt{}br\PYGZgt{}\PYGZlt{}input type=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{radio}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ name=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{radio}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ value=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ \PYGZgt{}LED on}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZlt{}/strong\PYGZgt{}\PYGZlt{}p\PYGZgt{}\PYGZlt{}input type=}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{submit}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{\PYGZgt{}\PYGZlt{}/form\PYGZgt{}\PYGZlt{}/span\PYGZgt{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{strcat}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZlt{}/body\PYGZgt{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZlt{}/html\PYGZgt{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{ret}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}SendData}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{SentDataLength}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}WRITE\PYGZus{}TIMEOUT}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ret}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}OK}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{SentDataLength}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{n}{http}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ret}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}STATUS\PYGZus{}ERROR}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{ret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if defined (TERMINAL\PYGZus{}USE)}
\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  Retargets the C library printf function to the USART.}
\PYG{c+cm}{  * @param  None}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{n}{PUTCHAR\PYGZus{}PROTOTYPE}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+cm}{/* Place your implementation of fputc here */}
\PYG{+w}{    }\PYG{c+cm}{/* e.g. write a character to the USART1 and Loop until the end of transmission */}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Transmit}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{hDiscoUart}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{ch}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0xFFFF}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{ch}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* TERMINAL\PYGZus{}USE */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef USE\PYGZus{}FULL\PYGZus{}ASSERT}

\PYG{c+cm}{/**}
\PYG{c+cm}{   * @brief Reports the name of the source file and the source line number}
\PYG{c+cm}{   * where the assert\PYGZus{}param error has occurred.}
\PYG{c+cm}{   * @param file: pointer to the source file name}
\PYG{c+cm}{   * @param line: assert\PYGZus{}param error line source number}
\PYG{c+cm}{   * @retval None}
\PYG{c+cm}{   */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{assert\PYGZus{}failed}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{file}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{line}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE BEGIN 6 */}
\PYG{+w}{  }\PYG{c+cm}{/* User can add his own implementation to report the file name and line number,}
\PYG{c+cm}{    ex: printf(\PYGZdq{}Wrong parameters value: file \PYGZpc{}s on line \PYGZpc{}d\PYGZbs{}r\PYGZbs{}n\PYGZdq{}, file, line) */}
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE END 6 */}

\PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  EXTI line detection callback.}
\PYG{c+cm}{  * @param  GPIO\PYGZus{}Pin: Specifies the port pin connected to corresponding EXTI line.}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}GPIO\PYGZus{}EXTI\PYGZus{}Callback}\PYG{p}{(}\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{GPIO\PYGZus{}Pin}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{switch}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{GPIO\PYGZus{}Pin}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{case}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{GPIO\PYGZus{}PIN\PYGZus{}1}\PYG{p}{)}\PYG{o}{:}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{SPI\PYGZus{}WIFI\PYGZus{}ISR}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{default}\PYG{o}{:}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/**}
\PYG{c+cm}{  * @brief  SPI3 line detection callback.}
\PYG{c+cm}{  * @param  None}
\PYG{c+cm}{  * @retval None}
\PYG{c+cm}{  */}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{SPI3\PYGZus{}IRQHandler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}SPI\PYGZus{}IRQHandler}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{hspi}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/* USER CODE END 4 */}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
编译下载代码后，等待开发板连接上 wifi，然后在手机或 PC 端打开浏览器输入开发板的 IP 地址

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
网页上显示温度传感器的值，并且可控制开发板上 LED 的亮灭，实现了数据的收发

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220808100952710}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
在浏览器顶部输入 view\sphinxhyphen{}source:http://192.168.137.182/，可查看页面源代码

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220808101322105}.png}

\sphinxAtStartPar
可以看到，跟开发板中的代码是相对应的

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220808101518206}.png}

\sphinxstepscope


\section{MQTT}
\label{\detokenize{exp-stm32/mqtt:mqtt}}\label{\detokenize{exp-stm32/mqtt::doc}}
\sphinxAtStartPar
MQTT 是一种基于发布/订阅（Publish/Subscribe）模式的轻量级通讯协议，该协议构建于TCP/IP协议上。一些 WiFi 模块已经集成了 TCP 协议栈，所以只需要通过发送 AT 指令即可建立 TCP 连接。建立 TCP 连接后，发送数据包需要配合 MQTT 协议做一些处理，再通过 AT 指令让数据包通过 TCP 协议发送，即可实现 MQTT 通信，接收数据同理。除此之外，一些模块内部也直接支持MQTT AT指令，相比于只支持TCP AT的模块，可以免去写一些配合MQTT协议的代码这个步骤。开发板上的WiFi模块默认的固件版本支持通过AT指令配置TCP，UDP，UDP Lite，TCP\sphinxhyphen{}SSL，MQTT，详细的AT指令官方文档：\sphinxhref{https://www.inventeksys.com/iwin/documentation/}{:link:ISM43362}

\sphinxAtStartPar
现在大部分的WiFi模块都支持MQTT AT指令（一些模块的默认固件可能不支持，需要去模块的官网下载相应固件烧录），本章节讲述如何通过MQTT AT指令来进行MQTT通信。


\subsection{实验目的}
\label{\detokenize{exp-stm32/mqtt:id1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
了解 MQTT 协议，感兴趣的同学可进一步了解如何实现 MQTT 协议

\item {} 
\sphinxAtStartPar
实现 MQTT 的 publish 和 subscribe 模式

\end{itemize}


\subsection{准备工作}
\label{\detokenize{exp-stm32/mqtt:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
已经搭建好的 MQTT 服务器（也可以使用mqtt或者emqx提供的公共服务器进行测试）

\item {} 
\sphinxAtStartPar
提前了解该wifi模块的AT指令（主要看与mqtt和wifi基本配置相关的AT指令）

\end{itemize}


\subsubsection{硬件}
\label{\detokenize{exp-stm32/mqtt:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
物联网实验箱

\item {} 
\sphinxAtStartPar
USB 数据线

\end{itemize}


\subsubsection{软件}
\label{\detokenize{exp-stm32/mqtt:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
CLion

\item {} 
\sphinxAtStartPar
STM32CubeMX

\end{itemize}


\subsection{相关电路原理}
\label{\detokenize{exp-stm32/mqtt:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
STM32 与 WiFi 模块的硬件连接

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220809173504803}.png}


\subsection{引脚定义与相关API}
\label{\detokenize{exp-stm32/mqtt:api}}\begin{itemize}
\item {} 
\sphinxAtStartPar
引脚定义
跟wifi的tcp，http章节是一样的。

\item {} 
\sphinxAtStartPar
相关API

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// wifi模块初始化，主要做的事情就是通过AT指令配置wifi模块}
\PYG{n}{WIFI\PYGZus{}StatusTypeDef}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}Init}\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}HandleTypeDef}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{hwifi}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// wifi模块连接wifi，同样是通过AT指令配置的}
\PYG{n}{WIFI\PYGZus{}StatusTypeDef}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}JoinNetwork}\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}HandleTypeDef}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{hwifi}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 初始化wifi模块，使用MQTT协议，主要是配置发布/订阅主题等信息}
\PYG{n}{WIFI\PYGZus{}StatusTypeDef}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}MQTTClientInit}\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}HandleTypeDef}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{hwifi}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// stm32节点作为订阅者，接受发布者发送过来的数据}
\PYG{n}{WIFI\PYGZus{}StatusTypeDef}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}MQTTReceive}\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}HandleTypeDef}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{hwifi}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{message}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// stm32节点作为发布者，向订阅者发送数据}
\PYG{n}{WIFI\PYGZus{}StatusTypeDef}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}MQTTPublish}\PYG{p}{(}\PYG{n}{WIFI\PYGZus{}HandleTypeDef}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{hwifi}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{message}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{sizeMessage}\PYG{p}{)}
\end{sphinxVerbatim}

\end{itemize}


\subsection{实验步骤}
\label{\detokenize{exp-stm32/mqtt:id6}}

\subsubsection{STM32CubeMX创建工程}
\label{\detokenize{exp-stm32/mqtt:stm32cubemx}}
\sphinxAtStartPar
在前面的章节，我们都是用Star My project from ST Board来生成工程的，但在平时使用的时候，我们一般不用ST的开发板（太贵啦）或者使用自己绘制的开发板，这就需要我们根据自己的硬件来生成工程，本章节就演示如何用零开始新建一个工程。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20230305160002076}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
选择Star My project from MCU，以特定的芯片来生成工程
\sphinxincludegraphics{{image-20230305160345242}.png}

\item {} 
\sphinxAtStartPar
我们的开发板使用的芯片是STM32L475VGT6，搜索该芯片，选择并Start Project
\sphinxincludegraphics{{image-20230305160754464}.png}

\item {} 
\sphinxAtStartPar
选择Debug方式为Serial Wire
\sphinxincludegraphics{{image-20230305160958858}.png}

\item {} 
\sphinxAtStartPar
修改时钟配置，如图，由于开发板上的外部晶振是8MHz的，因此Input frequency选择为8MHz，该芯片的最大运行频率为80MHz，设置为最大频率。
\sphinxincludegraphics{{image-20230305161533414}.png}

\item {} 
\sphinxAtStartPar
配置SPI3接口，如图，由于开发板上的wifi模块与stm32芯片的spi3引脚相连接，因此使用spi3接口。
\sphinxincludegraphics{{image-20230305161746727}.png}

\item {} 
\sphinxAtStartPar
配置USART1串口，用于调试，异步模式，其余配置保持默认即可。
\sphinxincludegraphics{{image-20230305161937232}.png}
由于开发板上的USB调试口用的是PB6和PB7，在这里需要设置为相应的引脚。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20230305162455654}.png}

\item {} 
\sphinxAtStartPar
配置wifi的EXTI、CS、RST引脚（鼠标左键设置）。
\sphinxincludegraphics{{image-20230305162821327}.png}
\sphinxincludegraphics{{image-20230305162849403}.png}
\sphinxincludegraphics{{image-20230305163435969}.png}

\sphinxAtStartPar
同时，为了方便辨识，为引脚设置特定的标识WIFI\_CMD\_DATA\_READY和WIFI\_NSS（鼠标右键设置）。
\sphinxincludegraphics{{image-20230305163112561}.png}

\sphinxAtStartPar
最后是这样子的，红色箭头上使能EXTI，也就是wifi模块需要用的EXTI。
\sphinxincludegraphics{{image-20230305163633469}.png}

\item {} 
\sphinxAtStartPar
最后在Project Manager中的配置上跟之前的章节是一样的，配置好生成工程即可。

\end{enumerate}


\subsubsection{代码编写及运行结果}
\label{\detokenize{exp-stm32/mqtt:id7}}\begin{itemize}
\item {} 
\sphinxAtStartPar
新建wifi.c和wifi.h文件，这里会提示无法洞察。。。，需要重置缓存并重新加载项目
这两个文件主要是wifi模块和mqtt的相关代码
\sphinxincludegraphics{{image-20230305165139060}.png}

\item {} 
\sphinxAtStartPar
新建helper\_functions.c和helper\_functions.h文件
这两个文件可有可无，串口调试的功能

\item {} 
\sphinxAtStartPar
修改main.c中wifi信息和mqtt主题，id，ip地址

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 以下根据实际修改}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{ssid}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{luobo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{// wifi名称}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{passphrase}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{88888888}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// wifi密码}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{subscribe\PYGZus{}topic}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{topic\PYGZus{}s}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// mqtt订阅主题}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{publish\PYGZus{}topic}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{topic\PYGZus{}p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{// mqtt发布主题}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{clientId}\PYG{p}{[}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{STM32}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}\PYG{+w}{  }\PYG{c+c1}{// 客户端ID}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sprintf}\PYG{p}{(}\PYG{n}{hwifi}\PYG{p}{.}\PYG{n}{remoteIpAddress}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test.mosquitto.org}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{// mqtt服务器ip地址，根据实际修改}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
编译下载代码后，等待开发板连接上wifi，就可以通过订阅/发布主题来互相通信。

\end{itemize}
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
这里使用MQTT X进行测试，首先需要安装MQTT X。

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo snap install mqttx
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
这里先使用由 EMQ X Cloud 提供的公共 MQTT 服务进行快速测试：

\sphinxAtStartPar
Broker 地址: broker.emqx.io
Broker TCP 端口: 1883
Broker SSL 端口: 8883

\item {} 
\sphinxAtStartPar
新建连接

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20230221164932515}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
按照图中说明修改发布/订阅主题，即可通过客户端看到stm32发送过来的数据，stm32串口打印出客户端发送给stm32的数据。

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20230221221941266}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20230221222145978}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
因为一般是以json格式发送或者接收，因此需要解析，比如发布者发送开灯命令“ON”，订阅者会接收到：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n+nt}{\PYGZdq{}msg\PYGZdq{}}\PYG{p}{:}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}ON\PYGZdq{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
然后就需要解析json格式，从中提取“ON”字符，用于控制LED灯的亮灭。有关json格式及其解析，使用C语言的有一个比较轻量的开源库名为cjson，详情请自行了解。

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20230221222241120}.png}
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
可以看到，通过支持MQTT AT的wifi模块使用MQTT是非常容易的。如果以后工作了，公司为了降低成本，用一些比较便宜的、不支持MQTT AT的wifi模块，就需要在TCP的基础上，按照MQTT的协议作一些包装，这就需要熟悉MQTT的报文格式了，详情请参考链接\sphinxhref{https://mcxiaoke.gitbooks.io/mqtt-cn/content/}{:link:MQTT协议中文版}。又或者为了更进一步降低成本，公司直接使用wifi芯片，这就需要根据wifi芯片的数据手册来进行配置而不是通过AT指令，这种就可能需要自己实现TCP协议栈，更为复杂一些，但这样可以直接省下一个mcu及其外围电路。

\end{itemize}

\sphinxstepscope

\sphinxstepscope


\chapter{ESP32实验篇}
\label{\detokenize{exp-esp32/index:esp32}}\label{\detokenize{exp-esp32/index::doc}}
\sphinxAtStartPar
本章实验包含如下几个部分，本章附有源代码，请 \sphinxhref{code.zip}{下载代码} 以便学习参考。

\sphinxstepscope


\section{IDE集成开发环境搭建}
\label{\detokenize{exp-esp32/ide/index:ide}}\label{\detokenize{exp-esp32/ide/index::doc}}
\sphinxAtStartPar
本节包含如下实验内容：

\sphinxstepscope


\subsection{ESP\sphinxhyphen{}IDF 环境配置}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:esp-idf}}\label{\detokenize{exp-esp32/ide/esp-idf-setup::doc}}

\subsubsection{实验目的}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id1}}
\sphinxAtStartPar
ESP\sphinxhyphen{}IDF 是乐鑫官方的物联网开发框架，适用于 ESP32、ESP32\sphinxhyphen{}S 和 ESP32\sphinxhyphen{}C 系列 SoC。它基于 C/C++ 语言提供了一个自给自足的 SDK，方便用户在这些平台上开发通用应用程序。

\sphinxAtStartPar
相较于 Arduino 等使用 microPython 的平台，ESP\sphinxhyphen{}IDF 能最大程度的发挥 ESP32 的全部实力，并且 ESP\sphinxhyphen{}IDF 是乐鑫官方推荐的 SDK，同时也是我们电子信息工程的学生应该掌握的开发工具之一。

\sphinxAtStartPar
本实验目的是搭建 ESP\sphinxhyphen{}IDF 的开发环境。
\begin{quote}

\sphinxAtStartPar
❗ 注意

\sphinxAtStartPar
本实验适用于同学们在自己的电脑上从头开始搭建环境，对于实验室电脑，实验环境已经搭建完毕，同学们只需阅读本节内容，了解 ESP\sphinxhyphen{}IDF 框架的基本内容即可。
\end{quote}


\subsubsection{ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 开发板简介}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:esp-wrover-kit}}

\paragraph{概述}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id2}}
\sphinxAtStartPar
ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 是 乐鑫 一款基于 ESP32 的开发板。开发板已集成了如下组件：
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP32\sphinxhyphen{}WROVER\sphinxhyphen{}E 模组

\item {} 
\sphinxAtStartPar
LCD 屏

\item {} 
\sphinxAtStartPar
MicroSD 卡槽

\end{itemize}

\sphinxAtStartPar
此外，ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 的独特之处在于集成了一款先进多协议 USB 桥接器 (FTDI FT2232HL)，允许开发人员直接通过 USB 接口，使用 JTAG 对 ESP32 进行调试，无需额外的 JTAG 调试器。ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 可为开发人员提供简单、便捷且极具成本效益的开发体验。

\sphinxAtStartPar
为了便于使用，板上模组的绝大部分管脚均已引出至开发板的引脚。
\begin{quote}

\sphinxAtStartPar
❗ 注意

\sphinxAtStartPar
ESP32 的 GPIO16 和 GPIO17 管脚用作 PSRAM 的片选和时钟信号。默认情况下，为了给用户提供可靠的性能，这两个 GPIO 管脚不引出至开发板引脚。
\end{quote}


\paragraph{电路框图}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id3}}
\sphinxAtStartPar
ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 开发板的主要组件和连接方式如下图所示。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728170303464}.png}


\paragraph{管脚分配}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id4}}
\sphinxAtStartPar
ESP32 模组的部分管脚/终端已被板上组件占用或用于外部硬件设备。如果某管脚对应的特定硬件未连接，则该管脚可用作他用。比如，摄像头/JP4 排针未连接相应硬件，则这些 GPIO 可用于其他用途。

\sphinxAtStartPar
部分管脚具备多个功能，可供板上组件或外部硬件设备同时使用，比如 GPIO0 和 GPIO2。由于管脚限制，一些外围设备不可同时使用，比如，由于 JTAG 和 SD 卡槽需共用部分管脚，因此一些使用 SD 卡功能的应用无法同时进行 JTAG 调试。

\sphinxAtStartPar
其他情况下，不同外设可同时使用。比如，LCD 屏幕和 SD 卡仅共用一个 GPIO21 管脚，可以同时使用。该管脚可为 LCD 屏幕提供 D/C（数据/控制）信号，并用于读取来自 SD 卡槽的卡检测信号。如无需使用卡检测功能，开发人员还可以通过移除 R167 来禁用该功能。此时，LCD 和 SD 卡槽可同时使用。


\subparagraph{管脚复用情况}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id5}}
\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728171255675}.png}

\sphinxAtStartPar
说明：
\begin{itemize}
\item {} 
\sphinxAtStartPar
NC/XTAL \sphinxhyphen{} 32.768 kHz 晶振

\item {} 
\sphinxAtStartPar
JTAG \sphinxhyphen{} JTAG / JP2

\item {} 
\sphinxAtStartPar
Boot \sphinxhyphen{} Boot 按键 / SW2

\item {} 
\sphinxAtStartPar
摄像头 \sphinxhyphen{} 摄像头 / JP4

\item {} 
\sphinxAtStartPar
LED \sphinxhyphen{} RGB LED

\item {} 
\sphinxAtStartPar
MicroSD \sphinxhyphen{} MicroSD Card / J4

\item {} 
\sphinxAtStartPar
LCD \sphinxhyphen{} LCD / U5

\item {} 
\sphinxAtStartPar
PSRAM \sphinxhyphen{} ESP32\sphinxhyphen{}WROVER\sphinxhyphen{}E 的 PSRAM

\end{itemize}


\subparagraph{32.768 kHz 晶振}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:khz}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
ESP32 管脚
\\
\hline
\sphinxAtStartPar
GPIO32
\\
\hline
\sphinxAtStartPar
GPIO33
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
默认情况下，管脚 GPIO32 和 GPIO33 已连接至晶振。因此，为了保证信号的完整性，这两个管脚并未连接至 JP1 I/O 连接器。用户可通过将 R11/R23 处的 0 欧电阻移至 R12/R24 处，以将 GP1O32 和 GPIO33 的连接从晶振移至 JP1。


\subparagraph{SPI Flash / JP2}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:spi-flash-jp2}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
ESP32 管脚
\\
\hline
\sphinxAtStartPar
CLK / GPIO6
\\
\hline
\sphinxAtStartPar
SD0 / GPIO7
\\
\hline
\sphinxAtStartPar
SD1 / GPIO8
\\
\hline
\sphinxAtStartPar
SD2 / GPIO9
\\
\hline
\sphinxAtStartPar
SD3 / GPIO10
\\
\hline
\sphinxAtStartPar
CMD / GPIO11
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Important

\sphinxAtStartPar
模组的 flash 总线已通过 0 欧电阻 R140 \textasciitilde{} R145 连接至排针 JP2。如果需要将 flash 的工作频率控制在 80 MHz，以达到保证总线信号完整性等目的，建议移除 R140 \textasciitilde{} R145 电阻，将模组的 flash 总线与排针 JP2 断开。


\subparagraph{JTAG / JP2}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:jtag-jp2}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
ESP32 管脚
&\sphinxstyletheadfamily 
\sphinxAtStartPar
JTAG 信号
\\
\hline
\sphinxAtStartPar
EN
&
\sphinxAtStartPar
TRST\_N
\\
\hline
\sphinxAtStartPar
MTMS / GPIO14
&
\sphinxAtStartPar
TMS
\\
\hline
\sphinxAtStartPar
MTDO / GPIO15
&
\sphinxAtStartPar
TDO
\\
\hline
\sphinxAtStartPar
MTDI / GPIO12
&
\sphinxAtStartPar
TDI
\\
\hline
\sphinxAtStartPar
MTCK / GPIO13
&
\sphinxAtStartPar
TCK
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subparagraph{摄像头 / JP4}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:jp4}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
ESP32 管脚
&\sphinxstyletheadfamily 
\sphinxAtStartPar
摄像头信号
\\
\hline
\sphinxAtStartPar
n/a
&
\sphinxAtStartPar
3.3V
\\
\hline
\sphinxAtStartPar
n/a
&
\sphinxAtStartPar
地
\\
\hline
\sphinxAtStartPar
GPIO27
&
\sphinxAtStartPar
SIO\_C / SCCB 时钟
\\
\hline
\sphinxAtStartPar
GPIO26
&
\sphinxAtStartPar
SIO\_D / SCCB 数据
\\
\hline
\sphinxAtStartPar
GPIO25
&
\sphinxAtStartPar
VSYNC / 垂直同步
\\
\hline
\sphinxAtStartPar
GPIO23
&
\sphinxAtStartPar
HREF / 水平参考
\\
\hline
\sphinxAtStartPar
GPIO22
&
\sphinxAtStartPar
PCLK / 像素时钟
\\
\hline
\sphinxAtStartPar
GPIO21
&
\sphinxAtStartPar
XCLK / 系统时钟
\\
\hline
\sphinxAtStartPar
GPIO35
&
\sphinxAtStartPar
D7 / 像素数据 Bit 7
\\
\hline
\sphinxAtStartPar
GPIO34
&
\sphinxAtStartPar
D6 / 像素数据 Bit 6
\\
\hline
\sphinxAtStartPar
GPIO39
&
\sphinxAtStartPar
D5 / 像素数据 Bit 5
\\
\hline
\sphinxAtStartPar
GPIO36
&
\sphinxAtStartPar
D4 / 像素数据 Bit 4
\\
\hline
\sphinxAtStartPar
GPIO19
&
\sphinxAtStartPar
D3 / 像素数据 Bit 3
\\
\hline
\sphinxAtStartPar
GPIO18
&
\sphinxAtStartPar
D2 / 像素数据 Bit 2
\\
\hline
\sphinxAtStartPar
GPIO5
&
\sphinxAtStartPar
D0 / 像素数据 Bit 1
\\
\hline
\sphinxAtStartPar
GPIO4
&
\sphinxAtStartPar
D0 / 像素数据 Bit 0
\\
\hline
\sphinxAtStartPar
GPIO0
&
\sphinxAtStartPar
RESET / 摄像头复位
\\
\hline
\sphinxAtStartPar
n/a
&
\sphinxAtStartPar
PWDN / 摄像头断电
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
D0 到 D7 为摄像头的数据总线


\subparagraph{RGB LED}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:rgb-led}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
ESP32 管脚
&\sphinxstyletheadfamily 
\sphinxAtStartPar
RGB LED
\\
\hline
\sphinxAtStartPar
GPIO0
&
\sphinxAtStartPar
红色
\\
\hline
\sphinxAtStartPar
GPIO2
&
\sphinxAtStartPar
绿色
\\
\hline
\sphinxAtStartPar
GPIO4
&
\sphinxAtStartPar
蓝色
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subparagraph{MicroSD 卡}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:microsd}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
ESP32 管脚
&\sphinxstyletheadfamily 
\sphinxAtStartPar
MicroSD 信号
\\
\hline
\sphinxAtStartPar
MTDI / GPIO12
&
\sphinxAtStartPar
DATA2
\\
\hline
\sphinxAtStartPar
MTCK / GPIO13
&
\sphinxAtStartPar
CD / DATA3
\\
\hline
\sphinxAtStartPar
MTDO / GPIO15
&
\sphinxAtStartPar
CMD
\\
\hline
\sphinxAtStartPar
MTMS / GPIO14
&
\sphinxAtStartPar
CLK
\\
\hline
\sphinxAtStartPar
GPIO2
&
\sphinxAtStartPar
DATA0
\\
\hline
\sphinxAtStartPar
GPIO4
&
\sphinxAtStartPar
DATA1
\\
\hline
\sphinxAtStartPar
GPIO21
&
\sphinxAtStartPar
Card Detect
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subparagraph{LCD / U5}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:lcd-u5}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
ESP32 管脚
&\sphinxstyletheadfamily 
\sphinxAtStartPar
LCD 信号
\\
\hline
\sphinxAtStartPar
GPIO18
&
\sphinxAtStartPar
复位
\\
\hline
\sphinxAtStartPar
GPIO19
&
\sphinxAtStartPar
SCL
\\
\hline
\sphinxAtStartPar
GPIO21
&
\sphinxAtStartPar
D/C
\\
\hline
\sphinxAtStartPar
GPIO22
&
\sphinxAtStartPar
CS
\\
\hline
\sphinxAtStartPar
GPIO23
&
\sphinxAtStartPar
SDA
\\
\hline
\sphinxAtStartPar
GPIO25
&
\sphinxAtStartPar
SDO
\\
\hline
\sphinxAtStartPar
GPIO5
&
\sphinxAtStartPar
背光
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subparagraph{原理图}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id6}}
\sphinxAtStartPar
\sphinxhref{https://dl.espressif.com/dl/schematics/ESP-WROVER-KIT\_V4\_1.pdf}{下载原理图}

\sphinxAtStartPar
\sphinxincludegraphics{{ylt}.png}


\subsubsection{实验准备}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id7}}

\paragraph{硬件}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id8}}\begin{itemize}
\item {} 
\sphinxAtStartPar
物联网实验验箱上的 ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 开发板

\item {} 
\sphinxAtStartPar
USB 数据线 (A 转 Micro\sphinxhyphen{}B)

\item {} 
\sphinxAtStartPar
电脑（PC 或 Mac OS）

\end{itemize}


\paragraph{软件}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id9}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Ubuntu20.04 Linux 操作系统

\item {} 
\sphinxAtStartPar
ESP\sphinxhyphen{}IDF 开发框架

\end{itemize}


\subsubsection{实验步骤}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id10}}\begin{quote}

\sphinxAtStartPar
❗ 注意如果使用的是我们提供的镜像文件，安装好 VM16PRO 后打开即可。全新安装配置，请按照以下步骤操作。
\end{quote}


\paragraph{第一步：安装准备}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id11}}
\sphinxAtStartPar
首先是更换国内源，此处不再赘述，可以自行网络学习，Ubuntu20.04 有图形界面进行选择更换，十分简单。

\sphinxAtStartPar
然后更新软件列表，检测出可以更新的软件并进行软件更新，具体终端输入如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt\PYGZhy{}get update
sudo apt\PYGZhy{}get upgrade
\end{sphinxVerbatim}

\sphinxAtStartPar
编译 ESP\sphinxhyphen{}IDF 需要以下软件依赖包。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt\PYGZhy{}get install git wget flex bison gperf python3 python3\PYGZhy{}pip python3\PYGZhy{}setuptools cmake ninja\PYGZhy{}build cca
\end{sphinxVerbatim}


\paragraph{第二步：获取 ESP\sphinxhyphen{}IDF}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id12}}
\sphinxAtStartPar
拉取 ESP\sphinxhyphen{}IDF 仓库。打开终端，运行以下命令：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir \PYGZhy{}p \PYGZti{}/esp
\PYG{n+nb}{cd} \PYGZti{}/esp
git clone \PYGZhy{}b v4.4.1 \PYGZhy{}\PYGZhy{}recursive https://github.com/espressif/esp\PYGZhy{}idf.git
\end{sphinxVerbatim}

\sphinxAtStartPar
ESP\sphinxhyphen{}IDF 将下载至 \textasciitilde{}/esp/esp\sphinxhyphen{}idf。
\begin{quote}

\sphinxAtStartPar
❗\sphinxstylestrong{注意：}
\begin{itemize}
\item {} 
\sphinxAtStartPar
此处因 GitHub 在国内下载速度不稳定，想要在自己电脑构建环境的同学们，针对 git clone 的下载问题可以先前往网址下载 zip 再放入虚拟机后解压。

\item {} 
\sphinxAtStartPar
也可以用国内提供的 GITTE 解决。

\end{itemize}
\end{quote}


\paragraph{第三步：设置工具}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id13}}
\sphinxAtStartPar
除了 ESP\sphinxhyphen{}IDF 框架本身，还需要安装 ESP\sphinxhyphen{}IDF 使用的各种工具，比如编译器、调试器、Python 包等。
\begin{itemize}
\item {} 
\sphinxAtStartPar
采用 GitHub，执行如下命令

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} \PYGZti{}/esp/esp\PYGZhy{}idf
./install.sh esp32
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
采用备用资源

\end{itemize}

\sphinxAtStartPar
在运行\sphinxcode{\sphinxupquote{install.sh}}时会下载 Github 发布版本中附带的一些工具，如果访问 Github 较为缓慢，则可以设置一个环境变量，实现优先选择 Espressif 提供的下载服务器进行 Github 资源下载。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} \PYGZti{}/esp/esp\PYGZhy{}idf
\PYG{n+nb}{export} \PYG{n+nv}{IDF\PYGZus{}GITHUB\PYGZus{}ASSETS}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}dl.espressif.com/github\PYGZus{}assets\PYGZdq{}}
./install.sh
\end{sphinxVerbatim}


\paragraph{第四步：设置环境变量}
\label{\detokenize{exp-esp32/ide/esp-idf-setup:id14}}
\sphinxAtStartPar
此时，您刚刚安装的工具尚未添加至 PATH 环境变量，无法通过“命令窗口”使用这些工具。因此，必须设置一些环境变量，这可以通过 ESP\sphinxhyphen{}IDF 提供的另一个脚本完成。

\sphinxAtStartPar
为了正常使用 ESP\sphinxhyphen{}IDF 提供的工具，必须将这些工具所在的目录添加到系统环境变量，可通过终端键入如下命令实现。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
. \PYG{n+nv}{\PYGZdl{}HOME}/esp/esp\PYGZhy{}idf/export.sh
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
❗\sphinxstylestrong{注意：}，命令开始的 “.” 与路径之间应有一个空格！
\end{quote}

\sphinxAtStartPar
如果您需要经常运行 ESP\sphinxhyphen{}IDF，可以上述脚本命令创建一个别名，具体步骤如下：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
复制并粘贴以下命令到 shell 配置文件中（.profile， .bashrc， .zprofile 等）

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{alias} get\PYGZhy{}idf\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}. \PYGZdl{}HOME/esp/esp\PYGZhy{}idf/export.sh\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
注意：这些文件在主目录下，并且需要开启查看隐藏文件

\sphinxAtStartPar
\sphinxincludegraphics{{1}.png}

\item {} 
\sphinxAtStartPar
通过重启终端窗口或运行 source {[}path to profile{]}，如 source \textasciitilde{}/.bashrc 来刷新配置文件。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{source} \PYGZti{}/.bashrc
\end{sphinxVerbatim}

\end{enumerate}

\sphinxAtStartPar
现在您可以在任何终端窗口中运行 get\sphinxhyphen{}idf 来设置或刷新 esp\sphinxhyphen{}idf 环境。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
get\PYGZhy{}idf

Detecting the Python interpreter
Checking \PYG{l+s+s2}{\PYGZdq{}python3\PYGZdq{}} ...
Python \PYG{l+m}{3}.9.13
\PYG{l+s+s2}{\PYGZdq{}python3\PYGZdq{}} has been detected
Checking Python compatibility
Checking other ESP\PYGZhy{}IDF version.
.....
Done! You can now compile ESP\PYGZhy{}IDF projects.
Go to the project directory and run:
idf.py build
\end{sphinxVerbatim}

\sphinxAtStartPar
这里不建议直接将 export.sh 添加到 shell 的配置文件。因为这会导致在每个终端会话中都激活 IDF 虚拟环境（包括无需使用 IDF 的情况），从而破坏使用虚拟环境的目的，并可能影响其他软件的使用。

\sphinxstepscope


\subsection{使用命令行创建项目的完整流程}
\label{\detokenize{exp-esp32/ide/esp-idf-cli:id1}}\label{\detokenize{exp-esp32/ide/esp-idf-cli::doc}}

\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{实验规约}}}
\label{\detokenize{exp-esp32/ide/esp-idf-cli:id2}}
\sphinxAtStartPar
由于实验机房中是多人共享实验机器，因此，为了避免不同小组之间的文件 冲突，必须要求，每组甚至每人都应该有自己单独的目录，大家实验的时候在自己的目录上 code 和 debug，尽量不要影响其他组的文件。


\paragraph{代码目录}
\label{\detokenize{exp-esp32/ide/esp-idf-cli:id3}}
\sphinxAtStartPar
对于每一个组，建议创建如下格式目录作为自己组的目录

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{GROUPNMAE}\PYG{o}{=} \PYG{l+m}{1}.11 \PYG{c+c1}{\PYGZsh{} 例如代表1班第11组}
mkdir \PYGZti{}/code/\PYG{n+nv}{\PYGZdl{}GROUPNAME}/esp32/
\end{sphinxVerbatim}


\paragraph{代码源}
\label{\detokenize{exp-esp32/ide/esp-idf-cli:id4}}
\sphinxAtStartPar
对于源代码，一个非常错误的方法是从\sphinxcode{\sphinxupquote{esp/esp\sphinxhyphen{}idf/sample}}里面去拷贝，因为很多同学直接在这里操作文件，而往往这里的文件已经不干净了。我们要求从指定的地址下载干净的源代码。

\sphinxAtStartPar
正确的带有注释的代码在 {\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码处下载}}}}

\sphinxAtStartPar
接下来，就可以开始从命令行开始创建并调试项目了。


\subsubsection{第一步：创建项目}
\label{\detokenize{exp-esp32/ide/esp-idf-cli:id5}}
\sphinxAtStartPar
现在，您可以开始准备开发 ESP32 应用程序了。假设我要重头开始创建 hellow\sphinxhyphen{}world 工程

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 进入项目目录}
\PYG{n+nb}{cd} \PYGZti{}/code/\PYG{n+nv}{\PYGZdl{}GROUPNAME}/esp32/

\PYG{c+c1}{\PYGZsh{} 获取idf所需的环境和工具}
get\PYGZhy{}idf
\PYG{c+c1}{\PYGZsh{} 创建hellow\PYGZhy{}world工程}
idf.py create\PYGZhy{}project hellow\PYGZhy{}world
\PYG{c+c1}{\PYGZsh{} 检查下目录下发生了什么}
tree \PYGZhy{}L \PYG{l+m}{2}
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
❗\sphinxstylestrong{注意：}
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP\sphinxhyphen{}IDF 编译系统不支持带有空格的路径！！！

\end{itemize}
\end{quote}


\subsubsection{第二步：连接设备}
\label{\detokenize{exp-esp32/ide/esp-idf-cli:id6}}
\sphinxAtStartPar
现在，请将 ESP32 开发板连接到 PC，并查看开发板使用的串口。

\sphinxAtStartPar
我们使用的\sphinxcode{\sphinxupquote{ ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT}} 开发板一般会有如下两个 \sphinxcode{\sphinxupquote{ttyUSB}} 口：

\sphinxAtStartPar
数字较小的为\sphinxcode{\sphinxupquote{ JATG}} 接口，较大的为串口接口。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ls \PYGZhy{}l /dev/ttyUSB*
crw\PYGZhy{}rw\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+ \PYG{l+m}{1} root plugdev \PYG{l+m}{188}, \PYG{l+m}{0} 7月  \PYG{l+m}{27} \PYG{l+m}{14}:31 /dev/ttyUSB0
crw\PYGZhy{}rw\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+ \PYG{l+m}{1} root plugdev \PYG{l+m}{188}, \PYG{l+m}{1} 7月  \PYG{l+m}{27} \PYG{l+m}{14}:31 /dev/ttyUSB1
\end{sphinxVerbatim}

\sphinxAtStartPar
此处的用户群组 \sphinxcode{\sphinxupquote{plugdev }}可能会有出入，具体原因是对\sphinxcode{\sphinxupquote{JAGT}}进行了 \sphinxcode{\sphinxupquote{USB }}驱动配置，会在下一章 \sphinxcode{\sphinxupquote{ESP\sphinxhyphen{}IDF JTAG }}调试流程 中提及。

\sphinxAtStartPar
请记住串口名，在下面的步骤中会使用到。


\subsubsection{第三步：设置目标芯片}
\label{\detokenize{exp-esp32/ide/esp-idf-cli:id7}}
\sphinxAtStartPar
打开一个新项目后，应首先设置“目标”芯片 。乐鑫有 esp32, esp32\sphinxhyphen{}s2, esp32\sphinxhyphen{}s3,esp32\sphinxhyphen{}c 以及 esp32\sphinxhyphen{}h 等多种架构

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 我们的开发版目标芯片是ESP32}
idf.py set\PYGZhy{}target esp32
\PYG{c+c1}{\PYGZsh{} 检查下目录下发生了什么}
tree \PYGZhy{}L \PYG{l+m}{2}
\end{sphinxVerbatim}


\subsubsection{第四步：配置参数}
\label{\detokenize{exp-esp32/ide/esp-idf-cli:id8}}
\sphinxAtStartPar
运行工程配置工具 menuconfig。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
idf.py menuconfig
\end{sphinxVerbatim}

\sphinxAtStartPar
注意，此操作将清除并初始化项目之前的编译和配置（如有）。 也可以直接将“目标”配置为环境变量（此时可跳过该步骤）。

\sphinxAtStartPar
如果之前的步骤都正确，则会显示下面的菜单：

\sphinxAtStartPar
\sphinxincludegraphics{{2}.png}

\sphinxAtStartPar
您可以通过此菜单设置项目的具体变量，包括 Wi\sphinxhyphen{}Fi 网络名称、密码和处理器速度等. \sphinxcode{\sphinxupquote{hello\_world}} 示例项目会以默认配置运行，因此可以跳过使用 \sphinxcode{\sphinxupquote{menuconfig}} 进行项目配置这一步骤。

\sphinxAtStartPar
关于\sphinxcode{\sphinxupquote{menuconfig}}, 以后还会有更多介绍。


\subsubsection{第五步：编写代码}
\label{\detokenize{exp-esp32/ide/esp-idf-cli:id9}}
\sphinxAtStartPar
在 main 目录下编写代码，程序入口点为\sphinxcode{\sphinxupquote{void app\_main(void)}}

\sphinxAtStartPar
也可以从实验源代码处{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{下载}}}}。


\subsubsection{第六步：编译}
\label{\detokenize{exp-esp32/ide/esp-idf-cli:id10}}
\sphinxAtStartPar
请使用以下命令，编译烧录工程：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
idf.py build
\end{sphinxVerbatim}

\sphinxAtStartPar
运行以上命令可以编译应用程序和所有 ESP\sphinxhyphen{}IDF 组件，接着生成 bootloader、分区表和应用程序二进制文件。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} idf.py build
Running cmake \PYG{k}{in} directory /path/to/hello\PYGZus{}world/build
Executing \PYG{l+s+s2}{\PYGZdq{}cmake \PYGZhy{}G Ninja \PYGZhy{}\PYGZhy{}warn\PYGZhy{}uninitialized /path/to/hello\PYGZus{}world\PYGZdq{}}...
Warn about uninitialized values.
\PYGZhy{}\PYGZhy{} Found Git:/usr/bin/git \PYG{o}{(}found version \PYG{l+s+s2}{\PYGZdq{}2.17.0\PYGZdq{}}\PYG{o}{)}
\PYGZhy{}\PYGZhy{} Building empty aws\PYGZus{}iot component due to configuration
\PYGZhy{}\PYGZhy{} Component names: ...
\PYGZhy{}\PYGZhy{} Component paths: ...

... \PYG{o}{(}more lines of build system output\PYG{o}{)}

\PYG{o}{[}\PYG{l+m}{527}/527\PYG{o}{]} Generating hello\PYGZus{}world.bin
esptool.py v2.3.1

Project build complete. To flash, run this command:
../../../components/esptool\PYGZus{}py/esptool/esptool.py \PYGZhy{}p \PYG{o}{(}PORT\PYG{o}{)} \PYGZhy{}b \PYG{l+m}{921600} write\PYGZus{}flash \PYGZhy{}\PYGZhy{}flash\PYGZus{}mode dio \PYGZhy{}\PYGZhy{}flash\PYGZus{}size detect \PYGZhy{}\PYGZhy{}flash\PYGZus{}freq 40m 0x10000 build/hello\PYGZus{}world.bin  build 0x1000 build/bootloader/bootloader.bin 0x8000 build/partition\PYGZus{}table/partition\PYGZhy{}table.bin
or run \PYG{l+s+s1}{\PYGZsq{}idf.py \PYGZhy{}p PORT flash\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
如果一切正常，编译完成后将生成 .bin 文件。


\subsubsection{第七步：烧录程序}
\label{\detokenize{exp-esp32/ide/esp-idf-cli:id11}}
\sphinxAtStartPar
请使用以下命令，将刚刚生成的二进制文件 (bootloader.bin, partition\sphinxhyphen{}table.bin 和 hello\_world.bin) 烧录至您的 ESP32 开发板：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
idf.py \PYGZhy{}p PORT flash
\end{sphinxVerbatim}

\sphinxAtStartPar
请将 \sphinxcode{\sphinxupquote{PORT}} 替换为 ESP32 开发板的串口名称，具体可见 第二步：连接设备。

\sphinxAtStartPar
还可以将 \sphinxcode{\sphinxupquote{BAUD}} 替换为你希望的烧录波特率。默认波特率为 460800。

\sphinxAtStartPar
当终端出现如下信息时，按下 Boot 按键直到烧录进度百分比开始变化

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{[} \PYG{l+m}{98}\PYGZpc{}\PYG{o}{]} Built target \PYGZus{}\PYGZus{}idf\PYGZus{}spiffs
\PYG{o}{[} \PYG{l+m}{99}\PYGZpc{}\PYG{o}{]} Built target \PYGZus{}\PYGZus{}idf\PYGZus{}fatfs
\PYG{o}{[} \PYG{l+m}{99}\PYGZpc{}\PYG{o}{]} Built target \PYGZus{}\PYGZus{}idf\PYGZus{}esp\PYGZus{}local\PYGZus{}ctrl
\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]} Built target \PYGZus{}\PYGZus{}idf\PYGZus{}wifi\PYGZus{}provisioning
\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]} Built target \PYGZus{}\PYGZus{}idf\PYGZus{}main
\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]} Built target \PYGZus{}\PYGZus{}ldgen\PYGZus{}output\PYGZus{}sections.ld
\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]} Built target blink.elf
\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]} Built target gen\PYGZus{}project\PYGZus{}binary
blink.bin binary size 0x2b9e0 bytes. Smallest app partition is 0x100000 bytes. 0xd4620 bytes \PYG{o}{(}\PYG{l+m}{83}\PYGZpc{}\PYG{o}{)} free.
\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]} Built target app\PYGZus{}check\PYGZus{}size
\PYG{o}{[}\PYG{l+m}{100}\PYGZpc{}\PYG{o}{]} Built target app
esptool.py esp32 \PYGZhy{}p /dev/ttyUSB2 \PYGZhy{}b \PYG{l+m}{460800} \PYGZhy{}\PYGZhy{}before\PYG{o}{=}default\PYGZus{}reset \PYGZhy{}\PYGZhy{}after\PYG{o}{=}hard\PYGZus{}reset write\PYGZus{}flash \PYGZhy{}\PYGZhy{}flash\PYGZus{}mode dio \PYGZhy{}\PYGZhy{}flash\PYGZus{}freq 40m \PYGZhy{}\PYGZhy{}flash\PYGZus{}size 2MB 0x1000 bootloader/bootloader.bin 0x10000 blink.bin 0x8000 partition\PYGZus{}table/partition\PYGZhy{}table.bin
esptool.py v3.3\PYGZhy{}dev
Serial port /dev/ttyUSB2
Connecting..............
\end{sphinxVerbatim}

\sphinxAtStartPar
按下后将会继续进行烧录，终端出现如下显示，烧录进度百分比开始变化即可松开

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Connecting..............
Chip is ESP32\PYGZhy{}D0WD \PYG{o}{(}revision \PYG{l+m}{1}\PYG{o}{)}
Features: WiFi, BT, Dual Core, 240MHz, VRef calibration \PYG{k}{in} efuse, BLK3 partially reserved, Coding Scheme \PYG{l+m}{3}/4
Crystal is 40MHz
MAC: \PYG{l+m}{30}:ae:a4:cc:3f:7c
Uploading stub...
Running stub...
Stub running...
Changing baud rate to \PYG{l+m}{460800}
Changed.
Configuring flash size...
Flash will be erased from 0x00001000 to 0x00007fff...
Flash will be erased from 0x00010000 to 0x0003bfff...
Flash will be erased from 0x00008000 to 0x00008fff...
Compressed \PYG{l+m}{25280} bytes to \PYG{l+m}{15813}...
Writing at 0x00001000... \PYG{o}{(}\PYG{l+m}{100} \PYGZpc{}\PYG{o}{)}
Wrote \PYG{l+m}{25280} bytes \PYG{o}{(}\PYG{l+m}{15813} compressed\PYG{o}{)} at 0x00001000 \PYG{k}{in} \PYG{l+m}{0}.8 seconds \PYG{o}{(}effective \PYG{l+m}{252}.9 kbit/s\PYG{o}{)}...
Hash of data verified.
Compressed \PYG{l+m}{178656} bytes to \PYG{l+m}{92861}...
Writing at 0x00010000... \PYG{o}{(}\PYG{l+m}{16} \PYGZpc{}\PYG{o}{)}
Writing at 0x0001bc70... \PYG{o}{(}\PYG{l+m}{33} \PYGZpc{}\PYG{o}{)}
Writing at 0x00021476... \PYG{o}{(}\PYG{l+m}{50} \PYGZpc{}\PYG{o}{)}
Writing at 0x0002713f... \PYG{o}{(}\PYG{l+m}{66} \PYGZpc{}\PYG{o}{)}
Writing at 0x0002f761... \PYG{o}{(}\PYG{l+m}{83} \PYGZpc{}\PYG{o}{)}
Writing at 0x00037913... \PYG{o}{(}\PYG{l+m}{100} \PYGZpc{}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
如果一切顺利，烧录完成后，开发板将会复位，应用程序 “hello\_world” 开始运行。

\sphinxAtStartPar
\sphinxstylestrong{烧录过程中可能遇到的问题}

\sphinxAtStartPar
如果在运行给定命令时出现如“连接失败”这样的错误，原因之一则可能是运行 \sphinxcode{\sphinxupquote{esptool.py }}出现错误。\sphinxcode{\sphinxupquote{esptool.py }}是构建系统调用的程序，用于重置芯片、与 ROM 引导加载器交互以及烧录固件的工具。解决该问题的一个简单的方法就是按照以下步骤进行手动复位。如果问题仍未解决，请参考 Troubleshooting 获取更多信息。

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{esptool.py }}通过使 USB 转串口转接器芯片（如 FTDI 或 CP210x）的 DTR 和 RTS 控制线生效来自动复位 ESP32（请参考 与 ESP32 创建串口连接 获取更多详细信息)。DTR 和 RTS 控制线又连接到 ESP32 的 \sphinxcode{\sphinxupquote{GPIO0 }}和 \sphinxcode{\sphinxupquote{CHIP\_PU (EN) }}管脚上，因此 DTR 和 RTS 的电压电平变化会使 ESP32 进入固件下载模式。相关示例可查看 ESP32 DevKitC 开发板的 原理图。

\sphinxAtStartPar
一般来说，使用官方的 esp\sphinxhyphen{}idf 开发板不会出现问题。但是，\sphinxcode{\sphinxupquote{esptool.py }}在以下情况下不能自动重置硬件。

\sphinxAtStartPar
您的硬件没有连接到 \sphinxcode{\sphinxupquote{GPIO0 }}和 \sphinxcode{\sphinxupquote{CIHP\_PU}} 的 DTR 和 RTS 控制线。

\sphinxAtStartPar
DTR 和 RTS 控制线的配置方式不同

\sphinxAtStartPar
根本没有这样的串行控制线路

\sphinxAtStartPar
根据您硬件的种类，也可以将您 ESP32 开发板手动设置成固件下载模式（复位）。

\sphinxAtStartPar
对于 Espressif 的开发板，您可以参考对应开发板的入门指南或用户指南。例如，可以通过按住 Boot 按钮 (GPIO0) 再按住 EN 按钮(CHIP\_PU) 来手动复位 esp\sphinxhyphen{}idf 开发板。

\sphinxAtStartPar
对于其他类型的硬件，可以尝试将 GPIO0 拉低。


\subsubsection{第八步：监视程序运行}
\label{\detokenize{exp-esp32/ide/esp-idf-cli:id12}}
\sphinxAtStartPar
你可以使用 \sphinxcode{\sphinxupquote{idf.py \sphinxhyphen{}p PORT monitor}} 命令，监视 “hello\_world” 工程的运行情况。注意，不要忘记将 \sphinxcode{\sphinxupquote{PORT}} 替换为你的串口名称。

\sphinxAtStartPar
运行该命令后，IDF 监视器 应用程序将启动：:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} idf.py \PYGZhy{}p /dev/ttyUSB0 monitor
Running idf\PYGZus{}monitor \PYG{k}{in} directory \PYG{o}{[}...\PYG{o}{]}/esp/hello\PYGZus{}world/build
Executing \PYG{l+s+s2}{\PYGZdq{}python [...]/esp\PYGZhy{}idf/tools/idf\PYGZus{}monitor.py \PYGZhy{}b 115200 [...]/esp/hello\PYGZus{}world/build/hello\PYGZus{}world.elf\PYGZdq{}}...
\PYGZhy{}\PYGZhy{}\PYGZhy{} idf\PYGZus{}monitor on /dev/ttyUSB0 \PYG{l+m}{115200} \PYGZhy{}\PYGZhy{}\PYGZhy{}
\PYGZhy{}\PYGZhy{}\PYGZhy{} Quit: Ctrl+\PYG{o}{]} \PYG{p}{|} Menu: Ctrl+T \PYG{p}{|} Help: Ctrl+T followed by Ctrl+H \PYGZhy{}\PYGZhy{}\PYGZhy{}
ets Jun  \PYG{l+m}{8} \PYG{l+m}{2016} \PYG{l+m}{00}:22:57

rst:0x1 \PYG{o}{(}POWERON\PYGZus{}RESET\PYG{o}{)},boot:0x13 \PYG{o}{(}SPI\PYGZus{}FAST\PYGZus{}FLASH\PYGZus{}BOOT\PYG{o}{)}
ets Jun  \PYG{l+m}{8} \PYG{l+m}{2016} \PYG{l+m}{00}:22:57
...
\end{sphinxVerbatim}

\sphinxAtStartPar
此时，你就可以在启动日志和诊断日志之后，看到打印的 “Hello world!” 了。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
...
Hello world!
Restarting \PYG{k}{in} \PYG{l+m}{10} seconds...
This is esp32 chip with \PYG{l+m}{2} CPU core\PYG{o}{(}s\PYG{o}{)}, WiFi/BT/BLE, silicon revision \PYG{l+m}{1}, 2MB external flash
Minimum free heap size: \PYG{l+m}{298968} bytes
Restarting \PYG{k}{in} \PYG{l+m}{9} seconds...
Restarting \PYG{k}{in} \PYG{l+m}{8} seconds...
Restarting \PYG{k}{in} \PYG{l+m}{7} seconds...
\end{sphinxVerbatim}

\sphinxAtStartPar
可使用快捷键 Ctrl+{]}，退出 IDF 监视器。

\sphinxAtStartPar
至此，你已经完成 ESP\sphinxhyphen{}IDF 命令行的基本流程。

\sphinxstepscope


\subsection{ESP\sphinxhyphen{}IDF JTAG 调试流程}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:esp-idf-jtag}}\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug::doc}}

\subsubsection{引言}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:id1}}
\sphinxAtStartPar
ESP32 具有两个强大的 Xtensa 内核，支持多种程序架构。ESP\sphinxhyphen{}IDF 自带的 FreeRTOS 操作系统支持多核抢占式调度，允许用户以更加直观的方式编写软件。

\sphinxAtStartPar
与此相对地，由于缺乏合适的工具，简便的编程方式也会给程序的调试带来困难，比如找出由两个线程引起的错误，并且这两个线程在单独的 CPU 核上同时运行，那么仅凭 printf 语句会花费很长时间来定位该错误。调试此类问题更好(往往也更快)的方法是使用调试器，将其连接到处理器的调试端口。

\sphinxAtStartPar
乐鑫已完成 OpenOCD 移植，以支持 ESP32 处理器和多核 FreeRTOS 架构（此作为大多数 ESP32 应用程序的基础）。此外，乐鑫还提供了一些 OpenOCD 本身并不支持的工具，以进一步丰富调试功能。


\subsubsection{工作原理}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:id2}}
\sphinxAtStartPar
通过 JTAG（Joint Test Action Group）接口使用 OpenOCD 调试 ESP32 时所需要的关键软件和硬件:
\begin{itemize}
\item {} 
\sphinxAtStartPar
包括 xtensa\sphinxhyphen{}esp32\sphinxhyphen{}elf\sphinxhyphen{}gdb 调试器

\item {} 
\sphinxAtStartPar
OpenOCD 片上调试器

\item {} 
\sphinxAtStartPar
连接到 ESP32 目标的 JTAG 适配器，

\end{itemize}

\sphinxAtStartPar
如下图 “Application Loading and Monitoring” 标志所示。

\sphinxAtStartPar
\sphinxincludegraphics{{3}.png}
JTAG 调试 \sphinxhyphen{} 概述图

\sphinxAtStartPar
“Application Loading and Monitoring” 标志显示一组关键的软件和硬件组件，可用于编译、构建和烧写应用程序到 ESP32 上，以及监视来自 ESP32 的运行诊断信息。

\sphinxAtStartPar
我们使用的 ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 开发板，由于其板载 FT232H 芯片，仅需一根 USB 线即可连接 PC 与 ESP32。FT232H 提供了两路 USB 通道，一路连接到 JTAG，另一路连接到 UART。

\sphinxAtStartPar
根据喜好，除了使用 Eclipse 集成开发环境，还可以直接在命令行终端运行 debugger 和 idf.py build。


\subsubsection{选择 JTAG 适配器}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:jtag}}
\sphinxAtStartPar
我们使用的 ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 开发板，它板载了 JTAG 调试接口，无需使用外部 JTAG 硬件适配器和额外线缆来连接 JTAG 与 ESP32。ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 采用 FT2232H 提供的 JTAG 接口，可以稳定运行在 20 MHz 的时钟频率，外接的适配器很难达到这个速度。

\sphinxAtStartPar
在软件方面，OpenOCD 支持相当多数量的 JTAG 适配器，请自行在网络上寻找并参阅 OpenOCD 支持的适配器列表 （请注意这一列表并不完整），其中还列出了兼容 SWD 接口的适配器，但请注意，ESP32 目前并不支持 SWD。此外，被硬编码为只支持特定产品线的 JTAG 适配器也无法在 ESP32 上工作，例如仅针对 STM32 系列产品的 ST\sphinxhyphen{}LINK 适配器。

\sphinxAtStartPar
JTAG 正常工作至少需要连接的信号线有：TDI、TDO、TCK、TMS 和 GND。一些 JTAG 适配器还需要 ESP32 提供一路电源到适配器的某个管脚上（比如 Vtar），用于设置适配器的工作电压。您也可以选择将 SRST 信号线连接到 ESP32 的 CH\_PD 管脚上，但请注意，目前 OpenOCD 对该信号线提供的支持相当有限。


\subsubsection{安装 OpenOCD}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:openocd}}
\sphinxAtStartPar
如果您已经按照前面的章节完成了 ESP\sphinxhyphen{}IDF 及其 CMake 构建系统的安装，那么 OpenOCD 已经被默认安装到了您的开发系统中。在设置开发环境 结束后，在终端中运行如下 OpenOCD 命令:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
openocd \PYGZhy{}\PYGZhy{}version
\end{sphinxVerbatim}

\sphinxAtStartPar
终端会输出类似以下内容的信息（实际版本号可能会更新）:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Open On\PYGZhy{}Chip Debugger  v0.10.0\PYGZhy{}esp32\PYGZhy{}20190708 \PYG{o}{(}\PYG{l+m}{2019}\PYGZhy{}07\PYGZhy{}08\PYGZhy{}11:04\PYG{o}{)}
Licensed under GNU GPL v2
For bug reports, \PYG{n+nb}{read}
    http://openocd.org/doc/doxygen/bugs.html
\end{sphinxVerbatim}

\sphinxAtStartPar
您还可以检查 OPENOCD\_SCRIPTS 环境变量的值，以确认 OpenOCD 配置文件的路径，Linux 和 macOS 用户可以在终端输入 echo \$OPENOCD\_SCRIPTS。如果终端输出了有效路径，则表明您已经正确安装 OpenOCD。


\subsubsection{配置并连接 JTAG 接口}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:id3}}
\sphinxAtStartPar
确保实验箱上的 JTAG 引脚已经使用跳线帽连接

\sphinxAtStartPar
检查 ESP32 上用于 JTAG 通信的引脚是否被接到了其它硬件上，这可能会影响 JTAG 的工作。

\sphinxAtStartPar
ESP32 引脚和 JTAG 接口信号


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
ESP32 引脚
&\sphinxstyletheadfamily 
\sphinxAtStartPar
JTAG 信号
\\
\hline
\sphinxAtStartPar
MTDO / GPIO15
&
\sphinxAtStartPar
TDO
\\
\hline
\sphinxAtStartPar
MTDI / GPIO12
&
\sphinxAtStartPar
TDI
\\
\hline
\sphinxAtStartPar
MTCK / GPIO13
&
\sphinxAtStartPar
TCK
\\
\hline
\sphinxAtStartPar
MTMS / GPIO14
&
\sphinxAtStartPar
TMS
\\
\hline
\sphinxAtStartPar
GND
&
\sphinxAtStartPar
GND
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{配置 USB 驱动}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:usb}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
使用标准 USB A / micro USB B 线将 ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 与计算机相连接，并打开开发板的电源。

\item {} 
\sphinxAtStartPar
打开终端，输入 \sphinxcode{\sphinxupquote{ls \sphinxhyphen{}l /dev/ttyUSB*}} 命令检查操作系统是否能够识别板子的 USB 端口。类似识别结果如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ls \PYGZhy{}l /dev/ttyUSB*
crw\PYGZhy{}rw\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYG{l+m}{1} root dialout \PYG{l+m}{188}, \PYG{l+m}{0} Jul \PYG{l+m}{10} \PYG{l+m}{19}:04 /dev/ttyUSB0
crw\PYGZhy{}rw\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{} \PYG{l+m}{1} root dialout \PYG{l+m}{188}, \PYG{l+m}{1} Jul \PYG{l+m}{10} \PYG{l+m}{19}:04 /dev/ttyUSB1
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
根据 OpenOCD README 文档 中 “Permissions delegation” 小节的介绍，设置这两个 USB 端口的访问权限。

\sphinxAtStartPar
在命令行中修改 USB 权限（单次生效）

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo chmod \PYG{l+m}{777} /dev/ttyUSB0
sudo chmod \PYG{l+m}{777} /dev/ttyUSB1
\end{sphinxVerbatim}

\sphinxAtStartPar
添加用户组到 plugdev（永久生效）

\sphinxAtStartPar
对于大多数 Linux 发行版（如 Ubuntu 等），我们需要将 openocd\sphinxhyphen{}esp32 提供的\sphinxcode{\sphinxupquote{.rules}}文件放到\sphinxcode{\sphinxupquote{/etc/udev/rules.d/}}下（具体请参考自己操作系统的文档）

\sphinxAtStartPar
.rules 文件目录：\sphinxcode{\sphinxupquote{/\$HOME/.espressif/tools/openocd\sphinxhyphen{}esp32/v0.11.0\sphinxhyphen{}esp32\sphinxhyphen{}20211220/openocd\sphinxhyphen{}esp32/share/openocd/contrib}}

\sphinxAtStartPar
其中.espressif 是隐藏文件夹

\sphinxAtStartPar
之后需要将你的用户添加到 plugdev 组中

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo usermod \PYGZhy{}a \PYGZhy{}G plugdev \PYG{n+nv}{\PYGZdl{}USER}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
注销并重新登录 Linux 系统，然后重新插拔板子的电源使之前的改动生效。在终端再次输入 \sphinxcode{\sphinxupquote{ls \sphinxhyphen{}l /dev/ttyUSB*}} 命令进行验证，查看这两个设备的组所有者是否已经从 dialout 更改为 plugde

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ls \PYGZhy{}l /dev/ttyUSB*
crw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} \PYG{l+m}{1} root plugdev \PYG{l+m}{188}, \PYG{l+m}{0} Jul \PYG{l+m}{10} \PYG{l+m}{19}:07 /dev/ttyUSB0
crw\PYGZhy{}rw\PYGZhy{}r\PYGZhy{}\PYGZhy{} \PYG{l+m}{1} root plugdev \PYG{l+m}{188}, \PYG{l+m}{1} Jul \PYG{l+m}{10} \PYG{l+m}{19}:07 /dev/ttyUSB1
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
使用标准 USB A / micro USB B 线将 ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 与计算机相连接，并打开板子的电源。打开终端，输入 \sphinxcode{\sphinxupquote{ls \sphinxhyphen{}l /dev/ttyUSB*}} 命令检查操作系统是否能够识别板子的 USB 端口。类似识别结果如下：

\end{enumerate}

\sphinxAtStartPar
​ 如果看到类似的输出结果，并且你也是 plugdev 组的成员， 那么设置工作就完成了。

\sphinxAtStartPar
​ 具有较低编号的 /dev/ttyUSBn 接口用于 JTAG 通信，另一路接口被连接到 ESP32 的串口（UART），用于上传应用程序映像给 ESP32 进行烧写。

\sphinxAtStartPar
现在，ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 的 JTAG 接口应该可以被 OpenOCD 使用。


\subsubsection{运行 OpenOCD}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:id4}}
\sphinxAtStartPar
配置完目标并将其连接到电脑后，即可启动 OpenOCD。

\sphinxAtStartPar
打开终端，按照快速入门指南中的 设置好开发环境 章节进行操作，然后运行如下命令，以启动 OpenOCD（该命令适用于 Windows、Linux 和 macOS）:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
openocd \PYGZhy{}f board/esp32\PYGZhy{}wrover\PYGZhy{}kit\PYGZhy{}3.3v.cfg
\end{sphinxVerbatim}

\sphinxAtStartPar
现在您应该可以看到如下输出（此日志来自板载 ESP32\sphinxhyphen{}WROOM\sphinxhyphen{}32 模组的 ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 开发板）:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
user\PYGZhy{}name@computer\PYGZhy{}name:\PYGZti{}/esp/esp\PYGZhy{}idf\PYGZdl{} openocd \PYGZhy{}f board/esp32\PYGZhy{}wrover\PYGZhy{}kit\PYGZhy{}3.3v.cfg
Open On\PYGZhy{}Chip Debugger  v0.10.0\PYGZhy{}esp32\PYGZhy{}20190708 \PYG{o}{(}\PYG{l+m}{2019}\PYGZhy{}07\PYGZhy{}08\PYGZhy{}11:04\PYG{o}{)}
Licensed under GNU GPL v2
For bug reports, \PYG{n+nb}{read}
        http://openocd.org/doc/doxygen/bugs.html
none separate
adapter speed: \PYG{l+m}{20000} kHz
force hard breakpoints
Info : ftdi: \PYG{k}{if} you experience problems at higher adapter clocks, try the \PYG{n+nb}{command} \PYG{l+s+s2}{\PYGZdq{}ftdi\PYGZus{}tdo\PYGZus{}sample\PYGZus{}edge falling\PYGZdq{}}
Info : clock speed \PYG{l+m}{20000} kHz
Info : JTAG tap: esp32.cpu0 tap/device found: 0x120034e5 \PYG{o}{(}mfg: 0x272 \PYG{o}{(}Tensilica\PYG{o}{)}, part: 0x2003, ver: 0x1\PYG{o}{)}
Info : JTAG tap: esp32.cpu1 tap/device found: 0x120034e5 \PYG{o}{(}mfg: 0x272 \PYG{o}{(}Tensilica\PYG{o}{)}, part: 0x2003, ver: 0x1\PYG{o}{)}
Info : esp32: Debug controller was reset \PYG{o}{(}\PYG{n+nv}{pwrstat}\PYG{o}{=}0x5F, after clear 0x0F\PYG{o}{)}.
Info : esp32: Core was reset \PYG{o}{(}\PYG{n+nv}{pwrstat}\PYG{o}{=}0x5F, after clear 0x0F\PYG{o}{)}.
\end{sphinxVerbatim}

\sphinxAtStartPar
如果出现指示权限问题的错误，请打开 \sphinxcode{\sphinxupquote{\textasciitilde{}/esp/openocd\sphinxhyphen{}esp32}} 目录，参阅 OpenOCD README 文件中关于 “Permissions delegation” 的说明。

\sphinxAtStartPar
如果遇到无法找到配置文件的错误，例如 Can’t find board/esp32\sphinxhyphen{}wrover\sphinxhyphen{}kit\sphinxhyphen{}3.3v.cfg，请检查 \sphinxcode{\sphinxupquote{OPENOCD\_SCRIPTS}} 环境变量是否设置正确，OpenOCD 根据此变量来查找 \sphinxhyphen{}f 指定的文件，详见 安装 OpenOCD。此外，还需要检查配置文件是否确实位于该路径下。

\sphinxAtStartPar
如果出现 JTAG 错误（例如输出为 …all ones 或 …all zeroes），请检查硬件连接是否正确，除了 ESP32 的管脚之外是否还有其他信号连接到了 JTAG，并查看是否所有器件都已经上电。


\subsubsection{上传待调试的应用程序}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:id5}}
\sphinxAtStartPar
按照正常步骤构建并上传 ESP32 应用程序，具体请参阅 ESP\sphinxhyphen{}IDF 命令行基本流程 章节。

\sphinxAtStartPar
除此以外，您还可以使用 OpenOCD 通过 JTAG 接口将应用程序镜像烧写到闪存中，命令如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
openocd \PYGZhy{}f board/esp32\PYGZhy{}wrover\PYGZhy{}kit\PYGZhy{}3.3v.cfg \PYGZhy{}c \PYG{l+s+s2}{\PYGZdq{}program\PYGZus{}esp filename.bin 0x10000 verify exit\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
其中 OpenOCD 的烧写命令 program\_esp 格式如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
program\PYGZus{}esp \PYGZlt{}image\PYGZus{}file\PYGZgt{} \PYGZlt{}offset\PYGZgt{} \PYG{o}{[}verify\PYG{o}{]} \PYG{o}{[}reset\PYG{o}{]} \PYG{o}{[}exit\PYG{o}{]}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
image\_file \sphinxhyphen{} 程序镜像文件存放的路径

\item {} 
\sphinxAtStartPar
offset \sphinxhyphen{} 镜像烧写到闪存中的偏移地址

\item {} 
\sphinxAtStartPar
verify \sphinxhyphen{} 烧写完成后校验闪存中的内容（可选）

\item {} 
\sphinxAtStartPar
reset \sphinxhyphen{} 烧写完成后重启目标（可选）

\item {} 
\sphinxAtStartPar
exit \sphinxhyphen{} 烧写完成后退出 OpenOCD（可选）

\end{itemize}


\subsubsection{启动调试器}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:id6}}
\sphinxAtStartPar
ESP32 的工具链中带有 GNU 调试器（简称 GDB），它和其它工具链软件共同存放于 xtensa\sphinxhyphen{}esp32\sphinxhyphen{}elf\sphinxhyphen{}gdb 中。现在我们在命令行环境下，实现 GDB 的调试


\paragraph{命令行模式}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:id7}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
为了能够启动调试会话，需要先启动并运行目标，如果还没有完成，请按照 \sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/jtag-debugging/index.html\#jtag-debugging-configuring-target}{配置 ESP32 目标板} 中的介绍进行操作。

\item {} 
\sphinxAtStartPar
打开一个新的终端会话并前往待调试的项目目录，比如：
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{o}{\PYGZti{}}\PYG{o}{/}\PYG{n}{esp}\PYG{o}{/}\PYG{n}{blink}
\end{sphinxVerbatim}
\end{quote}

\item {} 
\sphinxAtStartPar
当启动调试器时，通常需要提供几个配置参数和命令，为了避免每次都在命令行中逐行输入这些命令，您可以新建一个配置文件，并将其命名为 \sphinxcode{\sphinxupquote{gdbinit}}:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{target} \PYG{n}{remote} \PYG{p}{:}\PYG{l+m+mi}{3333}
\PYG{n+nb}{set} \PYG{n}{remote} \PYG{n}{hardware}\PYG{o}{\PYGZhy{}}\PYG{n}{watchpoint}\PYG{o}{\PYGZhy{}}\PYG{n}{limit} \PYG{l+m+mi}{2}
\PYG{n}{mon} \PYG{n}{reset} \PYG{n}{halt}
\PYG{n}{flushregs}
\PYG{n}{thb} \PYG{n}{app\PYGZus{}main}
\PYG{n}{c}
\end{sphinxVerbatim}

\sphinxAtStartPar
将此文件保存在当前目录中。

\sphinxAtStartPar
有关 \sphinxcode{\sphinxupquote{gdbinit}} 文件内部的更多详细信息，请参阅 \sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/jtag-debugging/tips-and-quirks.html\#jtag-debugging-tip-debugger-startup-commands}{调试器的启动命令的含义} 章节。
\end{quote}

\item {} 
\sphinxAtStartPar
准备好启动 GDB，请在终端中输入以下内容：
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{xtensa}\PYG{o}{\PYGZhy{}}\PYG{n}{esp32}\PYG{o}{\PYGZhy{}}\PYG{n}{elf}\PYG{o}{\PYGZhy{}}\PYG{n}{gdb} \PYG{o}{\PYGZhy{}}\PYG{n}{x} \PYG{n}{gdbinit} \PYG{n}{build}\PYG{o}{/}\PYG{n}{blink}\PYG{o}{.}\PYG{n}{elf}
\end{sphinxVerbatim}
\end{quote}

\item {} 
\sphinxAtStartPar
如果前面的步骤已经正确完成，您会看到如下所示的输出日志，在日志的最后会出现 \sphinxcode{\sphinxupquote{(gdb)}} 提示符：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
user\PYGZhy{}name@computer\PYGZhy{}name:\PYGZti{}/esp/blink\PYGZdl{} xtensa\PYGZhy{}esp32\PYGZhy{}elf\PYGZhy{}gdb \PYGZhy{}x gdbinit build/blink.elf
GNU gdb (crosstool\PYGZhy{}NG crosstool\PYGZhy{}ng\PYGZhy{}1.22.0\PYGZhy{}61\PYGZhy{}gab8375a) 7.10
Copyright (C) 2015 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later \PYGZlt{}http://gnu.org/licenses/gpl.html\PYGZgt{}
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type \PYGZdq{}show copying\PYGZdq{}
and \PYGZdq{}show warranty\PYGZdq{} for details.
This GDB was configured as \PYGZdq{}\PYGZhy{}\PYGZhy{}host=x86\PYGZus{}64\PYGZhy{}build\PYGZus{}pc\PYGZhy{}linux\PYGZhy{}gnu \PYGZhy{}\PYGZhy{}target=xtensa\PYGZhy{}esp32\PYGZhy{}elf\PYGZdq{}.
Type \PYGZdq{}show configuration\PYGZdq{} for configuration details.
For bug reporting instructions, please see:
\PYGZlt{}http://www.gnu.org/software/gdb/bugs/\PYGZgt{}.
Find the GDB manual and other documentation resources online at:
\PYGZlt{}http://www.gnu.org/software/gdb/documentation/\PYGZgt{}.
For help, type \PYGZdq{}help\PYGZdq{}.
Type \PYGZdq{}apropos word\PYGZdq{} to search for commands related to \PYGZdq{}word\PYGZdq{}...
Reading symbols from build/blink.elf...done.
0x400d10d8 in esp\PYGZus{}vApplicationIdleHook () at /home/user\PYGZhy{}name/esp/esp\PYGZhy{}idf/components/esp32/./freertos\PYGZus{}hooks.c:52
52          asm(\PYGZdq{}waiti 0\PYGZdq{});
JTAG tap: esp32.cpu0 tap/device found: 0x120034e5 (mfg: 0x272 (Tensilica), part: 0x2003, ver: 0x1)
JTAG tap: esp32.slave tap/device found: 0x120034e5 (mfg: 0x272 (Tensilica), part: 0x2003, ver: 0x1)
esp32: Debug controller was reset (pwrstat=0x5F, after clear 0x0F).
esp32: Core was reset (pwrstat=0x5F, after clear 0x0F).
esp32 halted. PRO\PYGZus{}CPU: PC=0x5000004B (active)    APP\PYGZus{}CPU: PC=0x00000000
esp32: target state: halted
esp32: Core was reset (pwrstat=0x1F, after clear 0x0F).
Target halted. PRO\PYGZus{}CPU: PC=0x40000400 (active)    APP\PYGZus{}CPU: PC=0x40000400
esp32: target state: halted
Hardware assisted breakpoint 1 at 0x400db717: file /home/user\PYGZhy{}name/esp/blink/main/./blink.c, line 43.
0x0:    0x00000000
Target halted. PRO\PYGZus{}CPU: PC=0x400DB717 (active)    APP\PYGZus{}CPU: PC=0x400D10D8
[New Thread 1073428656]
[New Thread 1073413708]
[New Thread 1073431316]
[New Thread 1073410672]
[New Thread 1073408876]
[New Thread 1073432196]
[New Thread 1073411552]
[Switching to Thread 1073411996]

Temporary breakpoint 1, app\PYGZus{}main () at /home/user\PYGZhy{}name/esp/blink/main/./blink.c:43
43      xTaskCreate(\PYGZam{}blink\PYGZus{}task, \PYGZdq{}blink\PYGZus{}task\PYGZdq{}, 512, NULL, 5, NULL);
(gdb)
\end{sphinxVerbatim}

\end{enumerate}

\sphinxAtStartPar
注意上面日志的倒数第三行显示了调试器已经在 \sphinxcode{\sphinxupquote{app\_main()}}函数的断点处停止，该断点在 \sphinxcode{\sphinxupquote{gdbinit}} 文件中设定。由于处理器已经暂停运行，LED 也不会闪烁。如果这也是您看到的现象，您可以开始调试了。

\sphinxAtStartPar
如果您不太了解 GDB 的常用方法，请查阅 \sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/jtag-debugging/debugging-examples.html\#jtag-debugging-examples-command-line}{使用命令行的调试示例} 文章中的调试示例章节 \sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/jtag-debugging/index.html\#jtag-debugging-examples}{调试范例}。


\paragraph{idf.py 模式}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:idf-py}}
\sphinxAtStartPar
您还可以使用 \sphinxcode{\sphinxupquote{idf.py}} 更方便地执行上述提到的调试命令，可以使用以下命令：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idf.py openocd}}

\sphinxAtStartPar
在终端中运行 OpenOCD，其配置信息来源于环境变量或者命令行。默认会使用 \sphinxcode{\sphinxupquote{OPENOCD\_SCRIPTS}} 环境变量中指定的脚本路径，它是由 ESP\sphinxhyphen{}IDF 项目仓库中的导出脚本（\sphinxcode{\sphinxupquote{export.sh}} or \sphinxcode{\sphinxupquote{export.bat}}）添加到系统环境变量中的。 当然，您可以在命令行中通过 \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}openocd\sphinxhyphen{}scripts}} 参数来覆盖这个变量的值。

\sphinxAtStartPar
至于当前开发板的 JTAG 配置，请使用环境变量 \sphinxcode{\sphinxupquote{OPENOCD\_COMMANDS}} 或命令行参数 \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}openocd\sphinxhyphen{}commands}}。如果这两者都没有被定义，那么 OpenOCD 会使用 \sphinxcode{\sphinxupquote{\sphinxhyphen{}fboard/esp32\sphinxhyphen{}wrover\sphinxhyphen{}kit\sphinxhyphen{}3.3v.cfg}} 参数来启动。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idf.py gdb}}

\sphinxAtStartPar
根据当前项目的 elf 文件自动生成 GDB 启动脚本，然后会按照 \sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/jtag-debugging/using-debugger.html\#jtag-debugging-using-debugger-command-line}{使用命令行调试} 中所描述的步骤启动 GDB。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idf.py gdbtui}}

\sphinxAtStartPar
和步骤 2 相同，但是会在启动 GDB 的时候传递 \sphinxcode{\sphinxupquote{tui}} 参数，这样可以方便在调试过程中查看源代码。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idf.py gdbgui}}

\sphinxAtStartPar
启动 \sphinxhref{https://www.gdbgui.com/}{gdbgui}，在浏览器中打开调试器的前端界面。请在运行安装脚本时添加 “–enable\sphinxhyphen{}gdbgui” 参数，即运行 \sphinxcode{\sphinxupquote{install.sh \sphinxhyphen{}\sphinxhyphen{}enable\sphinxhyphen{}gdbgui}}，从而确保支持 “gdbgui” 选项。

\sphinxAtStartPar
上述这些命令也可以合并到一起使用，\sphinxcode{\sphinxupquote{idf.py}} 会自动将后台进程（比如 openocd）最先运行，交互式进程（比如 GDB，monitor）最后运行。

\sphinxAtStartPar
常用的组合命令如下所示:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{idf}\PYG{o}{.}\PYG{n}{py} \PYG{n}{openocd} \PYG{n}{gdbgui} \PYG{n}{monitor}
\end{sphinxVerbatim}

\sphinxAtStartPar
上述命令会将 OpenOCD 运行至后台，然后启动 \sphinxhref{https://www.gdbgui.com/}{gdbgui} 打开一个浏览器窗口，显示调试器的前端界面，最后在活动终端打开串口监视器。

\end{enumerate}


\paragraph{IDE 模式}
\label{\detokenize{exp-esp32/ide/esp-idf-cli-debug:ide}}
\sphinxAtStartPar
实际应用中，我们并不直接在命令行终端中调用和操作 GDB ，而是在 IDE (例如 Eclipse、Visual Studio Code, cLion 等）中进行调用，使用图形用户界面间接操作 GDB，这一方法无需在终端中输入任何命令。本手册选择在 Clion 中进行 Debug 调试。

\sphinxAtStartPar
Clion 下的调试器配置与使用将在下一章 Clion 下 ESP\sphinxhyphen{}IDF 的配置与开发 中进行讲解。

\sphinxstepscope


\subsection{Clion 下 ESP\sphinxhyphen{}IDF 的配置与开发}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:clion-esp-idf}}\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev::doc}}

\subsubsection{clion 简介}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:clion}}
\sphinxAtStartPar
clion 是 jetbrain 公司开发的 C/C++ IDE 集成开发工具，具有如下优点：
\begin{itemize}
\item {} 
\sphinxAtStartPar
完善的开发环境：

\sphinxAtStartPar
指 ESP\sphinxhyphen{}IDF 工程的建立，配置，编译，调试，量产等基础操作的环境。一个优秀的编程环境可以让开发体验直线上升，工作事半功倍，而 Clion 恰是我们 C 语言开发的优秀编程环境！

\item {} 
\sphinxAtStartPar
代码辅助

\sphinxAtStartPar
使用对 C 和 C++ 有深刻理解的编辑器，您便可以高效地读写代码。 可在智能补全功能中按类型筛选出补全结果。 使用路径导航来跟踪您在范围层次结构内的位置。 借助参数名称提示，深入了解函数调用。 查找符号的上下文用法，或通过键入其名称直接跳转到该符号。 CLion 甚至可以确保您的代码符合编码指南，包括格式、命名等要求。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728105523027}.png}

\item {} 
\sphinxAtStartPar
代码生成

\sphinxAtStartPar
立即生成大量样板代码。 使用简单的快捷键重写和实现函数。 生成构造函数和析构函数、getter 和 setter 以及相等、相关和流输出运算符。 使用语句包装代码块，或者从用法生成声明。 创建自定义活动模板以在整个代码库中重用典型代码块，从而节省时间并使样式保持一致。 \sphinxincludegraphics{{image-20220728105547240}.png}

\item {} 
\sphinxAtStartPar
安全重构

\sphinxAtStartPar
重命名符号，内联函数、变量或宏，在层次结构中移动成员，更改函数签名，以及提取函数、变量、参数或 typedef。 无论您使用哪种自动重构，都请放心，CLion 能够安全地在整个代码中传播相关变更。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728105623134}.png}

\item {} 
\sphinxAtStartPar
快速文档

\sphinxAtStartPar
检查脱字符号下的代码即可了解任何信息：函数签名详细信息、审查评论、预览 Doxygen 样式文档、检查针对缺少显式类型的符号推断出的类型，以及查看正确格式化的最终宏替换。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728105704105}.png}

\end{itemize}


\subsubsection{Clion 及插件安装}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id1}}

\paragraph{安装 clion}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id2}}
\sphinxAtStartPar
clion 可以在官方网站获取并安装，在 ubunbu 下，安装 cion 又两种方法，分别如下：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
命令行安装

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo snap install clion \PYGZhy{}\PYGZhy{}classic
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
在 Ubuntu 自带应用商店 snap 中搜索一键安装

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728104733457}.png}

\end{enumerate}


\paragraph{添加插件}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id3}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
点击\sphinxcode{\sphinxupquote{setup | plugin}} ，搜索 Chinese，选择 中文语言包 并下载安装
\begin{itemize}
\item {} 
\sphinxAtStartPar
安装完成后会提示重启 IDE，重启后便显示中文

\end{itemize}

\item {} 
\sphinxAtStartPar
在插件处搜索 Serial，选择 Serial Port Monitor 并下载安装
\begin{itemize}
\item {} 
\sphinxAtStartPar
这是串口调试器插件，集成在 IED 内非常好用

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728112238437}.png}


\subsubsection{实验步骤}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id4}}
\sphinxAtStartPar
要从空白开始实现一个项目，需要两个工具：
\begin{itemize}
\item {} 
\sphinxAtStartPar
基于命令行的 \sphinxcode{\sphinxupquote{idf.py}} 项目管理工具

\item {} 
\sphinxAtStartPar
编码，调试使用的 \sphinxcode{\sphinxupquote{Clion}} 集成开发环境。

\end{itemize}


\paragraph{创建项目}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id5}}
\sphinxAtStartPar
现在，您可以开始准备开发 ESP32 应用程序了。假设我要重头开始创建 hellow\sphinxhyphen{}world 工程

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 进入项目目录}
\PYG{n+nb}{cd} \PYGZti{}/code/\PYG{n+nv}{\PYGZdl{}GROUPNAME}/esp32/

\PYG{c+c1}{\PYGZsh{} 获取idf所需的环境和工具}
get\PYGZhy{}idf
\PYG{c+c1}{\PYGZsh{} 创建hellow\PYGZhy{}world工程}
idf.py create\PYGZhy{}project hellow\PYGZhy{}world
\PYG{c+c1}{\PYGZsh{} 检查下目录下发生了什么}
tree \PYGZhy{}L \PYG{l+m}{2}
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
❗\sphinxstylestrong{注意：}
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP\sphinxhyphen{}IDF 编译系统不支持带有空格的路径！！！

\end{itemize}
\end{quote}


\paragraph{连接设备}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id6}}
\sphinxAtStartPar
现在，请将 ESP32 开发板连接到 PC，并查看开发板使用的串口。

\sphinxAtStartPar
我们使用的\sphinxcode{\sphinxupquote{ ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT}} 开发板一般会有如下两个 \sphinxcode{\sphinxupquote{ttyUSB}} 口：

\sphinxAtStartPar
数字较小的为\sphinxcode{\sphinxupquote{ JATG}} 接口，较大的为串口接口。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ls \PYGZhy{}l /dev/ttyUSB*
crw\PYGZhy{}rw\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+ \PYG{l+m}{1} root plugdev \PYG{l+m}{188}, \PYG{l+m}{0} 7月  \PYG{l+m}{27} \PYG{l+m}{14}:31 /dev/ttyUSB0
crw\PYGZhy{}rw\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+ \PYG{l+m}{1} root plugdev \PYG{l+m}{188}, \PYG{l+m}{1} 7月  \PYG{l+m}{27} \PYG{l+m}{14}:31 /dev/ttyUSB1
\end{sphinxVerbatim}

\sphinxAtStartPar
此处的用户群组 \sphinxcode{\sphinxupquote{plugdev }}可能会有出入，具体原因是对\sphinxcode{\sphinxupquote{JAGT}}进行了 \sphinxcode{\sphinxupquote{USB }}驱动配置，会在下一章 \sphinxcode{\sphinxupquote{ESP\sphinxhyphen{}IDFJTAG }}调试流程 中提及。

\sphinxAtStartPar
请记住串口名，在下面的步骤中会使用到。


\paragraph{设置目标芯片}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id7}}
\sphinxAtStartPar
打开一个新项目后，应首先设置“目标”芯片 。乐鑫有 esp32, esp32\sphinxhyphen{}s2, esp32\sphinxhyphen{}s3,esp32\sphinxhyphen{}c 以及 esp32\sphinxhyphen{}h 等多种架构

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 我们的开发版目标芯片是ESP32}
idf.py set\PYGZhy{}target esp32
\PYG{c+c1}{\PYGZsh{} 检查下目录下发生了什么}
tree \PYGZhy{}L \PYG{l+m}{2}
\end{sphinxVerbatim}


\paragraph{配置项目参数}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id8}}
\sphinxAtStartPar
运行工程配置工具 menuconfig。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{idf}\PYG{o}{.}\PYG{n}{py} \PYG{n}{menuconfig}
\end{sphinxVerbatim}

\sphinxAtStartPar
注意，此操作将清除并初始化项目之前的编译和配置（如有）。 也可以在后续步骤中再 clion 中实现该步骤的设置。


\paragraph{在 clion 中打开项目}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id9}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
打开 clion，然后依次\sphinxcode{\sphinxupquote{文件}} | \sphinxcode{\sphinxupquote{打开}}

\item {} 
\sphinxAtStartPar
在对话框找到你刚才创建项目的目录

\item {} 
\sphinxAtStartPar
点击\sphinxcode{\sphinxupquote{cmakelists.txt}}这个文件，点击打开

\item {} 
\sphinxAtStartPar
在弹出的对话框选择\sphinxcode{\sphinxupquote{作为项目打开}}

\end{enumerate}


\paragraph{配置项目环境变量}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id10}}

\subparagraph{系统变量}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id11}}
\sphinxAtStartPar
需要配置 esp\sphinxhyphen{}idf 的工具到系统环境变量，以便 clion 正确的使用这些工具。执行如下操作
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{设置}} \sphinxhyphen{}| \sphinxcode{\sphinxupquote{构建、执行、部署}} | \sphinxcode{\sphinxupquote{工具链}}，

\item {} 
\sphinxAtStartPar
在对话框右上角点击 \sphinxcode{\sphinxupquote{添加环境}} | \sphinxcode{\sphinxupquote{来自文件}}

\item {} 
\sphinxAtStartPar
选择你的 esp\sphinxhyphen{}idf 的环境脚本文件，如：\sphinxcode{\sphinxupquote{/home/iot/esp/esp\sphinxhyphen{}idf/export.sh}}

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{clion_env-setup}.png}


\subparagraph{用户变量}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id12}}
\sphinxAtStartPar
需要添加如下几个用户变量


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
名称
&\sphinxstyletheadfamily 
\sphinxAtStartPar
值
\\
\hline
\sphinxAtStartPar
ESPBAUD
&
\sphinxAtStartPar
115200
\\
\hline
\sphinxAtStartPar
ESPPORT
&
\sphinxAtStartPar
/dev/ttyUSB1
\\
\hline
\sphinxAtStartPar
IDF\_PATH
&
\sphinxAtStartPar
/home/iot/esp/esp\sphinxhyphen{}idf
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{quote}

\sphinxAtStartPar
❗ 注意

\sphinxAtStartPar
ESPBAUD 是波特率，默认 115200；ESPPORT 是串口的引脚，一般为数字较大的那个，具体根据实际情况填写，一般为 1 或 2

\sphinxAtStartPar
IDF\_PATH 一般默认如上表填写，实际上是安装的 ESP\sphinxhyphen{}IDF 的目录，自行构建环境的同学目录还可能带有\sphinxhyphen{}4.4.1 这种版本号
\end{quote}

\sphinxAtStartPar
添加过程如下图所示：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{设置}} | \sphinxcode{\sphinxupquote{构建、执行、部署}} | \sphinxcode{\sphinxupquote{cmake}}

\item {} 
\sphinxAtStartPar
点击下方\sphinxcode{\sphinxupquote{环境}}选项的编辑按钮，在弹出的对话框，点击 \sphinxcode{\sphinxupquote{+}} 号

\item {} 
\sphinxAtStartPar
填写名称和值

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{user_env}.png}

\sphinxAtStartPar
请下载 MOV 文件播放演示。

\sphinxAtStartPar
<video src=“../IMG/config\sphinxhyphen{}env.mov”>

\sphinxAtStartPar
\sphinxstylestrong{注意：在环境文件名下写 export.sh 所在的真实目录}


\paragraph{在 Clion 中实现 menuconfig}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:clion-menuconfig}}
\sphinxAtStartPar
menuconfig 可以通过 idf.py 实现，也可在 clion 中配置实现，具体配置方法如下：

\sphinxAtStartPar
点击\sphinxcode{\sphinxupquote{选择运行/调试配置}} 选择\sphinxcode{\sphinxupquote{编辑配置}}，如下图：找到 Shell Script 进行添加

\sphinxAtStartPar
\sphinxincludegraphics{{clion-edit-config}.png}

\sphinxAtStartPar
在弹出对话框中（如下图），点击 + ，选择 Shell Script , 一次选择并填写：

\sphinxAtStartPar
名称：menuconfig

\sphinxAtStartPar
执行：脚本文本

\sphinxAtStartPar
脚本文本填写如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
get\PYGZhy{}idf\PYG{p}{;}idf.py menuconfig
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{edit-menuconfig}.png}

\sphinxAtStartPar
以上设置好后，就可以在 clion 中实现 menuconfig 设置，点击\sphinxcode{\sphinxupquote{选择运行/调试配置}} , 选择\sphinxcode{\sphinxupquote{menuconfig}}并点击运行按钮，终端框会如下图所示，通过上下键依次设置即可。

\sphinxAtStartPar
如何不需要设置，直接按下 ESC 返回即可。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728151042596}.png}


\paragraph{代码编写}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id13}}
\sphinxAtStartPar
在 clion 中进行代码编写，充分发挥 clion 的功能。


\paragraph{编译、烧录、监视}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id14}}
\sphinxAtStartPar
右上角\sphinxcode{\sphinxupquote{调试配置}}工具栏是调试和配置的重要工具，如下图所示，左侧\sphinxcode{\sphinxupquote{小锤子}}图标代表\sphinxcode{\sphinxupquote{构建}}，右侧\sphinxcode{\sphinxupquote{三角}}图标代表\sphinxcode{\sphinxupquote{运行}}。下拉图标中有各种运行配置（esp\sphinxhyphen{}idf 的各种构建目标），其中最重要的就是，\sphinxcode{\sphinxupquote{编译}}、\sphinxcode{\sphinxupquote{烧录}}、\sphinxcode{\sphinxupquote{监视}}运行几个常见配置目标。即： \sphinxcode{\sphinxupquote{hello\_world(工程名).elf}}、\sphinxcode{\sphinxupquote{flash}}、\sphinxcode{\sphinxupquote{monitor}}。其他不需要的配置选项，可以在\sphinxcode{\sphinxupquote{编辑配置}}中 用 \sphinxcode{\sphinxupquote{\sphinxhyphen{}}} 号 删掉。

\sphinxAtStartPar
\sphinxincludegraphics{{../../../../Library/Application%20Support/typora-user-images/image-20230524123809612}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728143215219}.png}


\subparagraph{编译工程文件}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id15}}
\sphinxAtStartPar
选择\sphinxcode{\sphinxupquote{hello\_world.elf}}，点击\sphinxcode{\sphinxupquote{构建}}运行编译，如果一切正常，编译完成后将生成 .elf 文件。


\subparagraph{烧录到设备}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id16}}
\sphinxAtStartPar
选择\sphinxcode{\sphinxupquote{flash}}，点击\sphinxcode{\sphinxupquote{构建}}。跟在终端烧录一样，当下方消息框出现如图所示连接中的情况的时候，请按下板子的 boot 按键直到烧录开始再松开。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728152106428}.png}


\subparagraph{运行监视器查看串口日志输出}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id17}}
\sphinxAtStartPar
选择\sphinxcode{\sphinxupquote{monitor}}执行\sphinxcode{\sphinxupquote{构建}}，就能看到如下图的日志输出啦！

\sphinxAtStartPar
点击 红色方块 即可终止退出。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728152512423}.png}


\paragraph{JTAG Debug}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:jtag-debug}}

\subparagraph{JATG 配置}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:jatg}}
\sphinxAtStartPar
点 \sphinxcode{\sphinxupquote{运行/调试配置}} 框左上角\sphinxcode{\sphinxupquote{添加新配置}}，找到 \sphinxcode{\sphinxupquote{嵌入式 GDB 服务器}} 进行添加
\begin{itemize}
\item {} 
\sphinxAtStartPar
名称： 默认不用更改，也可改为自己想要的名称；

\item {} 
\sphinxAtStartPar
目标： 默认不用更改；

\item {} 
\sphinxAtStartPar
可执行二进制文件选择对应工程名的 elf 文件。

\item {} 
\sphinxAtStartPar
调试器

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/home/Ubuntu用户名/.espressif/tools/xtensa\PYGZhy{}esp32\PYGZhy{}elf/esp\PYGZhy{}2021r2\PYGZhy{}patch3\PYGZhy{}8.4.0/xtensa\PYGZhy{}esp32\PYGZhy{}elf/bin/xtensa\PYGZhy{}esp32\PYGZhy{}elf\PYGZhy{}gdb
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
下载可执行文件：\sphinxstylestrong{无}

\item {} 
\sphinxAtStartPar
‘target remote’:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
tcp:127.0.0.1:3333
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
GDB 服务器：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/home/Ubuntu用户名/.espressif/tools/openocd\PYGZhy{}esp32/v0.11.0\PYGZhy{}esp32\PYGZhy{}20211220/openocd\PYGZhy{}esp32/bin/openocd
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
GDB 服务器实参：

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}f board/esp32\PYGZhy{}wrover\PYGZhy{}kit\PYGZhy{}3.3v.cfg \PYGZhy{}c \PYG{l+s+s2}{\PYGZdq{}init;reset halt;\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728145749085}.png}


\subparagraph{调试}
\label{\detokenize{exp-esp32/ide/esp-idf-clion-dev:id18}}
\sphinxAtStartPar
先在希望程序中断运行的语句所在行打上断点，在所在行行数数字旁边空的区域单击，即可看见该行高亮并且带有红点

\sphinxAtStartPar
再选择设置好的 JTAGDebug 并点旁边的 ‘’小虫子‘’ 按键进行 Debug，执行后会如下图所示：

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220728152832656}.png}

\sphinxAtStartPar
我们能清楚的看到变量的情况以及类型等，更复杂的语句还有更多显示。

\sphinxAtStartPar
调试框边上的各个按键同学们可自行查看并学习用法。

\sphinxAtStartPar
点击 红色方块 即可终止退出。

\sphinxAtStartPar
\sphinxstylestrong{至此 Clion 下 ESP\sphinxhyphen{}IDF 的配置与开发已经完成！}

\sphinxstepscope


\section{外设接口与传感器}
\label{\detokenize{exp-esp32/peripherals/index:id1}}\label{\detokenize{exp-esp32/peripherals/index::doc}}
\sphinxAtStartPar
contents here


\subsection{实验内容}
\label{\detokenize{exp-esp32/peripherals/index:id2}}
\sphinxAtStartPar
本节包含如下实验内容：

\sphinxstepscope


\subsubsection{UART}
\label{\detokenize{exp-esp32/peripherals/uart:uart}}\label{\detokenize{exp-esp32/peripherals/uart::doc}}

\paragraph{概述}
\label{\detokenize{exp-esp32/peripherals/uart:id1}}
\sphinxAtStartPar
通用异步接收器/发送器 (UART) 是一种硬件功能，它使用广泛采用的异步串行通信接口（例如 RS232、RS422、RS485）来处理通信（即时序要求和数据帧）。

\sphinxAtStartPar
ESP32 芯片具有三个 UART 控制器（UART0、UART1 和 UART2），每个控制器都具有一组相同的寄存器，以简化编程并提高灵活性。

\sphinxAtStartPar
每个 UART 控制器可独立配置波特率、数据位长度、位顺序、停止位数量、奇偶校验位等参数。所有控制器都兼容不同制造商的 UART 设备，还可以支持红外数据关联协议（红外线）。


\paragraph{基本步骤}
\label{\detokenize{exp-esp32/peripherals/uart:id2}}
\sphinxAtStartPar
以下步骤描述了如何使用 UART 驱动程序的功能和数据类型在 ESP32 和其他 UART 设备之间建立通信。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
设置通讯参数\sphinxhyphen{} 设置波特率、数据位、停止位等。

\item {} 
\sphinxAtStartPar
设置通信引脚\sphinxhyphen{} 分配用于连接到设备的引脚。

\item {} 
\sphinxAtStartPar
驱动程序安装\sphinxhyphen{} 为 UART 驱动程序分配 ESP32 的资源。

\item {} 
\sphinxAtStartPar
运行 UART 通信\sphinxhyphen{} 发送/接收数据

\item {} 
\sphinxAtStartPar
使用中断\sphinxhyphen{} 触发特定通信事件的中断

\item {} 
\sphinxAtStartPar
删除驱动程序\sphinxhyphen{} 如果不再需要 UART 通信，则释放分配的资源

\end{enumerate}

\sphinxAtStartPar
步骤 1 到 3 包括配置阶段。第 4 步是 UART 开始运行的地方。步骤 5 和 6 是可选的。


\subparagraph{设置通讯参数}
\label{\detokenize{exp-esp32/peripherals/uart:id3}}
\sphinxAtStartPar
调用函数\sphinxcode{\sphinxupquote{uart\_param\_config()}}并将结构体\sphinxcode{\sphinxupquote{uart\_config\_t}}传递给它\sphinxcode{\sphinxupquote{uart\_config\_t}}。该\sphinxcode{\sphinxupquote{uart\_config\_t}}结构应包含所有必需的参数。示例代码如下。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{const}\PYG{+w}{ }\PYG{n}{uart\PYGZus{}config\PYGZus{}t}\PYG{+w}{ }\PYG{n}{uart\PYGZus{}config}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{baud\PYGZus{}rate}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{115200}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{data\PYGZus{}bits}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}DATA\PYGZus{}8\PYGZus{}BITS}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{parity}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}PARITY\PYGZus{}DISABLE}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{stop\PYGZus{}bits}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}STOP\PYGZus{}BITS\PYGZus{}1}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{flow\PYGZus{}ctrl}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}HW\PYGZus{}FLOWCTRL\PYGZus{}DISABLE}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{source\PYGZus{}clk}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}SCLK\PYGZus{}APB}\PYG{p}{,}
\PYG{+w}{    }\PYG{c+c1}{//从上到下分别为：波特率、数据位、奇偶校验控制、停止位、硬件流控模式、时钟选择}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{uart\PYGZus{}param\PYGZus{}config}\PYG{p}{(}\PYG{n}{UART\PYGZus{}NUM\PYGZus{}1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{uart\PYGZus{}config}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subparagraph{设置通信引脚}
\label{\detokenize{exp-esp32/peripherals/uart:id4}}
\sphinxAtStartPar
设置通信参数后，配置 UART 设备将连接到的物理 GPIO 引脚。调用该函数\sphinxcode{\sphinxupquote{uart\_set\_pin()}}并指定驱动程序应将 Tx、Rx、(RTS 和 CTS) 信号到的 GPIO 引脚号。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//定义UART引脚}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define TXD\PYGZus{}PIN (GPIO\PYGZus{}NUM\PYGZus{}4)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define RXD\PYGZus{}PIN (GPIO\PYGZus{}NUM\PYGZus{}5)}

\PYG{n}{uart\PYGZus{}set\PYGZus{}pin}\PYG{p}{(}\PYG{n}{UART\PYGZus{}NUM\PYGZus{}1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{TXD\PYGZus{}PIN}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{RXD\PYGZus{}PIN}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}PIN\PYGZus{}NO\PYGZus{}CHANGE}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}PIN\PYGZus{}NO\PYGZus{}CHANGE}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subparagraph{驱动安装}
\label{\detokenize{exp-esp32/peripherals/uart:id5}}
\sphinxAtStartPar
设置好通信引脚后，通过调用安装驱动程序\sphinxcode{\sphinxupquote{uart\_driver\_install()}}并指定以下参数：
\begin{itemize}
\item {} 
\sphinxAtStartPar
Tx 环形缓冲区的大小

\item {} 
\sphinxAtStartPar
Rx 环形缓冲区的大小

\item {} 
\sphinxAtStartPar
事件队列句柄和大小

\item {} 
\sphinxAtStartPar
分配中断的标志

\end{itemize}

\sphinxAtStartPar
该函数将为 UART 驱动程序分配所需的内部资源。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{uart\PYGZus{}driver\PYGZus{}install}\PYG{p}{(}\PYG{n}{UART\PYGZus{}NUM\PYGZus{}1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{RX\PYGZus{}BUF\PYGZus{}SIZE}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subparagraph{传输}
\label{\detokenize{exp-esp32/peripherals/uart:id6}}
\sphinxAtStartPar
准备好要传输的数据后，调用函数\sphinxcode{\sphinxupquote{uart\_write\_bytes()}}并将数据缓冲区的地址和数据长度传递给它。该函数会将数据复制到 Tx 环形缓冲区（立即或在有足够空间可用后），然后退出。当 Tx FIFO 缓冲区中有可用空间时，中断服务程序 (ISR) 将数据从 Tx 环形缓冲区移动到后台的 Tx FIFO 缓冲区。下面的代码演示了这个函数的使用。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 将数据写入 UART。}
\PYG{k+kt}{char}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{test\PYGZus{}str}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This is a test string.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{uart\PYGZus{}write\PYGZus{}bytes}\PYG{p}{(}\PYG{n}{uart\PYGZus{}num}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{)}\PYG{n}{test\PYGZus{}str}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{test\PYGZus{}str}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
功能\sphinxcode{\sphinxupquote{uart\_write\_bytes\_with\_break()}}类似于\sphinxcode{\sphinxupquote{uart\_write\_bytes()}}但在传输结束时增加了一个串行中断信号。“串行中断信号”意味着将 Tx 线保持在低电平的时间超过一个数据帧。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 向 UART 写入数据，以中断信号结束。}
\PYG{n}{uart\PYGZus{}write\PYGZus{}bytes\PYGZus{}with\PYGZus{}break}\PYG{p}{(}\PYG{n}{uart\PYGZus{}num}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test break}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{strlen}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test break}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
将数据写入 Tx FIFO 缓冲区的另一个函数是\sphinxcode{\sphinxupquote{uart\_tx\_chars()}}。与 不同\sphinxcode{\sphinxupquote{uart\_write\_bytes()}}，此函数在空间可用之前不会阻塞。相反，它将写入所有可以立即放入硬件 Tx FIFO 的数据，然后返回写入的字节数。

\sphinxAtStartPar
有一个“伴侣”功能\sphinxcode{\sphinxupquote{uart\_wait\_tx\_done()}}可以监控 Tx FIFO 缓冲区的状态，并在它为空时返回。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 等待数据包发送}
\PYG{k}{const}\PYG{+w}{ }\PYG{n}{uart\PYGZus{}port\PYGZus{}t}\PYG{+w}{ }\PYG{n}{uart\PYGZus{}num}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}NUM\PYGZus{}2}\PYG{p}{;}
\PYG{n}{ESP\PYGZus{}ERROR\PYGZus{}CHECK}\PYG{p}{(}\PYG{n}{uart\PYGZus{}wait\PYGZus{}tx\PYGZus{}done}\PYG{p}{(}\PYG{n}{uart\PYGZus{}num}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// wait timeout is 100 RTOS ticks (TickType\PYGZus{}t)}
\end{sphinxVerbatim}


\subparagraph{接收}
\label{\detokenize{exp-esp32/peripherals/uart:id7}}
\sphinxAtStartPar
一旦 UART 接收到数据并保存在 Rx FIFO 缓冲区中，就需要使用 函数检索数据\sphinxcode{\sphinxupquote{uart\_read\_bytes()}}。在读取数据之前，您可以通过调用来检查 Rx FIFO 缓冲区中可用的字节数\sphinxcode{\sphinxupquote{uart\_get\_buffeed\_data\_len()}}。下面给出了使用这些函数的示例。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 从 UART 读取数据。}
\PYG{k}{const}\PYG{+w}{ }\PYG{n}{uart\PYGZus{}port\PYGZus{}t}\PYG{+w}{ }\PYG{n}{uart\PYGZus{}num}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}NUM\PYGZus{}2}\PYG{p}{;}
\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{[}\PYG{l+m+mi}{128}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{length}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ESP\PYGZus{}ERROR\PYGZus{}CHECK}\PYG{p}{(}\PYG{n}{uart\PYGZus{}get\PYGZus{}buffered\PYGZus{}data\PYGZus{}len}\PYG{p}{(}\PYG{n}{uart\PYGZus{}num}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t}\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{length}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{length}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{uart\PYGZus{}read\PYGZus{}bytes}\PYG{p}{(}\PYG{n}{uart\PYGZus{}num}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{length}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
如果不再需要 Rx FIFO 缓冲区中的数据，您可以通过调用清除缓冲区 uart\_flush()。


\subparagraph{软件流控制}
\label{\detokenize{exp-esp32/peripherals/uart:id8}}
\sphinxAtStartPar
如果硬件流控关闭，可以分别使用 和 函数手动设置 RTS 和 DTR 信号电\sphinxcode{\sphinxupquote{uart\_set\_rts()}}平\sphinxcode{\sphinxupquote{uart\_set\_dtr()}}。


\subparagraph{通讯方式选择}
\label{\detokenize{exp-esp32/peripherals/uart:id9}}
\sphinxAtStartPar
UART 控制器支持多种通信模式。可以使用该功能选择模式\sphinxcode{\sphinxupquote{uart\_set\_mode()}}。选择特定模式后，UART 驱动程序将相应地处理连接的 UART 设备的行为。例如，它可以使用 RTS 线控制 RS485 驱动芯片，实现半双工 RS485 通信。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// 将 UART 设置为 rs485 半双工模式}
\PYG{n}{ESP\PYGZus{}ERROR\PYGZus{}CHECK}\PYG{p}{(}\PYG{n}{uart\PYGZus{}set\PYGZus{}mode}\PYG{p}{(}\PYG{n}{uart\PYGZus{}num}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{UART\PYGZus{}MODE\PYGZus{}RS485\PYGZus{}HALF\PYGZus{}DUPLEX}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subparagraph{使用中断}
\label{\detokenize{exp-esp32/peripherals/uart:id10}}
\sphinxAtStartPar
在特定的 UART 状态或检测到的错误之后，可以生成许多中断。\sphinxcode{\sphinxupquote{ESP32 技术参考手册> UART 控制器 (UART) > UART 中断和UHCI 中断{[} PDF {]}}}中提供了可用中断的完整列表。\sphinxcode{\sphinxupquote{uart\_enable\_intr\_mask()}}您可以通过调用或\sphinxcode{\sphinxupquote{uart\_disable\_intr\_mask()}}分别启用或禁用特定的中断。所有中断的掩码都可以作为\sphinxcode{\sphinxupquote{UART\_INTR\_MASK}}.

\sphinxAtStartPar
默认情况下，该\sphinxcode{\sphinxupquote{uart\_driver\_install()}}函数安装驱动程序的内部中断处理程序来管理 Tx 和 Rx 环形缓冲区，并提供高级 API 函数，如事件（见下文）。也可以使用 注册一个较低级别的中断处理程序\sphinxcode{\sphinxupquote{uart\_isr\_register()}}，并使用 再次释放它\sphinxcode{\sphinxupquote{uart\_isr\_free()}}。在这种情况下，一些使用 Tx 和 Rx 环形缓冲区、事件等的 UART 驱动程序函数将不会自动工作 \sphinxhyphen{} 必须直接在 ISR 中处理中断。在自定义处理程序实现中，使用清除中断状态位\sphinxcode{\sphinxupquote{uart\_clear\_intr\_status()}}。

\sphinxAtStartPar
API 提供了一种方便的方法来处理本文档中讨论的特定中断，方法是将它们包装到专用函数中：
\begin{itemize}
\item {} 
\sphinxAtStartPar
事件检测：其中定义了几个事件\sphinxcode{\sphinxupquote{uart\_event\_type\_t}}，可以使用 FreeRTOS 队列功能向用户应用程序报告。您可以在驱动程序安装\sphinxcode{\sphinxupquote{uart\_driver\_install()}}中描述的调用时启用此功能。在 peripherals/uart/uart\_events 中可以找到使用事件检测的示例。

\item {} 
\sphinxAtStartPar
FIFO 空间阈值或传输超时：当 Tx 和 Rx FIFO 缓冲区填充特定数量的字符或发送或接收数据超时时，它们会触发中断。要使用这些中断，请执行以下操作：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uart\_intr\_config\_t}}通过在结构中输入并调用来配置缓冲区长度和超时的各个阈值\sphinxcode{\sphinxupquote{uart\_intr\_config()}}

\item {} 
\sphinxAtStartPar
使用函数启用中断\sphinxcode{\sphinxupquote{uart\_enable\_tx\_intr()}}和\sphinxcode{\sphinxupquote{uart\_enable\_rx\_intr()}}

\item {} 
\sphinxAtStartPar
使用相应的函数禁用这些中断\sphinxcode{\sphinxupquote{uart\_disable\_tx\_intr()}}或\sphinxcode{\sphinxupquote{uart\_disable\_rx\_intr()}}

\end{itemize}

\item {} 
\sphinxAtStartPar
模式检测：在检测到相同字符的“模式”被重复接收/发送多次时触发的中断。此功能在示例\sphinxcode{\sphinxupquote{peripherals/uart/uart\_events}}中演示。例如，它可用于检测命令字符串后跟在命令字符串末尾添加的特定数量的相同字符（“模式”）。可以使用以下功能：
\begin{itemize}
\item {} 
\sphinxAtStartPar
使用配置和启用此中断\sphinxcode{\sphinxupquote{uart\_enable\_pattern\_det\_intr()}}

\item {} 
\sphinxAtStartPar
使用禁用中断\sphinxcode{\sphinxupquote{uart\_disable\_pattern\_det\_intr()}}

\end{itemize}

\end{itemize}


\subparagraph{宏}
\label{\detokenize{exp-esp32/peripherals/uart:id11}}
\sphinxAtStartPar
API 还定义了几个宏。例如，\sphinxcode{\sphinxupquote{UART\_FIFO\_LEN}}定义硬件 FIFO 缓冲区的长度；\sphinxcode{\sphinxupquote{UART\_BITRATE\_MAX}}给出 UART 控制器等支持的最大波特率。


\subparagraph{删除驱动程序}
\label{\detokenize{exp-esp32/peripherals/uart:id12}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uart\_driver\_install()}}如果不再需要与之建立的通信，可以通过调用来删除驱动程序以释放分配的资源\sphinxcode{\sphinxupquote{uart\_driver\_delete()}}。


\paragraph{实验内容}
\label{\detokenize{exp-esp32/peripherals/uart:id13}}
\sphinxAtStartPar
示例演示两个异步任务如何使用相同的 UART 接口进行通信。可以使用此示例为串行通信开发更复杂的应用程序。

\sphinxAtStartPar
该示例启动了两个 FreeRTOS 任务：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
第一个任务\sphinxcode{\sphinxupquote{Hello world}}通过 UART 定期发送。

\item {} 
\sphinxAtStartPar
第二个任务任务监听、接收和打印来自 UART 的数据。

\end{enumerate}


\subparagraph{所需硬件}
\label{\detokenize{exp-esp32/peripherals/uart:id14}}
\sphinxAtStartPar
ESP32 开发板、microUSB 线、电脑，一根母对母头杜邦线。


\subparagraph{硬件接线}
\label{\detokenize{exp-esp32/peripherals/uart:id15}}
\sphinxAtStartPar
代码中可配置的\sphinxcode{\sphinxupquote{RXD\_PIN}}和\sphinxcode{\sphinxupquote{TXD\_PIN}}（默认情况下是 GPIO4 和 GPIO5）需要使用杜邦线进行\sphinxstylestrong{短接}。


\subparagraph{源代码参考}
\label{\detokenize{exp-esp32/peripherals/uart:id16}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}


\subparagraph{代码调试与示例输出}
\label{\detokenize{exp-esp32/peripherals/uart:id17}}
\sphinxAtStartPar
使用 idf.py 以及 clion 管理项目，编码，build, flash, 以及 monitor。

\sphinxAtStartPar
运行 monitor 后，你将从监控控制台收到以下串口打印输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
...
I \PYG{o}{(}\PYG{l+m}{3261}\PYG{o}{)} TX\PYGZus{}TASK: Wrote \PYG{l+m}{11} bytes
I \PYG{o}{(}\PYG{l+m}{4261}\PYG{o}{)} RX\PYGZus{}TASK: Read \PYG{l+m}{11} bytes: \PYG{l+s+s1}{\PYGZsq{}Hello world\PYGZsq{}}
I \PYG{o}{(}\PYG{l+m}{4261}\PYG{o}{)} RX\PYGZus{}TASK: 0x3ffb821c   \PYG{l+m}{48} \PYG{l+m}{65} 6c 6c 6f \PYG{l+m}{20} \PYG{l+m}{77} 6f  \PYG{l+m}{72} 6c \PYG{l+m}{64}                 \PYG{p}{|}Hello world\PYG{p}{|}
...
\end{sphinxVerbatim}


\paragraph{API 参考}
\label{\detokenize{exp-esp32/peripherals/uart:api}}
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-reference/peripherals/uart.html}{UART API}

\sphinxstepscope


\subsubsection{LCD\&SPI}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:lcd-spi}}\label{\detokenize{exp-esp32/peripherals/lcd_spi::doc}}

\paragraph{实验目的}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:id1}}
\sphinxAtStartPar
本实验主要完成以下两个目的：
\begin{itemize}
\item {} 
\sphinxAtStartPar
学习 ESP32 的 SPI 接口 API 使用

\item {} 
\sphinxAtStartPar
完成具备 SPI 接口的 LCD 的图片显示

\end{itemize}


\paragraph{SPI 相关知识}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:spi}}
\sphinxAtStartPar
SPI 是串行外设接口（Serial Peripheral Interface）的缩写，是一种高速的，全双工，同步的通信总线。


\subparagraph{特点}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:id2}}
\sphinxAtStartPar
SPI 是一个同步的数据总线，也就是说它是用单独的数据线和一个单独的时钟信号来保证发送端和接收端的完美同步。

\sphinxAtStartPar
时钟是一个振荡信号，它告诉接收端在确切的时机对数据线上的信号进行采样。

\sphinxAtStartPar
产生时钟的一侧称为主机，另一侧称为从机。总是只有一个主机（一般来说可以是微控制器/MCU），但是可以有多个从机（后面详细介绍）；

\sphinxAtStartPar
数据的采集时机可能是时钟信号的上升沿（从低到高）或下降沿（从高到低）。

\sphinxAtStartPar
具体要看对 SPI 的配置；

\sphinxAtStartPar
整体的传输大概可以分为以下几个过程：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
主机先将 NSS 信号拉低，这样保证开始接收数据；

\item {} 
\sphinxAtStartPar
当接收端检测到时钟的边沿信号时，它将立即读取数据线上的信号，这样就得到了一位数据（1bit）;

\item {} 
\sphinxAtStartPar
由于时钟是随数据一起发送的，因此指定数据的传输速度并不重要，尽管设备将具有可以运行的最高速度（稍后我们将讨论选择合适的时钟边沿和速度）。

\item {} 
\sphinxAtStartPar
主机发送到从机时：主机产生相应的时钟信号，然后数据一位一位地将从 MOSI 信号线上进行发送到从机；

\item {} 
\sphinxAtStartPar
主机接收从机数据：如果从机需要将数据发送回主机，则主机将继续生成预定数量的时钟信号，并且从机会将数据通过 MISO 信号线发送；

\end{enumerate}

\sphinxAtStartPar
具体如下图所示：

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220805095644008}.png}
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{❗ 注意}

\sphinxAtStartPar
\sphinxstylestrong{SPI 是“全双工”（具有单独的发送和接收线路），因此可以在同一时间发送和接收数据，另外 SPI 的接收硬件可以是一个简单的移位寄存器。这比异步串行通信所需的完整 UART 要简单得多，并且更加便宜；}
\end{quote}


\subparagraph{SPI 特性}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:id3}}
\sphinxAtStartPar
SPI 总线包括 4 条逻辑线，定义如下：
\begin{itemize}
\item {} 
\sphinxAtStartPar
MISO：Master input slave output 主机输入，从机输出（数据来自从机）；

\item {} 
\sphinxAtStartPar
MOSI：Master output slave input 主机输出，从机输入（数据来自主机）；

\item {} 
\sphinxAtStartPar
SCLK ：Serial Clock 串行时钟信号，由主机产生发送给从机；

\item {} 
\sphinxAtStartPar
SS：Slave Select 片选信号，由主机发送，以控制与哪个从机通信，通常是低电平有效信号。

\end{itemize}

\sphinxAtStartPar
其他制造商可能会遵循其他命名规则，但是最终他们指的相同的含义。以下是一些常用术语；
\begin{itemize}
\item {} 
\sphinxAtStartPar
MISO 也可以是 SIMO，DOUT，DO，SDO 或 SO（在主机端）;

\item {} 
\sphinxAtStartPar
MOSI 也可以是 SOMI，DIN，DI，SDI 或 SI（在主机端）;

\item {} 
\sphinxAtStartPar
NSS 也可以是 CE，CS 或 SSEL;

\item {} 
\sphinxAtStartPar
SCLK 也可以是 SCK;

\end{itemize}

\sphinxAtStartPar
本文将按照以下命名进行讲解{[}MISO, MOSI, SCK，NSS{]}

\sphinxAtStartPar
下图显示了单个主机和单个从机之间的典型 SPI 连接。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220805095850815}.png}


\subparagraph{时钟频率}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:id4}}
\sphinxAtStartPar
SPI 总线上的主机必须在通信开始时候配置并生成相应的时钟信号。在每个 SPI 时钟周期内，都会发生全双工数据传输。

\sphinxAtStartPar
主机在 MOSI 线上发送一位数据，从机读取它，而从机在 MISO 线上发送一位数据，主机读取它。

\sphinxAtStartPar
就算只进行单向的数据传输，也要保持这样的顺序。这就意味着无论接收任何数据，必须实际发送一些东西！在这种情况下，我们称其为虚拟数据；

\sphinxAtStartPar
从理论上讲，只要实际可行，时钟速率就可以是您想要的任何速率，当然这个速率受限于每个系统能提供多大的系统时钟频率，以及最大的 SPI 传输速率。


\subparagraph{时钟极性 CKP/Clock Polarity}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:ckp-clock-polarity}}
\sphinxAtStartPar
除了配置串行时钟速率（频率）外，SPI 主设备还需要配置时钟极性。

\sphinxAtStartPar
根据硬件制造商的命名规则不同，时钟极性通常写为 CKP 或 CPOL。时钟极性和相位共同决定读取数据的方式，比如信号上升沿读取数据还是信号下降沿读取数据；

\sphinxAtStartPar
CKP 可以配置为 1 或 0。这意味着您可以根据需要将时钟的默认状态（IDLE）设置为高或低。极性反转可以通过简单的逻辑逆变器实现。您必须参考设备的数据手册才能正确设置 CKP 和 CKE。

\sphinxAtStartPar
CKP = 0：时钟空闲 IDLE 为低电平 0；

\sphinxAtStartPar
CKP = 1：时钟空闲 IDLE 为高电平 1；


\subparagraph{时钟相位 CKE /Clock Phase (Edge)}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:cke-clock-phase-edge}}
\sphinxAtStartPar
除配置串行时钟速率和极性外，SPI 主设备还应配置时钟相位（或边沿）。根据硬件制造商的不同，时钟相位通常写为 CKE 或 CPHA；

\sphinxAtStartPar
顾名思义，时钟相位/边沿，也就是采集数据时是在时钟信号的具体相位或者边沿；

\sphinxAtStartPar
CKE = 0：在时钟信号 SCK 的第一个跳变沿采样；

\sphinxAtStartPar
CKE = 1：在时钟信号 SCK 的第二个跳变沿采样；


\subparagraph{时钟配置总结}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:id5}}
\sphinxAtStartPar
综上几种情况，下图总结了所有时钟配置组合，并突出显示了实际采样数据的时刻；

\sphinxAtStartPar
其中黑色线为采样数据的时刻；

\sphinxAtStartPar
蓝色线为 SCK 时钟信号；

\sphinxAtStartPar
具体如下图所示；

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220805095947933}.png}


\paragraph{实验内容}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:id6}}
\sphinxAtStartPar
本实验的内容是解码 jpeg 图像并将其显示在具备 SPI 接口的 LCD 上，图片位于 main 文件夹中。


\subparagraph{LCD 硬件}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:lcd}}
\sphinxAtStartPar
实验箱的 esp32 开发板 ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 上，已经附带有一块 LCD 屏幕 ILI9341。

\sphinxAtStartPar
LCD 与 ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 管脚连接情况


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
ESP32 管脚
&\sphinxstyletheadfamily 
\sphinxAtStartPar
LCD 信号
\\
\hline
\sphinxAtStartPar
GPIO18
&
\sphinxAtStartPar
复位
\\
\hline
\sphinxAtStartPar
GPIO19
&
\sphinxAtStartPar
SCL
\\
\hline
\sphinxAtStartPar
GPIO21
&
\sphinxAtStartPar
D/C
\\
\hline
\sphinxAtStartPar
GPIO22
&
\sphinxAtStartPar
CS
\\
\hline
\sphinxAtStartPar
GPIO23
&
\sphinxAtStartPar
SDA
\\
\hline
\sphinxAtStartPar
GPIO25
&
\sphinxAtStartPar
SDO
\\
\hline
\sphinxAtStartPar
GPIO5
&
\sphinxAtStartPar
背光
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subparagraph{源代码}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:id7}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}

\sphinxAtStartPar
具体函数作用参考代码注释，想要了解 ESP32 的 SPI 驱动更多以及更深入的话可以前往乐鑫官方文档，以下为链接：

\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/v4.4.1/esp32/api-reference/peripherals/spi\_master.html}{SPI API 参考}

\sphinxAtStartPar
本实验中无需再去\sphinxcode{\sphinxupquote{menuconfig}}中配置，默认引脚设置就是为 ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT 服务的，具体请检查 \sphinxcode{\sphinxupquote{main.c}} 代码内如下定义：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}LCD\PYGZus{}PIXEL\PYGZus{}CLOCK\PYGZus{}HZ (10 * 1000 * 1000)}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}LCD\PYGZus{}BK\PYGZus{}LIGHT\PYGZus{}ON\PYGZus{}LEVEL  0}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}LCD\PYGZus{}BK\PYGZus{}LIGHT\PYGZus{}OFF\PYGZus{}LEVEL !EXAMPLE\PYGZus{}LCD\PYGZus{}BK\PYGZus{}LIGHT\PYGZus{}ON\PYGZus{}LEVEL}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}PIN\PYGZus{}NUM\PYGZus{}DATA0          23  }\PYG{c+cm}{/*!\PYGZlt{} for 1\PYGZhy{}line SPI, this also refered as MOSI */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}PIN\PYGZus{}NUM\PYGZus{}PCLK           19}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}PIN\PYGZus{}NUM\PYGZus{}CS             22}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}PIN\PYGZus{}NUM\PYGZus{}DC             21}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}PIN\PYGZus{}NUM\PYGZus{}RST            18}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}PIN\PYGZus{}NUM\PYGZus{}BK\PYGZus{}LIGHT       5}
\end{sphinxVerbatim}


\subparagraph{编码调试与示例输出}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:id8}}
\sphinxAtStartPar
使用 idf.py 以及 clion 管理项目，编码，build, flash。

\sphinxAtStartPar
完成后，您将看到 LCD 中显示如下画面：

\sphinxAtStartPar
\sphinxincludegraphics{{20220805143854}.jpg}


\paragraph{SPI API 参考}
\label{\detokenize{exp-esp32/peripherals/lcd_spi:spi-api}}
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/v4.4.1/esp32/api-reference/peripherals/spi\_master.html}{SPI API 参考}

\sphinxstepscope


\subsubsection{I2C}
\label{\detokenize{exp-esp32/peripherals/i2c:i2c}}\label{\detokenize{exp-esp32/peripherals/i2c::doc}}
\sphinxstepscope


\subsubsection{摄像头OV7670}
\label{\detokenize{exp-esp32/peripherals/camera:ov7670}}\label{\detokenize{exp-esp32/peripherals/camera::doc}}
\sphinxstepscope


\subsubsection{触摸传感器}
\label{\detokenize{exp-esp32/peripherals/touch:id1}}\label{\detokenize{exp-esp32/peripherals/touch::doc}}
\sphinxAtStartPar
触摸传感器系统由保护覆盖层、触摸电极、绝缘基板和走线组成，保护覆盖层位于最上层，绝缘基板上设有电极及走线。\sphinxstylestrong{用户触摸覆盖层将产生电容变化}，根据电容变化判断此次触摸是否为有效触摸行为。

\sphinxAtStartPar
ESP32 最多可支持 \sphinxstylestrong{10 个电容式触摸传感器}通道/GPIO。

\sphinxAtStartPar
触摸传感器可以以矩阵或滑条等方式组合使用，从而覆盖更大触感区域及更多触感点。触摸传感由软件或专用硬件计时器发起，由有限状态机 (FSM) 硬件控制。


\paragraph{API 介绍}
\label{\detokenize{exp-esp32/peripherals/touch:api}}
\sphinxAtStartPar
下面将 API 分解成几个函数组进行介绍，帮助用户快速了解以下功能：
\begin{itemize}
\item {} 
\sphinxAtStartPar
初始化触摸传感器驱动程序

\item {} 
\sphinxAtStartPar
配置触摸传感器 GPIO 管脚

\item {} 
\sphinxAtStartPar
触摸状态测量

\item {} 
\sphinxAtStartPar
调整测量参数（优化测量）

\item {} 
\sphinxAtStartPar
滤波采样

\item {} 
\sphinxAtStartPar
触摸监测方式

\item {} 
\sphinxAtStartPar
设置中断信号监测触碰动作

\item {} 
\sphinxAtStartPar
中断触发，唤醒睡眠模式

\end{itemize}


\subparagraph{初始化触摸传感器驱动程序}
\label{\detokenize{exp-esp32/peripherals/touch:id2}}
\sphinxAtStartPar
使用触摸传感器之前，需要先调用 \sphinxcode{\sphinxupquote{touch\_pad\_init()}} 函数初始化触摸传感器驱动程序。此函数设置了 API 参考 项下的 Macros 中列出的几项 ..\_DEFAULT 驱动程序参数，同时删除之前设置过的触摸传感器信息（如有），并禁用中断。

\sphinxAtStartPar
如果不再需要该驱动程序，可以调用 \sphinxcode{\sphinxupquote{touch\_pad\_deinit()}} 释放已初始化的驱动程序。


\subparagraph{配置触摸传感器 GPIO 管脚}
\label{\detokenize{exp-esp32/peripherals/touch:gpio}}
\sphinxAtStartPar
调用 \sphinxcode{\sphinxupquote{touch\_pad\_config()}} 使能某一 GPIO 的触感功能。

\sphinxAtStartPar
使用 \sphinxcode{\sphinxupquote{touch\_pad\_set\_fsm\_mode()}} 选择触摸传感器测量（由 FSM 操作）是由硬件定时器自动启动，还是由软件自动启动。如果选择软件模式，请使用 \sphinxcode{\sphinxupquote{touch\_pad\_sw\_start()}} 启动 FSM。


\subparagraph{触摸状态测量}
\label{\detokenize{exp-esp32/peripherals/touch:id3}}
\sphinxAtStartPar
借助以下两个函数从传感器读取原始数据和滤波后的数据：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{touch\_pad\_read\_raw\_data()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{touch\_pad\_read\_filtered()}}

\end{itemize}

\sphinxAtStartPar
这两个函数也可以用于检查触碰和释放触摸传感器时传感器读数变化范围，然后根据这些信息设定触摸传感器的触摸阈值。
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{❗ 注意}

\sphinxAtStartPar
\sphinxstylestrong{使用\sphinxcode{\sphinxupquote{touch\_pad\_read\_filtered()}}之前，需要先调用 滤波采样 中特定的滤波器函数来初始化并配置该滤波器。}
\end{quote}


\subparagraph{测量方式}
\label{\detokenize{exp-esp32/peripherals/touch:id4}}
\sphinxAtStartPar
触摸传感器会统计固定时间内的充放电次数，其计数结果即为原始数据，可由 \sphinxcode{\sphinxupquote{touch\_pad\_read\_raw\_data()}} 读出。上述固定时间可通过 \sphinxcode{\sphinxupquote{touch\_pad\_set\_measurement\_clock\_cycles()}} 设置。完成一次测量后，触摸传感器会在下次测量开始前保持睡眠状态。两次测量之前的间隔时间可由 \sphinxcode{\sphinxupquote{touch\_pad\_set\_measurement\_interval()}} 进行设置。
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{❗ 注意}

\sphinxAtStartPar
\sphinxstylestrong{若设置的计数时间太短（即测量持续的时钟周期数太小），则可能导致结果不准确，但是过大的计数时间也会造成功耗上升。另外，若睡眠时间加测量时间的总时间过长，则会造成触摸传感器响应变慢。}
\end{quote}


\subparagraph{优化测量}
\label{\detokenize{exp-esp32/peripherals/touch:id5}}
\sphinxAtStartPar
触摸传感器设有数个可配置参数，以适应触摸传感器设计特点。例如，如果需要感知较细微的电容变化，则可以缩小触摸传感器充放电的参考电压范围。用户可以使用 \sphinxcode{\sphinxupquote{touch\_pad\_set\_voltage()}} 函数设置电压参考低值和参考高值。

\sphinxAtStartPar
优化测量除了可以识别细微的电容变化之外，还可以降低应用程序功耗，但可能会增加测量噪声干扰。如果得到的动态读数范围结果比较理想，则可以调用 \sphinxcode{\sphinxupquote{touch\_pad\_set\_measurement\_clock\_cycles()}} 函数来减少测量时间，从而进一步降低功耗。

\sphinxAtStartPar
可用的测量参数及相应的 \sphinxcode{\sphinxupquote{set}}函数总结如下：

\sphinxAtStartPar
触摸传感器充放电参数：

\sphinxAtStartPar
电压门限：\sphinxcode{\sphinxupquote{touch\_pad\_set\_voltage()}}

\sphinxAtStartPar
速率（斜率）\sphinxcode{\sphinxupquote{ touch\_pad\_set\_cnt\_mode()}}

\sphinxAtStartPar
单次测量所用的时钟周期：\sphinxcode{\sphinxupquote{touch\_pad\_set\_measurement\_clock\_cycles()}}

\sphinxAtStartPar
电压门限（参考低值/参考高值）、速率（斜率）与测量时间的关系如下图所示：

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220802142310089}.png}

\sphinxAtStartPar
上图中的 Output 代表触摸传感器读值，即一个测量周期内测得的脉冲计数值。

\sphinxAtStartPar
所有函数均成对出现，用于设定某一特定参数，并获取当前参数值。例如：\sphinxcode{\sphinxupquote{touch\_pad\_set\_voltage() }}和 \sphinxcode{\sphinxupquote{touch\_pad\_get\_voltage()}}。


\subparagraph{滤波采样}
\label{\detokenize{exp-esp32/peripherals/touch:id6}}
\sphinxAtStartPar
如果测量中存在噪声，可以使用提供的 API 函数对采样进行滤波。使用滤波器之前，请先调用 \sphinxcode{\sphinxupquote{touch\_pad\_filter\_start()}} 启动该滤波器。

\sphinxAtStartPar
滤波器类型为 IIR（无限脉冲响应滤波器），可以调用 \sphinxcode{\sphinxupquote{touch\_pad\_set\_filter\_period()}} 配置此类滤波器的采样周期。

\sphinxAtStartPar
如需停止滤波器，请调用 \sphinxcode{\sphinxupquote{touch\_pad\_filter\_stop()}} 函数。如果不再使用该滤波器，请调用 \sphinxcode{\sphinxupquote{touch\_pad\_filter\_delete()}} 删除此滤波器。


\subparagraph{触摸监测}
\label{\detokenize{exp-esp32/peripherals/touch:id7}}
\sphinxAtStartPar
触摸监测基于用户配置的阈值和 FSM 执行的原始测量，并由 ESP32 硬件实现。用户可以调用 \sphinxcode{\sphinxupquote{touch\_pad\_get\_status()}} 查看被触碰的触摸传感器，或调用 \sphinxcode{\sphinxupquote{touch\_pad\_clear\_status()}} 清除触摸状态信息。

\sphinxAtStartPar
也可以将硬件触摸监测连接至中断，详细介绍见下一章节。

\sphinxAtStartPar
如果测量中存在噪声，且电容变化幅度较小，硬件触摸监测结果可能就不太理想。如需解决这一问题，不建议使用硬件监测或中断信号，建议用户在自己的应用程序中进行采样滤波，并执行触摸监测。


\subparagraph{中断触发}
\label{\detokenize{exp-esp32/peripherals/touch:id8}}
\sphinxAtStartPar
在对触摸监测启用中断之前，请先设置一个触摸监测阈值。然后使用 触摸状态测量 中所述的函数读取并显示触摸和释放触摸传感器时测得的结果。如果测量中存在噪声且相对电容变化较小，请使用滤波器。用户也可以根据应用程序和环境条件，测试温度和电源电压变化对测量值的影响。

\sphinxAtStartPar
确定监测阈值后就可以在初始化时调用 \sphinxcode{\sphinxupquote{touch\_pad\_config() }}设置此阈值，或在运行时调用 \sphinxcode{\sphinxupquote{touch\_pad\_set\_thresh()}} 设置此阈值。

\sphinxAtStartPar
下一步就是设置如何触发中断。用户可以设置在阈值以下或以上触发中断，具体触发模式由函数 \sphinxcode{\sphinxupquote{touch\_pad\_set\_trigger\_mode() }}设置。

\sphinxAtStartPar
最后用户可以使用以下函数配置和管理中断调用：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{touch\_pad\_isr\_register() / touch\_pad\_isr\_deregister()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{touch\_pad\_intr\_enable() / touch\_pad\_intr\_disable()}}

\end{itemize}

\sphinxAtStartPar
中断配置完成后，用户可以调用 touch\_pad\_get\_status() 查看中断信号来自哪个触摸传感器，也可以调用 touch\_pad\_clear\_status() 清除触摸传感器状态信息。
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{❗ 注意}

\sphinxAtStartPar
\sphinxstylestrong{触摸监测中的中断信号基于原始/未经滤波的采样（对比设置的阈值），并在硬件中实现。启用软件滤波 API (请参考 滤波采样）并不会影响这一过程。}
\end{quote}


\subparagraph{从睡眠模式唤醒}
\label{\detokenize{exp-esp32/peripherals/touch:id9}}
\sphinxAtStartPar
如果使用触摸传感器中断将芯片从睡眠模式唤醒，用户可以选择配置一些触摸传感器，例如 SET1 或 SET1 和 SET2，触摸这些触摸传感器将触发中断并唤醒芯片。请调用 \sphinxcode{\sphinxupquote{touch\_pad\_set\_trigger\_source() }}实现上述操作。

\sphinxAtStartPar
用户可以使用以下函数管理 ‘SET’ 中触摸传感器所需的位模式配置：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{touch\_pad\_set\_group\_mask() / touch\_pad\_get\_group\_mask()}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{touch\_pad\_clear\_group\_mask()}}

\end{itemize}


\paragraph{实验内容}
\label{\detokenize{exp-esp32/peripherals/touch:id10}}

\subparagraph{触摸传感器中断示例}
\label{\detokenize{exp-esp32/peripherals/touch:id11}}
\sphinxAtStartPar
本实验演示如何设置 ESP32 的电容式触摸板外设以在触摸板时触发中断。它还展示了当需要更高的触摸检测灵敏度时，如何通过用于传感器设计的软件检测触摸事件。

\sphinxAtStartPar
ESP32 通过配置硬件寄存器支持触摸检测。硬件定期检测脉冲计数。如果脉冲计数超过设定的阈值，则会产生硬件中断，通知应用层某个触摸传感器通道可能被触发。

\sphinxAtStartPar
对于当垫被玻璃或塑料覆盖时的传感器设计，由“触摸”动作引起的差异可能非常小。在这种情况下，我们使用软件池和算法来降低噪声，以便仍然能够检测到脉冲计数的微小变化。在某些情况下，我们可能需要使用其他例程来动态调整阈值水平，因为它可能会根据环境条件而变化。


\subparagraph{源代码参考}
\label{\detokenize{exp-esp32/peripherals/touch:id12}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}


\subparagraph{代码调试与示例输出}
\label{\detokenize{exp-esp32/peripherals/touch:id13}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
使用 idf.py 以及 clion 管理项目，编码，build, flash,monitor

\item {} 
\sphinxAtStartPar
触摸 GPIO27 并 monitor

\end{enumerate}

\sphinxAtStartPar
观察监视器打印输出如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{6303}\PYG{o}{)} Touch pad: Waiting \PYG{k}{for} any pad being touched...
I \PYG{o}{(}\PYG{l+m}{6733}\PYG{o}{)} Touch pad: T7 activated!
I \PYG{o}{(}\PYG{l+m}{7333}\PYG{o}{)} Touch pad: T7 activated!
I \PYG{o}{(}\PYG{l+m}{7723}\PYG{o}{)} Touch pad: T7 activated!
I \PYG{o}{(}\PYG{l+m}{8043}\PYG{o}{)} Touch pad: T7 activated!
I \PYG{o}{(}\PYG{l+m}{8883}\PYG{o}{)} Touch pad: T5 activated!
I \PYG{o}{(}\PYG{l+m}{9523}\PYG{o}{)} Touch pad: T7 activated!
I \PYG{o}{(}\PYG{l+m}{12503}\PYG{o}{)} Touch pad: Waiting \PYG{k}{for} any pad being touched...
I \PYG{o}{(}\PYG{l+m}{15483}\PYG{o}{)} Touch pad: T7 activated!
I \PYG{o}{(}\PYG{l+m}{16253}\PYG{o}{)} Touch pad: T5 activated!
I \PYG{o}{(}\PYG{l+m}{17903}\PYG{o}{)} Touch pad: Waiting \PYG{k}{for} any pad being touched...
I \PYG{o}{(}\PYG{l+m}{22903}\PYG{o}{)} Touch pad: Waiting \PYG{k}{for} any pad being touched...
\end{sphinxVerbatim}
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{❗ 注意}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{感应阈值在启动时通过执行简单校准自动设置。应用程序正在读取每个焊盘的电流值，并假设该值的三分之二作为感应阈值。不要在应用程序启动时触摸板，否则感应可能无法正常工作。}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{因为我们开发板的引脚大规模复用，请在使用时将摄像头拔下，触摸 GPIO27}

\end{enumerate}
\end{quote}

\sphinxstepscope


\subsubsection{温湿度传感器采集}
\label{\detokenize{exp-esp32/peripherals/dht11:id1}}\label{\detokenize{exp-esp32/peripherals/dht11::doc}}

\paragraph{实验目的}
\label{\detokenize{exp-esp32/peripherals/dht11:id2}}
\sphinxAtStartPar
本实验演示如何从从 DHT11 温湿度传感器读取数据并将读取到的温湿度发送到串口。


\paragraph{DHT11 接口电路}
\label{\detokenize{exp-esp32/peripherals/dht11:dht11}}

\subparagraph{DHT11 及其接口}
\label{\detokenize{exp-esp32/peripherals/dht11:id3}}
\sphinxAtStartPar
本实验使用的 DHT11 数字温湿度传感器是一款含有已校准数字信号输出的温湿度复合传感器。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729165045406}.png}

\sphinxAtStartPar
DHT11 有 4 个引脚 pin


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
1
&\sphinxstyletheadfamily 
\sphinxAtStartPar
2
&\sphinxstyletheadfamily 
\sphinxAtStartPar
3
&\sphinxstyletheadfamily 
\sphinxAtStartPar
4
\\
\hline
\sphinxAtStartPar
VDD
&
\sphinxAtStartPar
DATA
&
\sphinxAtStartPar
NC
&
\sphinxAtStartPar
GND
\\
\hline
\sphinxAtStartPar
供电 3－5.5VDC
&
\sphinxAtStartPar
串行数据，单总线
&
\sphinxAtStartPar
空脚
&
\sphinxAtStartPar
接地，电源负极
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
可见实际只有 3 个需要引出，而信号线只有一条 DATA 线

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729164903590}.png}


\subparagraph{DATA 线时序图}
\label{\detokenize{exp-esp32/peripherals/dht11:data}}
\sphinxAtStartPar
先进行通讯，也就是检查有没有 DHT11 模块

\sphinxAtStartPar
首先主机发送开始信号，即：拉低数据线，保持 t1（至少 18ms）时间，然后拉高数据线 t2（20\sphinxhyphen{}40us）时间，然后读取 DHT11 的响应，正常的话，DHT11 会拉低数据线，保持 t3 （40\sphinxhyphen{}50us）时间，作为响应信号，然后 DHT11 拉高数据线，保持 t4（40\sphinxhyphen{}50us）时间后，开始输出数据。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729170546878}.png}

\sphinxAtStartPar
因为 DHT11 会发送 40 位的数据。

\sphinxAtStartPar
数据格式:

\sphinxAtStartPar
8bit 湿度整数数据+8bit 湿度小数数据 +8bi 温度整数数据+8bit 温度小数数据 +8bit 校验和

\sphinxAtStartPar
这 40 位的数据每一位的 0/1 状态又是怎么确定的呢？下图就是数字 0 和 1 的信号表示方法
\begin{itemize}
\item {} 
\sphinxAtStartPar
数字 0 时序：

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729171045106}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
数字 1 时序：

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729171143739}.png}


\paragraph{关键代码注释}
\label{\detokenize{exp-esp32/peripherals/dht11:id4}}
\sphinxAtStartPar
读取一个字节

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//读取一个字节数据}
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{COM}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{+w}{    }\PYG{c+c1}{// 温湿写入}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{uchar}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{8}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ucharFLAG}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{//等待IO口变低，变低后，通过延时去判断是0还是1}
\PYG{+w}{        }\PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{n}{getData}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{ucharFLAG}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{ets\PYGZus{}delay\PYGZus{}us}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ets\PYGZus{}delay\PYGZus{}us}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//延时35us}
\PYG{+w}{        }\PYG{n}{uchartemp}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{//如果这个位是1，35us后，还是1，否则为0}
\PYG{+w}{        }\PYG{k}{if}\PYG{p}{(}\PYG{n}{getData}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{+w}{          }\PYG{n}{uchartemp}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ucharFLAG}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{//等待IO口变高，变高后，表示可以读取下一位}
\PYG{+w}{        }\PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{n}{getData}\PYG{p}{(}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{ucharFLAG}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{+w}{          }\PYG{n}{ets\PYGZus{}delay\PYGZus{}us}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{p}{(}\PYG{n}{ucharFLAG}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{+w}{          }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ucharcomdata}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ucharcomdata}\PYG{o}{|}\PYG{o}{=}\PYG{n}{uchartemp}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
逐个字节读取并返回值

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{getData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{c+c1}{//表示传感器拉低总线}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ucharFLAG}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{//等待总线被传感器拉高}
\PYG{+w}{        }\PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{o}{!}\PYG{n}{getData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{ucharFLAG}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{+w}{          }\PYG{n}{ets\PYGZus{}delay\PYGZus{}us}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ucharFLAG}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{//等待总线被传感器拉低}
\PYG{+w}{        }\PYG{k}{while}\PYG{p}{(}\PYG{p}{(}\PYG{n}{getData}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{n}{ucharFLAG}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{+w}{          }\PYG{n}{ets\PYGZus{}delay\PYGZus{}us}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{COM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//读取第1字节，}
\PYG{+w}{        }\PYG{n}{ucharRH\PYGZus{}data\PYGZus{}H\PYGZus{}temp}\PYG{o}{=}\PYG{n}{ucharcomdata}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{COM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//读取第2字节，}
\PYG{+w}{        }\PYG{n}{ucharRH\PYGZus{}data\PYGZus{}L\PYGZus{}temp}\PYG{o}{=}\PYG{n}{ucharcomdata}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{COM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//读取第3字节，}
\PYG{+w}{        }\PYG{n}{ucharT\PYGZus{}data\PYGZus{}H\PYGZus{}temp}\PYG{o}{=}\PYG{n}{ucharcomdata}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{COM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//读取第4字节，}
\PYG{+w}{        }\PYG{n}{ucharT\PYGZus{}data\PYGZus{}L\PYGZus{}temp}\PYG{o}{=}\PYG{n}{ucharcomdata}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{COM}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//读取第5字节，}
\PYG{+w}{        }\PYG{n}{ucharcheckdata\PYGZus{}temp}\PYG{o}{=}\PYG{n}{ucharcomdata}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{OutputHigh}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{//判断校验和是否一致}
\PYG{+w}{        }\PYG{n}{uchartemp}\PYG{o}{=}\PYG{p}{(}\PYG{n}{ucharT\PYGZus{}data\PYGZus{}H\PYGZus{}temp}\PYG{o}{+}\PYG{n}{ucharT\PYGZus{}data\PYGZus{}L\PYGZus{}temp}\PYG{o}{+}\PYG{n}{ucharRH\PYGZus{}data\PYGZus{}H\PYGZus{}temp}\PYG{o}{+}\PYG{n}{ucharRH\PYGZus{}data\PYGZus{}L\PYGZus{}temp}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{p}{(}\PYG{n}{uchartemp}\PYG{o}{=}\PYG{o}{=}\PYG{n}{ucharcheckdata\PYGZus{}temp}\PYG{p}{)}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{//校验和一致，}
\PYG{+w}{            }\PYG{n}{ucharRH\PYGZus{}data\PYGZus{}H}\PYG{o}{=}\PYG{n}{ucharRH\PYGZus{}data\PYGZus{}H\PYGZus{}temp}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{ucharRH\PYGZus{}data\PYGZus{}L}\PYG{o}{=}\PYG{n}{ucharRH\PYGZus{}data\PYGZus{}L\PYGZus{}temp}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{ucharT\PYGZus{}data\PYGZus{}H}\PYG{o}{=}\PYG{n}{ucharT\PYGZus{}data\PYGZus{}H\PYGZus{}temp}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{ucharT\PYGZus{}data\PYGZus{}L}\PYG{o}{=}\PYG{n}{ucharT\PYGZus{}data\PYGZus{}L\PYGZus{}temp}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{ucharcheckdata}\PYG{o}{=}\PYG{n}{ucharcheckdata\PYGZus{}temp}\PYG{p}{;}
\PYG{+w}{            }\PYG{c+c1}{//保存温度和湿度}
\PYG{+w}{            }\PYG{n}{Humi}\PYG{o}{=}\PYG{n}{ucharRH\PYGZus{}data\PYGZus{}H}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{Humi\PYGZus{}small}\PYG{o}{=}\PYG{n}{ucharRH\PYGZus{}data\PYGZus{}L}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{Temp}\PYG{o}{=}\PYG{n}{ucharT\PYGZus{}data\PYGZus{}H}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{Temp\PYGZus{}small}\PYG{o}{=}\PYG{n}{ucharT\PYGZus{}data\PYGZus{}L}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{else}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{          }\PYG{n}{Humi}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{;}
\PYG{+w}{          }\PYG{n}{Temp}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{else}\PYG{+w}{ }\PYG{c+c1}{//没用成功读取，返回0}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{    	}\PYG{n}{Humi}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}
\PYG{+w}{    	}\PYG{n}{Temp}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{实验内容}
\label{\detokenize{exp-esp32/peripherals/dht11:id5}}

\subparagraph{源代码参考}
\label{\detokenize{exp-esp32/peripherals/dht11:id6}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}


\subparagraph{硬件链接}
\label{\detokenize{exp-esp32/peripherals/dht11:id7}}\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP32 开发板、microUSB 线、电脑。

\item {} 
\sphinxAtStartPar
将 DHT11 传感器通过杜邦线连接到开发板上。

\end{itemize}

\sphinxAtStartPar
注意传感器插入方向，不要插反！！！


\subparagraph{代码调试}
\label{\detokenize{exp-esp32/peripherals/dht11:id8}}
\sphinxAtStartPar
使用 idf.py 以及 clion 管理项目，编码，build, flash

\sphinxAtStartPar
打开串口调试器，将会收到读取到的温湿度信息
\begin{quote}

\sphinxAtStartPar
❗ 注意：是串口调试器！不是\sphinxcode{\sphinxupquote{monitor}}！
\end{quote}

\sphinxAtStartPar
您将从串口调试器收到以下输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{Temp}\PYG{o}{=}\PYG{l+m}{25}.6d℃\PYGZhy{}\PYGZhy{}Humi\PYG{o}{=}\PYG{l+m}{60}.3\PYGZpc{}RH
\PYG{n+nv}{Temp}\PYG{o}{=}\PYG{l+m}{25}.6d℃\PYGZhy{}\PYGZhy{}Humi\PYG{o}{=}\PYG{l+m}{60}.3\PYGZpc{}RH
\PYG{n+nv}{Temp}\PYG{o}{=}\PYG{l+m}{25}.9d℃\PYGZhy{}\PYGZhy{}Humi\PYG{o}{=}\PYG{l+m}{61}.4\PYGZpc{}RH
\PYG{n+nv}{Temp}\PYG{o}{=}\PYG{l+m}{25}.9d℃\PYGZhy{}\PYGZhy{}Humi\PYG{o}{=}\PYG{l+m}{61}.4\PYGZpc{}RH
\PYG{n+nv}{Temp}\PYG{o}{=}\PYG{l+m}{25}.6d℃\PYGZhy{}\PYGZhy{}Humi\PYG{o}{=}\PYG{l+m}{61}.4\PYGZpc{}RH
\PYG{n+nv}{Temp}\PYG{o}{=}\PYG{l+m}{25}.6d℃\PYGZhy{}\PYGZhy{}Humi\PYG{o}{=}\PYG{l+m}{60}.3\PYGZpc{}RH
\PYG{n+nv}{Temp}\PYG{o}{=}\PYG{l+m}{25}.6d℃\PYGZhy{}\PYGZhy{}Humi\PYG{o}{=}\PYG{l+m}{60}.3\PYGZpc{}RH
\end{sphinxVerbatim}

\sphinxstepscope


\subsubsection{光照传感器采集}
\label{\detokenize{exp-esp32/peripherals/light:id1}}\label{\detokenize{exp-esp32/peripherals/light::doc}}
\sphinxstepscope


\subsubsection{手势识别}
\label{\detokenize{exp-esp32/peripherals/gesture:id1}}\label{\detokenize{exp-esp32/peripherals/gesture::doc}}
\sphinxstepscope


\section{BlueTooth 蓝牙}
\label{\detokenize{exp-esp32/bluetooth/index:bluetooth}}\label{\detokenize{exp-esp32/bluetooth/index::doc}}

\subsection{实验内容}
\label{\detokenize{exp-esp32/bluetooth/index:id1}}
\sphinxAtStartPar
本节包含如下实验内容：

\sphinxstepscope


\subsubsection{BluFi 配网实验}
\label{\detokenize{exp-esp32/bluetooth/blufi:blufi}}\label{\detokenize{exp-esp32/bluetooth/blufi::doc}}

\paragraph{什么是 BluFi}
\label{\detokenize{exp-esp32/bluetooth/blufi:id1}}
\sphinxAtStartPar
BluFi 是一款移动 APP，是一种基于蓝牙通道的 Wi\sphinxhyphen{}Fi 网络配置工具，适用于 ESP32。

\sphinxAtStartPar
它通过安全协议将 Wi\sphinxhyphen{}Fi 的 SSID、密码等配置信息传输到 ESP32，然后 ESP32 可基于这些信息连接到 AP 或建立 SoftAP。


\subparagraph{App 获取}
\label{\detokenize{exp-esp32/bluetooth/blufi:app}}
\sphinxAtStartPar
Blufi 是完全开源的 app，可通过如下方式装到手机：
\begin{itemize}
\item {} 
\sphinxAtStartPar
Andriod：\sphinxhref{https://github.com/EspressifApp/EspBlufiForAndroid/releases}{下载} APK 到手机安装

\item {} 
\sphinxAtStartPar
Ios：在 app store 中搜索 \sphinxcode{\sphinxupquote{espbluefi}} 并安装

\end{itemize}


\subparagraph{BluFi 配网流程}
\label{\detokenize{exp-esp32/bluetooth/blufi:id2}}
\sphinxAtStartPar
BluFi 配网功能包含配置 SoftAP 和 Station 两部分。其中关键部分包括：数据的分片、加密、校验和验证。

\sphinxAtStartPar
下面以配置 \sphinxcode{\sphinxupquote{Station}} 为例说明配置步骤。包含：广播、连接、服务发现、协商共享密钥、传输数据、回传连接状态等步骤。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
ESP32 开启 \sphinxcode{\sphinxupquote{GATT Server}} 模式，发送带有特定 \sphinxcode{\sphinxupquote{advertising data}} 的广播。你可以自定义该广播，该广播不属于 BluFi Profile。

\item {} 
\sphinxAtStartPar
使用手机 APP 搜索到该特定广播，手机作为 \sphinxcode{\sphinxupquote{GATT Client}} 连接 ESP32。你可以决定使用哪款手机 APP。

\item {} 
\sphinxAtStartPar
GATT 连接建立成功后，手机会向 ESP32 发送数据帧进行密钥协商（详情见 BluFi 中定义的帧格式 ）。

\item {} 
\sphinxAtStartPar
ESP32 收到密钥协商的数据帧后，会按照使用者自定义的协商方法来解析。

\item {} 
\sphinxAtStartPar
手机与 ESP32 进行密钥协商。协商过程可使用 DH/RSA/ECC 等加密算法。

\item {} 
\sphinxAtStartPar
协商结束后，手机端向 ESP32 发送控制帧，用于设置安全模式。

\item {} 
\sphinxAtStartPar
ESP32 收到控制帧后，使用共享密钥以及安全配置对通信数据进行加密和解密。

\item {} 
\sphinxAtStartPar
手机向 ESP32 发送 BluFi 中定义的帧格式 中定义的数据帧，包括 SSID、密码等 Wi\sphinxhyphen{}Fi 配置信息。

\item {} 
\sphinxAtStartPar
手机向 ESP32 发送 Wi\sphinxhyphen{}Fi 连接请求的控制帧。ESP32 收到这个控制帧之后，会认为手机已将必要的信息已经传输完毕，准备连接 Wi\sphinxhyphen{}Fi。

\item {} 
\sphinxAtStartPar
ESP32 连接到 Wi\sphinxhyphen{}Fi 后，发送 Wi\sphinxhyphen{}Fi 连接状态报告的控制帧到手机，以报告连接状态。至此配网结束。

\end{enumerate}
\begin{quote}

\sphinxAtStartPar
❗ 注解

\sphinxAtStartPar
ESP32 收到安全模式配置的控制帧后，会根据定义的安全模式进行相关操作。

\sphinxAtStartPar
进行对称加密和解密时，加密和解密前后的数据长度必须一致，支持原地加密和解密。
\end{quote}

\sphinxAtStartPar
下图为 bluefi 配网流程图：

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801111604055}.png}


\subparagraph{API 介绍}
\label{\detokenize{exp-esp32/bluetooth/blufi:api}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}t}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}blufi\PYGZus{}register\PYGZus{}callbacks}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}blufi\PYGZus{}callbacks\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{callbacks}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
调用该函数接收 blufi 回调事件。

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP\_OK \sphinxhyphen{} 成功，其他 \sphinxhyphen{} 失败

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}in{]} callbacks: 回调函数

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}t}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}blufi\PYGZus{}profile\PYGZus{}init}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
调用此函数来初始化 blufi\_profile。

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP\_OK \sphinxhyphen{} 成功，其他 \sphinxhyphen{} 失败

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}t}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}blufi\PYGZus{}profile\PYGZus{}deinit}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
调用此函数以取消初始化 blufi\_profile。

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP\_OK \sphinxhyphen{} 成功，其他 \sphinxhyphen{} 失败

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}t}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}blufi\PYGZus{}send\PYGZus{}wifi\PYGZus{}conn\PYGZus{}report}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{wifi\PYGZus{}mode\PYGZus{}t}\PYG{+w}{ }\PYG{n}{opmode}\PYG{+w}{ }\PYG{p}{,}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}blufi\PYGZus{}sta\PYGZus{}conn\PYGZus{}state\PYGZus{}t}\PYG{+w}{ }\PYG{n}{sta\PYGZus{}conn\PYGZus{}state}\PYG{+w}{ }\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{softap\PYGZus{}conn\PYGZus{}num}\PYG{+w}{ }\PYG{p}{,}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}blufi\PYGZus{}extra\PYGZus{}info\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{extra\PYGZus{}info}\PYG{+w}{ }\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
调用此函数以发送 wifi 连接报告。

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP\_OK \sphinxhyphen{} 成功，其他 \sphinxhyphen{} 失败

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
opmode: : wifi 操作模式

\item {} 
\sphinxAtStartPar
sta\_conn\_state: : 站是否已经连接

\item {} 
\sphinxAtStartPar
softap\_conn\_num: : softap 连接数

\item {} 
\sphinxAtStartPar
extra\_info:: 额外信息，如 sta\_ssid、softap\_ssid 等。

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}t}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}blufi\PYGZus{}send\PYGZus{}wifi\PYGZus{}list}\PYG{p}{(}\PYG{+w}{ }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{apCount}\PYG{+w}{ }\PYG{p}{,}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}blufi\PYGZus{}ap\PYGZus{}record\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{list}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
调用此函数发送 wifi 列表。

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP\_OK \sphinxhyphen{} 成功，其他 \sphinxhyphen{} 失败

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
apCount:: wifi 列表计数

\item {} 
\sphinxAtStartPar
list: : 无线网络列表

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}blufi\PYGZus{}get\PYGZus{}version}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
获取 BLUFI 配置文件版本。

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
最高 8 位为大版本，最低 8 位为子版本

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}tesp\PYGZus{}blufi\PYGZus{}send\PYGZus{}error\PYGZus{}info}\PYG{p}{(}\PYG{n}{esp\PYGZus{}blufi\PYGZus{}error\PYGZus{}state\PYGZus{}tstate}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
调用此函数以发送 blufi 错误信息。

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP\_OK \sphinxhyphen{} 成功，其他 \sphinxhyphen{} 失败

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
state:: 错误状态

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}tesp\PYGZus{}blufi\PYGZus{}send\PYGZus{}custom\PYGZus{}data}\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{uint32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{data\PYGZus{}len}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
调用此函数来自定义数据。

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP\_OK \sphinxhyphen{} 成功，其他 \sphinxhyphen{} 失败

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
data:: 自定义数据值

\item {} 
\sphinxAtStartPar
data\_len:: 自定义数据的长度

\end{itemize}


\subparagraph{关键代码解释}
\label{\detokenize{exp-esp32/bluetooth/blufi:id3}}
\sphinxAtStartPar
在我们的示例代码中，主要分为 3 个部分
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
WIFI 部分事件处理

\sphinxAtStartPar
主要负责 WIFI 的连接、断开重连、扫描

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{wifi\PYGZus{}event\PYGZus{}handler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}event\PYGZus{}base\PYGZus{}t}\PYG{+w}{ }\PYG{n}{event\PYGZus{}base}\PYG{p}{,}
\PYG{+w}{                                }\PYG{k+kt}{int32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{event\PYGZus{}id}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{event\PYGZus{}data}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
NETIF 部分事件处理
获取网络 IP 地址，完成 IP 接口搭建（默认 IO 口）；

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{ip\PYGZus{}event\PYGZus{}handler}\PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{arg}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}event\PYGZus{}base\PYGZus{}t}\PYG{+w}{ }\PYG{n}{event\PYGZus{}base}\PYG{p}{,}
\PYG{+w}{                                }\PYG{k+kt}{int32\PYGZus{}t}\PYG{+w}{ }\PYG{n}{event\PYGZus{}id}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{event\PYGZus{}data}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
BLUFI 配网部分事件处理

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{example\PYGZus{}event\PYGZus{}callback}\PYG{p}{(}\PYG{n}{esp\PYGZus{}blufi\PYGZus{}cb\PYGZus{}event\PYGZus{}t}\PYG{+w}{ }\PYG{n}{event}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}blufi\PYGZus{}cb\PYGZus{}param\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{param}\PYG{p}{)}
\end{sphinxVerbatim}

\end{enumerate}


\paragraph{实验内容}
\label{\detokenize{exp-esp32/bluetooth/blufi:id4}}
\sphinxAtStartPar
本实验展示了如何使用 Blufi 进行 AP 与 ESP32 的 Wi\sphinxhyphen{}Fi 连接配置。


\subparagraph{软硬件需求}
\label{\detokenize{exp-esp32/bluetooth/blufi:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{exp-esp32/bluetooth/blufi:getapp}]{\sphinxcrossref{\DUrole{xref,myst}{bluefi app}}}}

\item {} 
\sphinxAtStartPar
智能手机

\item {} 
\sphinxAtStartPar
ESP32 开发板

\item {} 
\sphinxAtStartPar
USB 线

\end{itemize}


\subparagraph{源代码参考}
\label{\detokenize{exp-esp32/bluetooth/blufi:id6}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}


\subparagraph{配置目标}
\label{\detokenize{exp-esp32/bluetooth/blufi:id7}}
\sphinxAtStartPar
需要配置目标芯片为 ESP32

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{idf}\PYG{o}{.}\PYG{n}{py} \PYG{n+nb}{set}\PYG{o}{\PYGZhy{}}\PYG{n}{target} \PYG{n}{esp32}
\end{sphinxVerbatim}


\subparagraph{构建和烧录}
\label{\detokenize{exp-esp32/bluetooth/blufi:id8}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：

\sphinxAtStartPar
\sphinxstylestrong{命令行界面：}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
idf.py \PYGZhy{}p PORT flash monitor
\PYG{c+c1}{\PYGZsh{}（要退出串行监视器，请键入Ctrl\PYGZhy{}]。）}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Clion 界面：}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
选择 flash 并运行
选择 monitor 并运行
\end{sphinxVerbatim}


\subparagraph{示例输出}
\label{\detokenize{exp-esp32/bluetooth/blufi:id9}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} \subsubsection*{烧录代码后会有以下输出：}

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{751}\PYG{o}{)} wifi\PYGZus{}init: WiFi IRAM OP enabled
I \PYG{o}{(}\PYG{l+m}{751}\PYG{o}{)} wifi\PYGZus{}init: WiFi RX IRAM OP enabled
I \PYG{o}{(}\PYG{l+m}{761}\PYG{o}{)} phy\PYGZus{}init: phy\PYGZus{}version \PYG{l+m}{4670},719f9f6,Feb \PYG{l+m}{18} \PYG{l+m}{2021},17:07:07
W \PYG{o}{(}\PYG{l+m}{931}\PYG{o}{)} phy\PYGZus{}init: saving new calibration data because of checksum failure, mode\PYG{o}{(}\PYG{l+m}{0}\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{951}\PYG{o}{)} wifi:mode : sta \PYG{o}{(}\PYG{l+m}{30}:ae:a4:cc:3f:7c\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{951}\PYG{o}{)} wifi:enable tsf
I \PYG{o}{(}\PYG{l+m}{951}\PYG{o}{)} BTDM\PYGZus{}INIT: BT controller compile version \PYG{o}{[}5688ed5\PYG{o}{]}
I \PYG{o}{(}\PYG{l+m}{1241}\PYG{o}{)} BLUFI\PYGZus{}EXAMPLE: BD ADDR: \PYG{l+m}{30}:ae:a4:cc:3f:7e

I \PYG{o}{(}\PYG{l+m}{1251}\PYG{o}{)} BLUFI\PYGZus{}EXAMPLE: BLUFI init finish

I \PYG{o}{(}\PYG{l+m}{1251}\PYG{o}{)} BLUFI\PYGZus{}EXAMPLE: BLUFI VERSION \PYG{l+m}{0102}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
手机端会有类似如下的设备出现：

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801153117381}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
点击属于自己的设备，然后点击连接会有如下界面：

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801153346393}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
点击下方配网，会有如下界面，选择连接的 WiFi 并输入密码点确定即自动返回主界面配网

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801153818161}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
若配网成功，APP 端会有类似如下的信息：

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220801153859463}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
\sphinxAtStartPar
IDE 的监视器会有类似如下输出：

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{1273}\PYG{o}{)} wifi:AP\PYG{l+s+s1}{\PYGZsq{}s beacon interval = 102400 us, DTIM period = 1}
\PYG{l+s+s1}{I (2183) esp\PYGZus{}netif\PYGZus{}handlers: sta ip: 192.168.50.57, mask: 255.255.255.0, gw: 192.168.50.1}
\PYG{l+s+s1}{I (2183) BLUFI\PYGZus{}EXAMPLE: BLUFI BLE is not connected yet}

\PYG{l+s+s1}{I (13553) BLUFI\PYGZus{}EXAMPLE: BLUFI ble connect}

\PYG{l+s+s1}{I (18963) BLUFI\PYGZus{}EXAMPLE: BLUFI Set WIFI opmode 1}

\PYG{l+s+s1}{I (19053) BLUFI\PYGZus{}EXAMPLE: Recv STA SSID RT\PYGZhy{}AX82U}

\PYG{l+s+s1}{I (19083) BLUFI\PYGZus{}EXAMPLE: Recv STA PASSWORD fro12345}

\PYG{l+s+s1}{I (19083) BLUFI\PYGZus{}EXAMPLE: BLUFI requset wifi connect to AP}

\PYG{l+s+s1}{I (19083) wifi:state: run \PYGZhy{}\PYGZgt{} init (0)}
\PYG{l+s+s1}{I (19083) wifi:pm stop, total sleep time: 15617342 us / 17897403 us}

\PYG{l+s+s1}{W (19093) wifi:\PYGZlt{}ba\PYGZhy{}del\PYGZgt{}idx}
\PYG{l+s+s1}{I (19093) wifi:new:\PYGZlt{}8,0\PYGZgt{}, old:\PYGZlt{}8,0\PYGZgt{}, ap:\PYGZlt{}255,255\PYGZgt{}, sta:\PYGZlt{}8,0\PYGZgt{}, prof:1}
\PYG{l+s+s1}{E (19103) wifi:sta is connecting, return error}
\PYG{l+s+s1}{I (19193) wifi:new:\PYGZlt{}8,0\PYGZgt{}, old:\PYGZlt{}8,0\PYGZgt{}, ap:\PYGZlt{}255,255\PYGZgt{}, sta:\PYGZlt{}8,0\PYGZgt{}, prof:1}
\PYG{l+s+s1}{I (19193) wifi:state: init \PYGZhy{}\PYGZgt{} auth (b0)}
\PYG{l+s+s1}{I (19193) wifi:state: auth \PYGZhy{}\PYGZgt{} assoc (0)}
\PYG{l+s+s1}{I (19203) wifi:state: assoc \PYGZhy{}\PYGZgt{} run (10)}
\PYG{l+s+s1}{I (19223) wifi:connected with RT\PYGZhy{}AX82U, aid = 19, channel 8, BW20, bssid = f0:2f:74:5d:fe:a8}
\PYG{l+s+s1}{I (19233) wifi:security: WPA2\PYGZhy{}PSK, phy: bgn, rssi: \PYGZhy{}50}
\PYG{l+s+s1}{I (19243) wifi:pm start, type: 1}

\PYG{l+s+s1}{W (19253) wifi:\PYGZlt{}ba\PYGZhy{}add\PYGZgt{}idx:0 (ifx:0, f0:2f:74:5d:fe:a8), tid:6, ssn:0, winSize:64}
\PYG{l+s+s1}{I (19293) wifi:AP\PYGZsq{}}s beacon \PYG{n+nv}{interval} \PYG{o}{=} \PYG{l+m}{102400} us, DTIM \PYG{n+nv}{period} \PYG{o}{=} \PYG{l+m}{1}
I \PYG{o}{(}\PYG{l+m}{20183}\PYG{o}{)} esp\PYGZus{}netif\PYGZus{}handlers: sta ip: \PYG{l+m}{192}.168.50.57, mask: \PYG{l+m}{255}.255.255.0, gw: \PYG{l+m}{192}.168.50.1
W \PYG{o}{(}\PYG{l+m}{21043}\PYG{o}{)} wifi:\PYGZlt{}ba\PYGZhy{}add\PYGZgt{}idx:1 \PYG{o}{(}ifx:0, f0:2f:74:5d:fe:a8\PYG{o}{)}, tid:0, ssn:0, winSize:64
\end{sphinxVerbatim}

\sphinxstepscope


\subsubsection{BT HCI主机控制接口}
\label{\detokenize{exp-esp32/bluetooth/hci:bt-hci}}\label{\detokenize{exp-esp32/bluetooth/hci::doc}}
\sphinxAtStartPar
BlueTooth 的HCI(主机控制接口)包括三种类型控制接口：
\begin{itemize}
\item {} 
\sphinxAtStartPar
通过UART使用HCI

\item {} 
\sphinxAtStartPar
通过virtual HCI 层使用HCI

\item {} 
\sphinxAtStartPar
混合方式

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{本实验使用最基础的UART方式}


\paragraph{UART HCI 控制器}
\label{\detokenize{exp-esp32/bluetooth/hci:uart-hci}}
\sphinxAtStartPar
这使用 UART 作为 HCI 控制器，这要求 UART 设备强制支持 RTS/CTS。

\sphinxAtStartPar
可以通过 \sphinxcode{\sphinxupquote{idf.py menuconfig}} 来配置串口号和串口波特率。


\subparagraph{源代码参考}
\label{\detokenize{exp-esp32/bluetooth/hci:id1}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}


\subparagraph{UART分配}
\label{\detokenize{exp-esp32/bluetooth/hci:uart}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UART0}} 用作正常输出或由 IDF 监视器使用

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UART1}} 或 \sphinxcode{\sphinxupquote{UART2}} 用于传送 HCI 消息

\sphinxAtStartPar
需要 \sphinxcode{\sphinxupquote{UART1}} 或 \sphinxcode{\sphinxupquote{UART2}} 的 \sphinxcode{\sphinxupquote{RTS}} 和 \sphinxcode{\sphinxupquote{CTS}} 线。引脚 5、18、23、19 分别用作 \sphinxcode{\sphinxupquote{UART1}} 或 \sphinxcode{\sphinxupquote{UART2}} 的 \sphinxcode{\sphinxupquote{TxD}}、\sphinxcode{\sphinxupquote{RxD}}、\sphinxcode{\sphinxupquote{CTS}}、\sphinxcode{\sphinxupquote{RTS}} 引脚。


\paragraph{实验步骤}
\label{\detokenize{exp-esp32/bluetooth/hci:id2}}

\subparagraph{配置项目}
\label{\detokenize{exp-esp32/bluetooth/hci:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
idf.py menuconfig
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UART}}编号配置：\sphinxcode{\sphinxupquote{HCI UART(H4) Options > UART Number for HCI}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UART}}波特率配置：\sphinxcode{\sphinxupquote{HCI UART(H4) Options > UART Baudrate for HCI}}


\subparagraph{构建和烧录}
\label{\detokenize{exp-esp32/bluetooth/hci:id4}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：


\subparagraph{命令行界面：}
\label{\detokenize{exp-esp32/bluetooth/hci:id5}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
idf.py \PYGZhy{}p PORT flash monitor 
\end{sphinxVerbatim}

\sphinxAtStartPar
（要退出串行监视器，请键入Ctrl\sphinxhyphen{}{]}。）


\subparagraph{Clion界面：}
\label{\detokenize{exp-esp32/bluetooth/hci:clion}}
\sphinxAtStartPar
选择 flash 并运行

\sphinxAtStartPar
选择 monitor 并运行


\subparagraph{示例输出}
\label{\detokenize{exp-esp32/bluetooth/hci:id6}}
\sphinxAtStartPar
该示例重置 HCI UART 传输并启用蓝牙控制器。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{442}\PYG{o}{)} CONTROLLER\PYGZus{}UART\PYGZus{}HCI: HCI UART1 Pin \PYG{k}{select}: TX \PYG{l+m}{5}, RX \PYG{l+m}{18}, CTS \PYG{l+m}{23}, RTS \PYG{l+m}{19}
I \PYG{o}{(}\PYG{l+m}{442}\PYG{o}{)} BTDM\PYGZus{}INIT: BT controller compile version \PYG{o}{[}078d492\PYG{o}{]}
I \PYG{o}{(}\PYG{l+m}{452}\PYG{o}{)} system\PYGZus{}api: Base MAC address is not \PYG{n+nb}{set}
I \PYG{o}{(}\PYG{l+m}{452}\PYG{o}{)} system\PYGZus{}api: \PYG{n+nb}{read} default base MAC address from EFUSE
I \PYG{o}{(}\PYG{l+m}{462}\PYG{o}{)} phy\PYGZus{}init: phy\PYGZus{}version \PYG{l+m}{4670},719f9f6,Feb \PYG{l+m}{18} \PYG{l+m}{2021},17:07:07
\end{sphinxVerbatim}

\sphinxAtStartPar
在这些输出发生后，HCI 消息可以通过 \sphinxcode{\sphinxupquote{UART1}} 或 \sphinxcode{\sphinxupquote{UART2}} 进行通信。（本例中为 \sphinxcode{\sphinxupquote{UART1}}）

\sphinxstepscope


\subsubsection{基于GAP的BLE HID人机接口}
\label{\detokenize{exp-esp32/bluetooth/hid-gap:gapble-hid}}\label{\detokenize{exp-esp32/bluetooth/hid-gap::doc}}

\paragraph{实验内容}
\label{\detokenize{exp-esp32/bluetooth/hid-gap:id1}}
\sphinxAtStartPar
本次实验的内容验证基于GAP协议的HID人机接口。实验分为两大部分：
\begin{itemize}
\item {} 
\sphinxAtStartPar
BLE HID Device共有两个内容：
\begin{itemize}
\item {} 
\sphinxAtStartPar
以PC机为HOST，BLE HID Device连接后充当鼠标

\item {} 
\sphinxAtStartPar
连接到下面提到的BLE HID Host，充当无线遥控器。

\end{itemize}

\item {} 
\sphinxAtStartPar
BLE HID Host

\sphinxAtStartPar
充当BLE HID Host，与BLE HID Device配合使用，接收无线遥控器输入

\end{itemize}


\paragraph{GAP简介}
\label{\detokenize{exp-esp32/bluetooth/hid-gap:gap}}
\sphinxAtStartPar
蓝牙是⼀种短距通信系统，其关键特性包括鲁棒性、低功耗、低成本等。蓝牙系统分为两种不同的技术：经典蓝牙 (Classic Bluetooth) 和蓝牙低功耗 (Bluetooth Low Energy)。
ESP32 支持\sphinxstylestrong{双模蓝牙}，即\sphinxstylestrong{同时支持经典蓝牙和蓝牙低功耗}。

\sphinxAtStartPar
从整体结构上，蓝牙可分为控制器 (Controller) 和主机 (Host) 两⼤部分：控制器包括了 PHY、Baseband、Link Controller、Link Manager、Device Manager、HCI 等模块，用于硬件接⼝管理、链路管理等等；主机则包括了 L2CAP、SMP、SDP、ATT、GATT、GAP 以及各种规范，构建了向应用层提供接口的基础，方便应用层对蓝牙系统的访问。主机可以与控制器运行在同⼀个宿主上，也可以分布在不同的宿主上。ESP32 可以支持上述两种方式。
\sphinxincludegraphics{{image-20220802135211110}.png}

\sphinxAtStartPar
LL(Link Layer) 位于最底层，负责广播通信有关功能的定义和实现，包括物理通道的选择、相关的链路状态的定义、PDU的定义、设备过滤(Device Filtering)机制的实现等。

\sphinxAtStartPar
HCI负责将LL提供的所有功能，以Command/Event的形式抽象出来，供Host使用。

\sphinxAtStartPar
GAP负责从应用程序的角度，抽象并封装LL提供的功能，以便让应用以比较傻瓜的方式进行广播通信。当然，这不是必须的，也就是说，我们也可以在没有GAP参与的情况下，进行广播通信。

\sphinxAtStartPar
广播通信相关的协议层次 GAP>HCI>Link Layer。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220802134835763}.png}


\paragraph{BLE HID Device}
\label{\detokenize{exp-esp32/bluetooth/hid-gap:ble-hid-device}}
\sphinxAtStartPar
该演示使用 esp\_hid 组件提供的 API 来创建 BT、BLE 或蓝牙双模隐藏设备。用户可以通过设置来选择模式HID\_DEV\_MODE。


\subparagraph{做为PC的ble鼠标}
\label{\detokenize{exp-esp32/bluetooth/hid-gap:pcble}}
\sphinxAtStartPar
将ESP32蓝牙与电脑相连接，蓝牙名为\sphinxcode{\sphinxupquote{ESP BT HID}}，此时BT HID设备充当鼠标。连接成功后，用户可以按照下面的方法在监视器中输入字母指令，可一次输入多个，操作“鼠标”。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
BT hid mouse demo usage:
You can input these value to simulate mouse: \PYG{l+s+s1}{\PYGZsq{}q\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}w\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}e\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}a\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}s\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}d\PYGZsq{}}, \PYG{l+s+s1}{\PYGZsq{}h\PYGZsq{}}
q \PYGZhy{}\PYGZhy{} click the left key
w \PYGZhy{}\PYGZhy{} move up
e \PYGZhy{}\PYGZhy{} click the right key
a \PYGZhy{}\PYGZhy{} move left
s \PYGZhy{}\PYGZhy{} move down
d \PYGZhy{}\PYGZhy{} move right
h \PYGZhy{}\PYGZhy{} show the \PYG{n+nb}{help}
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\end{sphinxVerbatim}


\subparagraph{BLE HID设备充当遥控器}
\label{\detokenize{exp-esp32/bluetooth/hid-gap:ble-hid}}
\sphinxAtStartPar
此示例需要与下面的BLE HID HOST示例配合使用

\sphinxAtStartPar
BLE HID设备充当遥控器。让其与另一个烧录了BLE HID host程序的ESP32自动连接，连接成功后，遥控器会定时调高和调低音量，可在监视器中看到输出数据。


\subparagraph{构建和烧录}
\label{\detokenize{exp-esp32/bluetooth/hid-gap:id2}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：

\sphinxAtStartPar
\sphinxstylestrong{命令行界面：}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idf.py \sphinxhyphen{}p PORT flash monitor}}

\sphinxAtStartPar
（要退出串行监视器，请键入Ctrl\sphinxhyphen{}{]}。）

\sphinxAtStartPar
\sphinxstylestrong{Clion界面：}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
选择 flash 并运行

\item {} 
\sphinxAtStartPar
选择 monitor 并运行

\end{enumerate}


\subparagraph{示例输出}
\label{\detokenize{exp-esp32/bluetooth/hid-gap:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{0}\PYG{o}{)} cpu\PYGZus{}start: Starting scheduler on APP CPU.
I \PYG{o}{(}\PYG{l+m}{607}\PYG{o}{)} BTDM\PYGZus{}INIT: BT controller compile version \PYG{o}{[}d03a5d3\PYG{o}{]}
I \PYG{o}{(}\PYG{l+m}{607}\PYG{o}{)} system\PYGZus{}api: Base MAC address is not \PYG{n+nb}{set}
I \PYG{o}{(}\PYG{l+m}{607}\PYG{o}{)} system\PYGZus{}api: \PYG{n+nb}{read} default base MAC address from EFUSE
I \PYG{o}{(}\PYG{l+m}{617}\PYG{o}{)} phy\PYGZus{}init: phy\PYGZus{}version \PYG{l+m}{4670},719f9f6,Feb \PYG{l+m}{18} \PYG{l+m}{2021},17:07:07
W \PYG{o}{(}\PYG{l+m}{1337}\PYG{o}{)} BT\PYGZus{}BTM: BTM\PYGZus{}BleWriteAdvData, Partial data write into ADV
I \PYG{o}{(}\PYG{l+m}{1357}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: START
I \PYG{o}{(}\PYG{l+m}{25067}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: CONNECT
I \PYG{o}{(}\PYG{l+m}{25357}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
E \PYG{o}{(}\PYG{l+m}{25437}\PYG{o}{)} BT\PYGZus{}SMP: Value \PYG{k}{for} numeric \PYG{n+nv}{comparison} \PYG{o}{=} \PYG{l+m}{125657}
I \PYG{o}{(}\PYG{l+m}{25437}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP NC\PYGZus{}REQ passkey:125657
W \PYG{o}{(}\PYG{l+m}{25517}\PYG{o}{)} BT\PYGZus{}SMP: FOR LE SC LTK IS USED INSTEAD OF STK
I \PYG{o}{(}\PYG{l+m}{25587}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP KEY \PYG{n+nb}{type} \PYG{o}{=} ESP\PYGZus{}LE\PYGZus{}KEY\PYGZus{}LENC
I \PYG{o}{(}\PYG{l+m}{25587}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP KEY \PYG{n+nb}{type} \PYG{o}{=} ESP\PYGZus{}LE\PYGZus{}KEY\PYGZus{}PENC
I \PYG{o}{(}\PYG{l+m}{25587}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP KEY \PYG{n+nb}{type} \PYG{o}{=} ESP\PYGZus{}LE\PYGZus{}KEY\PYGZus{}LID
I \PYG{o}{(}\PYG{l+m}{25647}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP KEY \PYG{n+nb}{type} \PYG{o}{=} ESP\PYGZus{}LE\PYGZus{}KEY\PYGZus{}PID
I \PYG{o}{(}\PYG{l+m}{25757}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP AUTH SUCCESS
I \PYG{o}{(}\PYG{l+m}{27457}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{29557}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{31657}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{33757}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{35857}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{37957}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{40057}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{42157}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{44257}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{46357}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{48457}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{50557}\PYG{o}{)} HID\PYGZus{}DEV\PYGZus{}DEMO: Send the volume
...
\end{sphinxVerbatim}


\paragraph{BLE HID Host}
\label{\detokenize{exp-esp32/bluetooth/hid-gap:ble-hid-host}}
\sphinxAtStartPar
该演示使用 \sphinxcode{\sphinxupquote{esp\_hid}} 组件提供的 API 创建蓝牙双模隐藏主机。程序启动后，HID 主机会扫描周围的蓝牙 HID 设备，并尝试连接上一个被扫描的设备。当连接建立成功后，HID 主机会转储 HID 设备信息，并可以接收 HID 设备发送的数据。

\sphinxAtStartPar
此示例与 \sphinxcode{\sphinxupquote{BLE HID Device}} 示例配合使用，需要两组配合完成。
\begin{itemize}
\item {} 
\sphinxAtStartPar
一组同学烧录主机

\item {} 
\sphinxAtStartPar
一组烧录设备进行验证

\end{itemize}


\subparagraph{构建和烧录}
\label{\detokenize{exp-esp32/bluetooth/hid-gap:id4}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：

\sphinxAtStartPar
\sphinxstylestrong{命令行界面：}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idf.py \sphinxhyphen{}p PORT flash monitor}} （要退出串行监视器，请键入Ctrl\sphinxhyphen{}{]}。）

\sphinxAtStartPar
\sphinxstylestrong{Clion界面：}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
选择 flash 并运行

\item {} 
\sphinxAtStartPar
选择 monitor 并运行

\end{enumerate}


\subparagraph{示例输出}
\label{\detokenize{exp-esp32/bluetooth/hid-gap:id5}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{0}\PYG{o}{)} cpu\PYGZus{}start: Starting scheduler on APP CPU.
I \PYG{o}{(}\PYG{l+m}{602}\PYG{o}{)} BTDM\PYGZus{}INIT: BT controller compile version \PYG{o}{[}d03a5d3\PYG{o}{]}
I \PYG{o}{(}\PYG{l+m}{612}\PYG{o}{)} system\PYGZus{}api: Base MAC address is not \PYG{n+nb}{set}
I \PYG{o}{(}\PYG{l+m}{612}\PYG{o}{)} system\PYGZus{}api: \PYG{n+nb}{read} default base MAC address from EFUSE
I \PYG{o}{(}\PYG{l+m}{612}\PYG{o}{)} phy\PYGZus{}init: phy\PYGZus{}version \PYG{l+m}{4670},719f9f6,Feb \PYG{l+m}{18} \PYG{l+m}{2021},17:07:07
I \PYG{o}{(}\PYG{l+m}{1332}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: SCAN...
I \PYG{o}{(}\PYG{l+m}{7212}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: SCAN: \PYG{l+m}{1} results
  BLE: fc:f5:c4:3c:62:92, RSSI: \PYGZhy{}29, USAGE: GENERIC, APPEARANCE: 0x03c0, ADDR\PYGZus{}TYPE: \PYG{l+s+s1}{\PYGZsq{}PUBLIC\PYGZsq{}}, NAME: ESP BLE HID2 
I \PYG{o}{(}\PYG{l+m}{7332}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP SEC\PYGZus{}REQ
E \PYG{o}{(}\PYG{l+m}{7702}\PYG{o}{)} BT\PYGZus{}SMP: Value \PYG{k}{for} numeric \PYG{n+nv}{comparison} \PYG{o}{=} \PYG{l+m}{125657}
I \PYG{o}{(}\PYG{l+m}{7702}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP NC\PYGZus{}REQ passkey:125657
W \PYG{o}{(}\PYG{l+m}{7742}\PYG{o}{)} BT\PYGZus{}SMP: FOR LE SC LTK IS USED INSTEAD OF STK
I \PYG{o}{(}\PYG{l+m}{7892}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP KEY \PYG{n+nb}{type} \PYG{o}{=} ESP\PYGZus{}LE\PYGZus{}KEY\PYGZus{}PID
I \PYG{o}{(}\PYG{l+m}{7892}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP KEY \PYG{n+nb}{type} \PYG{o}{=} ESP\PYGZus{}LE\PYGZus{}KEY\PYGZus{}LENC
I \PYG{o}{(}\PYG{l+m}{7892}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP KEY \PYG{n+nb}{type} \PYG{o}{=} ESP\PYGZus{}LE\PYGZus{}KEY\PYGZus{}PENC
I \PYG{o}{(}\PYG{l+m}{7892}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP KEY \PYG{n+nb}{type} \PYG{o}{=} ESP\PYGZus{}LE\PYGZus{}KEY\PYGZus{}LID
I \PYG{o}{(}\PYG{l+m}{8142}\PYG{o}{)} ESP\PYGZus{}HID\PYGZus{}GAP: BLE GAP AUTH SUCCESS
I \PYG{o}{(}\PYG{l+m}{9332}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: fc:f5:c4:3c:62:92 OPEN: ESP BLE HID2
BDA:fc:f5:c4:3c:62:92, Appearance: 0x03c0, Connection ID: \PYG{l+m}{0}
Name: ESP BLE HID2, Manufacturer: Espressif, Serial Number: \PYG{l+m}{1234567890}
PID: 0x05df, VID: 0x16c0, VERSION: 0x0100
Battery: Handle: \PYG{l+m}{42}, CCC Handle: \PYG{l+m}{43}
Report Maps: \PYG{l+m}{2}
  Report Map Length: \PYG{l+m}{38}
      VENDOR FEATURE REPORT, ID:  \PYG{l+m}{1}, Length:   \PYG{l+m}{8}, Permissions: 0x0a, Handle:  \PYG{l+m}{71}, CCC Handle:   \PYG{l+m}{0}
      VENDOR  OUTPUT REPORT, ID:  \PYG{l+m}{1}, Length:   \PYG{l+m}{8}, Permissions: 0x0a, Handle:  \PYG{l+m}{68}, CCC Handle:   \PYG{l+m}{0}
      VENDOR   INPUT REPORT, ID:  \PYG{l+m}{1}, Length:   \PYG{l+m}{8}, Permissions: 0x12, Handle:  \PYG{l+m}{64}, CCC Handle:  \PYG{l+m}{65}
  Report Map Length: \PYG{l+m}{111}
    CCONTROL   INPUT REPORT, ID:  \PYG{l+m}{3}, Length:   \PYG{l+m}{2}, Permissions: 0x12, Handle:  \PYG{l+m}{85}, CCC Handle:  \PYG{l+m}{86}
I \PYG{o}{(}\PYG{l+m}{9722}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: fc:f5:c4:3c:62:92 INPUT: CCONTROL, MAP:  \PYG{l+m}{1}, ID:   \PYG{l+m}{3}, Len: \PYG{l+m}{2}, Data:
I \PYG{o}{(}\PYG{l+m}{9722}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: \PYG{l+m}{40} \PYG{l+m}{00} 
I \PYG{o}{(}\PYG{l+m}{9812}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: fc:f5:c4:3c:62:92 INPUT: CCONTROL, MAP:  \PYG{l+m}{1}, ID:   \PYG{l+m}{3}, Len: \PYG{l+m}{2}, Data:
I \PYG{o}{(}\PYG{l+m}{9812}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: \PYG{l+m}{00} \PYG{l+m}{00} 
I \PYG{o}{(}\PYG{l+m}{11822}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: fc:f5:c4:3c:62:92 INPUT: CCONTROL, MAP:  \PYG{l+m}{1}, ID:   \PYG{l+m}{3}, Len: \PYG{l+m}{2}, Data:
I \PYG{o}{(}\PYG{l+m}{11822}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: \PYG{l+m}{80} \PYG{l+m}{00} 
I \PYG{o}{(}\PYG{l+m}{11912}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: fc:f5:c4:3c:62:92 INPUT: CCONTROL, MAP:  \PYG{l+m}{1}, ID:   \PYG{l+m}{3}, Len: \PYG{l+m}{2}, Data:
I \PYG{o}{(}\PYG{l+m}{11912}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: \PYG{l+m}{00} \PYG{l+m}{00} 
I \PYG{o}{(}\PYG{l+m}{13922}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: fc:f5:c4:3c:62:92 INPUT: CCONTROL, MAP:  \PYG{l+m}{1}, ID:   \PYG{l+m}{3}, Len: \PYG{l+m}{2}, Data:
I \PYG{o}{(}\PYG{l+m}{13922}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: \PYG{l+m}{40} \PYG{l+m}{00} 
I \PYG{o}{(}\PYG{l+m}{14012}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: fc:f5:c4:3c:62:92 INPUT: CCONTROL, MAP:  \PYG{l+m}{1}, ID:   \PYG{l+m}{3}, Len: \PYG{l+m}{2}, Data:
I \PYG{o}{(}\PYG{l+m}{14012}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: \PYG{l+m}{00} \PYG{l+m}{00} 
I \PYG{o}{(}\PYG{l+m}{16022}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: fc:f5:c4:3c:62:92 INPUT: CCONTROL, MAP:  \PYG{l+m}{1}, ID:   \PYG{l+m}{3}, Len: \PYG{l+m}{2}, Data:
I \PYG{o}{(}\PYG{l+m}{16022}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: \PYG{l+m}{80} \PYG{l+m}{00} 
I \PYG{o}{(}\PYG{l+m}{16112}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: fc:f5:c4:3c:62:92 INPUT: CCONTROL, MAP:  \PYG{l+m}{1}, ID:   \PYG{l+m}{3}, Len: \PYG{l+m}{2}, Data:
I \PYG{o}{(}\PYG{l+m}{16112}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: \PYG{l+m}{00} \PYG{l+m}{00} 
I \PYG{o}{(}\PYG{l+m}{18122}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: fc:f5:c4:3c:62:92 INPUT: CCONTROL, MAP:  \PYG{l+m}{1}, ID:   \PYG{l+m}{3}, Len: \PYG{l+m}{2}, Data:
I \PYG{o}{(}\PYG{l+m}{18122}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: \PYG{l+m}{40} \PYG{l+m}{00} 
I \PYG{o}{(}\PYG{l+m}{18212}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: fc:f5:c4:3c:62:92 INPUT: CCONTROL, MAP:  \PYG{l+m}{1}, ID:   \PYG{l+m}{3}, Len: \PYG{l+m}{2}, Data:
I \PYG{o}{(}\PYG{l+m}{18212}\PYG{o}{)} ESP\PYGZus{}HIDH\PYGZus{}DEMO: \PYG{l+m}{00} \PYG{l+m}{00} 
...
\end{sphinxVerbatim}


\paragraph{源代码参考}
\label{\detokenize{exp-esp32/bluetooth/hid-gap:id6}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}

\sphinxstepscope


\subsubsection{基于 GATT 的 BLE HID 设备}
\label{\detokenize{exp-esp32/bluetooth/hid-device-gatt:gatt-ble-hid}}\label{\detokenize{exp-esp32/bluetooth/hid-device-gatt::doc}}

\paragraph{实验目的}
\label{\detokenize{exp-esp32/bluetooth/hid-device-gatt:id1}}
\sphinxAtStartPar
本实验实现基于 GATT 的 BLEHID Device , 即 BLE 的设备模式。
\begin{quote}

\sphinxAtStartPar
❗ 注意

\sphinxAtStartPar
本实验需要 Android bluebird 协议栈支持，不支持非 Android 手机
\end{quote}


\paragraph{GATT BLE HID 介绍}
\label{\detokenize{exp-esp32/bluetooth/hid-device-gatt:id2}}
\sphinxAtStartPar
GATT（Generic Attributes Profile）的缩写，中文是通用属性协议，是已连接的低功耗蓝牙设备之间进行通信的协议。

\sphinxAtStartPar
一旦两个设备建立起了连接，GATT 就开始起作用了，这也意味着，你必需完成前面的 GAP 协议。

\sphinxAtStartPar
GATT 使用了 ATT（Attribute Protocol）协议，ATT 协议把 Service，Characteristic 对应的数据保存在一个查找表中，查找表使用 16bit ID 作为每一项的索引。

\sphinxAtStartPar
从 GATT 的角度来看，处于连接状态时的两个设备，它们各自充当两种角色中的一种：
\begin{itemize}
\item {} 
\sphinxAtStartPar
服务端（Server）

\end{itemize}

\sphinxAtStartPar
包含被 GATT 客户端读取或写入的特征数据的设备。
\begin{itemize}
\item {} 
\sphinxAtStartPar
客户端（Client）

\end{itemize}

\sphinxAtStartPar
从 GATT 服务器中读取数据或向 GATT 服务器写入数据的设备。

\sphinxAtStartPar
外围设备（从机）作为 GATT 服务端（Server），它维持了 ATT 的查找表以及 service 和 characteristic 的定义；

\sphinxAtStartPar
客户端和服务器的 GATT 角色独立于外围设备和中央设备的 GAP 角色。外围设备可以是 GATT 客户端或 GATT 服务器，中心可以是 GATT 客户端或 GATT 服务器。
\sphinxincludegraphics{{image-20220801162020208}.png}

\sphinxAtStartPar
在 ESP\sphinxhyphen{}IDF 中，使用经过大量修改后的 BLUEDROID 作为蓝牙主机 (Classic BT + BLE)。BLUEDROID 拥有较为完善的功能，⽀持常用的规范和架构设计，同时也较为复杂，所以在此不再赘述，感兴趣的同学可以前往乐鑫官网 ESP\sphinxhyphen{}IDF 编程指南 中查看。


\paragraph{实验内容}
\label{\detokenize{exp-esp32/bluetooth/hid-device-gatt:id3}}
\sphinxAtStartPar
本例实现了一个 BLE HID 设备配置文件相关功能，其中 HID 设备有 4 个类型：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
鼠标

\item {} 
\sphinxAtStartPar
键盘和 LED

\item {} 
\sphinxAtStartPar
消费类设备

\item {} 
\sphinxAtStartPar
供应商设备

\end{enumerate}

\sphinxAtStartPar
用户可以根据自己的应用场景选择不同的类型。BLE HID 配置文件继承和 USB HID 类。


\subparagraph{文件说明}
\label{\detokenize{exp-esp32/bluetooth/hid-device-gatt:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ble\_hidd\_demo\_main.c}} 此文件是演示如何使用 HID（您可以将其连接到智能手机充当消费设备，然后可以使用按钮来音量++或音量–等，或连接到 Windows 10 PC 行为作为键盘或鼠标）

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hidd\_le\_prf\_int.h}} 此头文件包含一些与 HID 配置文件相关的定义。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{esp\_hidd\_prf\_api.h}}\&\sphinxcode{\sphinxupquote{esp\_hidd\_prf\_api.c}} 这些文件包含 HID 配置文件的 api 当您使用 HID 配置文件时，您只需添加 esp\_hidd\_prf\_api.h 包含文件并使用 \sphinxcode{\sphinxupquote{esp\_hidd\_prf\_api.c}} 文件中定义的函数发送 HID 数据。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hid\_dev.h}} \& \sphinxcode{\sphinxupquote{hid\_dev.c}} 这些文件定义了 HID 规范相关的定义

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hid\_device\_le\_prf.c}} 该文件是 HID 配置文件定义文件，它包含了 HID 配置文件的主要功能。主要包括如何创建 HID 服务。如果您发送和接收 HID 数据并将数据转换为键盘键，则鼠标和使用者值将转发到应用程序。

\end{itemize}


\subparagraph{构建和烧录}
\label{\detokenize{exp-esp32/bluetooth/hid-device-gatt:id5}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：


\subparagraph{命令行界面：}
\label{\detokenize{exp-esp32/bluetooth/hid-device-gatt:id6}}
\sphinxAtStartPar
idf.py \sphinxhyphen{}p PORT flash monitor （要退出串行监视器，请键入 Ctrl\sphinxhyphen{}{]}。）


\subparagraph{Clion 界面：}
\label{\detokenize{exp-esp32/bluetooth/hid-device-gatt:clion}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
选择 flash 并运行

\item {} 
\sphinxAtStartPar
选择 monitor 并运行

\end{enumerate}


\paragraph{示例输出}
\label{\detokenize{exp-esp32/bluetooth/hid-device-gatt:id7}}
\sphinxAtStartPar
\sphinxstylestrong{假如此时将手机蓝牙连接至 esp32，esp32 将会去控制手机的音量增至最大和减小至最小}

\sphinxAtStartPar
监视器中会有类似如下输出:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{0}\PYG{o}{)} cpu\PYGZus{}start: Starting scheduler on APP CPU.
I \PYG{o}{(}\PYG{l+m}{584}\PYG{o}{)} BTDM\PYGZus{}INIT: BT controller compile version \PYG{o}{[}1342a48\PYG{o}{]}
I \PYG{o}{(}\PYG{l+m}{584}\PYG{o}{)} system\PYGZus{}api: Base MAC address is not \PYG{n+nb}{set}
I \PYG{o}{(}\PYG{l+m}{584}\PYG{o}{)} system\PYGZus{}api: \PYG{n+nb}{read} default base MAC address from EFUSE
I \PYG{o}{(}\PYG{l+m}{594}\PYG{o}{)} phy\PYGZus{}init: phy\PYGZus{}version \PYG{l+m}{4670},719f9f6,Feb \PYG{l+m}{18} \PYG{l+m}{2021},17:07:07
I \PYG{o}{(}\PYG{l+m}{1024}\PYG{o}{)} HID\PYGZus{}LE\PYGZus{}PRF: esp\PYGZus{}hidd\PYGZus{}prf\PYGZus{}cb\PYGZus{}hdl\PYG{o}{(}\PYG{o}{)}, start added the hid service to the stack database. \PYG{n+nv}{incl\PYGZus{}handle} \PYG{o}{=} \PYG{l+m}{40}
I \PYG{o}{(}\PYG{l+m}{1034}\PYG{o}{)} HID\PYGZus{}LE\PYGZus{}PRF: hid svc \PYG{n+nv}{handle} \PYG{o}{=} 2d
I \PYG{o}{(}\PYG{l+m}{5964}\PYG{o}{)} HID\PYGZus{}LE\PYGZus{}PRF: HID connection establish, \PYG{n+nv}{conn\PYGZus{}id} \PYG{o}{=} \PYG{l+m}{0}
I \PYG{o}{(}\PYG{l+m}{5964}\PYG{o}{)} HID\PYGZus{}DEMO: ESP\PYGZus{}HIDD\PYGZus{}EVENT\PYGZus{}BLE\PYGZus{}CONNECT
I \PYG{o}{(}\PYG{l+m}{6744}\PYG{o}{)} HID\PYGZus{}DEMO: remote BD\PYGZus{}ADDR: 7767f4abe386
I \PYG{o}{(}\PYG{l+m}{6744}\PYG{o}{)} HID\PYGZus{}DEMO: address \PYG{n+nb}{type} \PYG{o}{=} \PYG{l+m}{1}
I \PYG{o}{(}\PYG{l+m}{6744}\PYG{o}{)} HID\PYGZus{}DEMO: pair \PYG{n+nv}{status} \PYG{o}{=} success
I \PYG{o}{(}\PYG{l+m}{8024}\PYG{o}{)} HID\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{16024}\PYG{o}{)} HID\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{24024}\PYG{o}{)} HID\PYGZus{}DEMO: Send the volume
I \PYG{o}{(}\PYG{l+m}{27784}\PYG{o}{)} HID\PYGZus{}DEMO: ESP\PYGZus{}HIDD\PYGZus{}EVENT\PYGZus{}BLE\PYGZus{}DISCONNECT
\end{sphinxVerbatim}


\paragraph{源代码参考}
\label{\detokenize{exp-esp32/bluetooth/hid-device-gatt:id8}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}

\sphinxstepscope


\section{WiFi}
\label{\detokenize{exp-esp32/wifi/index:wifi}}\label{\detokenize{exp-esp32/wifi/index::doc}}
\sphinxAtStartPar
本节包含如下实验内容：

\sphinxstepscope


\subsection{Station 模式}
\label{\detokenize{exp-esp32/wifi/station:station}}\label{\detokenize{exp-esp32/wifi/station::doc}}

\subsubsection{实验目的}
\label{\detokenize{exp-esp32/wifi/station:id1}}
\sphinxAtStartPar
Station(基站)模式，又称 STA 模式或 Client 模式。

\sphinxAtStartPar
本实验目的是将 ESP32 设备连接到附近的 AP 接入点。


\subsubsection{内容详解}
\label{\detokenize{exp-esp32/wifi/station:id2}}

\paragraph{设置 WiFi 接入点参数}
\label{\detokenize{exp-esp32/wifi/station:wifi}}
\sphinxAtStartPar
WiFi 连接接入点 AP 的主要参数有：接入点 SSID，接入点密码，以及最大连接次数, 如下图，宏定义在\sphinxcode{\sphinxupquote{station\_example\_main.c}}中，可直接在在文件中修改，也可使用 \sphinxcode{\sphinxupquote{idf.py menuconfig}}中修改

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}SSID      CONFIG\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}SSID			}\PYG{c+c1}{//WiFi接入点名}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}PASS      CONFIG\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}PASSWORD		}\PYG{c+c1}{//WiFi接入点密码}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}ESP\PYGZus{}MAXIMUM\PYGZus{}RETRY  CONFIG\PYGZus{}ESP\PYGZus{}MAXIMUM\PYGZus{}RETRY		}\PYG{c+c1}{//最大重连次数}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{wifi\PYGZus{}config\PYGZus{}t}\PYG{+w}{ }\PYG{n}{wifi\PYGZus{}config}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{sta}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{p}{.}\PYG{n}{ssid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{EXAMPLE\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}SSID}\PYG{p}{,}
\PYG{+w}{        }\PYG{p}{.}\PYG{n}{password}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{EXAMPLE\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}PASS}\PYG{p}{,}
\PYG{+w}{        }\PYG{c+cm}{/* Setting a password implies station will connect to all security modes including WEP/WPA.}
\PYG{c+cm}{         * 设置密码意味着工作站将连接到所有安全模式，包括 WEP/WPA。}
\PYG{c+cm}{         * However these modes are deprecated and not advisable to be used. Incase your Access point}
\PYG{c+cm}{         * doesn\PYGZsq{}t support WPA2, these mode can be enabled by commenting below line}
\PYG{c+cm}{         * 但是，这些模式已被弃用，不建议使用。以防万一您的接入点不支持 WPA2，这些模式可以通过下面的注释来启用*/}
\PYG{+w}{  }\PYG{p}{.}\PYG{n}{threshold}\PYG{p}{.}\PYG{n}{authmode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}AUTH\PYGZus{}WPA2\PYGZus{}PSK}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\end{sphinxVerbatim}

\sphinxAtStartPar
其中主要用到了 wifi\_sta\_config\_t 这个结构体，它的内容如下所示

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{typedef}\PYG{+w}{ }\PYG{k}{struct}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{ssid}\PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{]}\PYG{p}{;}\PYG{c+c1}{//SSID}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{password}\PYG{p}{[}\PYG{l+m+mi}{64}\PYG{p}{]}\PYG{p}{;}\PYG{c+c1}{//密码}
\PYG{+w}{    }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{bssid\PYGZus{}set}\PYG{p}{;}\PYG{c+c1}{//是否设置目标AP的MAC地址，一般设为0；只有用户需要查看AP的MAC地址时才设为1}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{bssid}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{;}\PYG{c+c1}{//目标AP的MAC地址}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{channel}\PYG{p}{;}\PYG{c+c1}{//目标AP的通道，如果未知设为0；范围是1\PYGZhy{}13}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{wifi\PYGZus{}sta\PYGZus{}config\PYGZus{}t}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{API}
\label{\detokenize{exp-esp32/wifi/station:api}}
\sphinxAtStartPar
WIFI 的 API 定义在\sphinxcode{\sphinxupquote{esp\_wifi.h}}头文件中，希望深入了解的同学可以自行前往该头文件进行阅读并理解 WiFi 深层次的知识。
\begin{itemize}
\item {} 
\sphinxAtStartPar
WiFi 驱动可以看成是黑盒，它对高层代码一无所知，比如 TCPIP 栈、应用程序任务、事件任务等，它所能做的就是接收来自高层的 API 调用或将事件队列发布到指定的队列，由 API \sphinxcode{\sphinxupquote{esp\_wifi\_init()}} 初始化。

\item {} 
\sphinxAtStartPar
事件任务是一个守护任务，它接收来自 WiFi 驱动程序或其他子系统的事件，例如作为 TCPIP 栈，事件任务在接收到事件时会调用默认的回调函数。例如在接收到事件 \sphinxcode{\sphinxupquote{SYSTEM\_EVENT\_STA\_CONNECTED}} 时，它会调用 \sphinxcode{\sphinxupquote{tcpip\_adapter\_start()}} 来启动 DHCP 客户端在它的默认处理程序中。

\item {} 
\sphinxAtStartPar
应用可以通过 API \sphinxcode{\sphinxupquote{esp\_event\_init}}注册自己的事件回调函数，然后应用回调函数将在默认回调之后调用。此外，如果应用程序不想执行回调，在事件任务中，它需要做的是在应用回调函数中将相关事件发布到应用任务。

\item {} 
\sphinxAtStartPar
应用程序任务（代码）通常将所有这些东西混合在一起，它调用 API 来初始化系统/WiFi 和必要时处理事件。

\end{itemize}

\sphinxAtStartPar
下图为 station 模式下的宏观场景，其中包含不同阶段的具体描述：

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729113358844}.png}


\subsubsection{Wi\sphinxhyphen{}Fi station 模式示例}
\label{\detokenize{exp-esp32/wifi/station:wi-fi-station}}
\sphinxAtStartPar
此示例说明如何使用 ESP 的 Wi\sphinxhyphen{}Fi 驱动程序将 Wi\sphinxhyphen{}Fi Station 连接到接入点。

\sphinxAtStartPar
请同学们使用手机开热点并设置密码，将热点名称和密码输入到 ESP32 初始化。或使用实验室 WiFi 热点：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
SSID:	iot
PASS: iot@Gdpu3721
\end{sphinxVerbatim}


\paragraph{配置 WiFi 接入点参数}
\label{\detokenize{exp-esp32/wifi/station:id3}}
\sphinxAtStartPar
打开项目配置功能：\sphinxcode{\sphinxupquote{idf.py menuconfig}}

\sphinxAtStartPar
在\sphinxcode{\sphinxupquote{Example Configuration}}菜单中：
\begin{itemize}
\item {} 
\sphinxAtStartPar
设置 WiFi SSID。

\item {} 
\sphinxAtStartPar
设置 WiFi Password。

\item {} 
\sphinxAtStartPar
设置 Maxmum Retry

\end{itemize}

\sphinxAtStartPar
可选：如果需要，请根据您的要求更改其他选项。


\paragraph{构建和烧录}
\label{\detokenize{exp-esp32/wifi/station:id4}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出，两种方法：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
在终端中进入命令行界面：

\end{enumerate}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idf.py \sphinxhyphen{}p PORT flash monitor}} （要退出串行监视器，请键入 Ctrl\sphinxhyphen{}{]}。）
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
在 Clion 进入视窗界面：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
选择 flash 并运行

\item {} 
\sphinxAtStartPar
选择 monitor 并运行

\end{enumerate}

\end{enumerate}


\paragraph{示例输出}
\label{\detokenize{exp-esp32/wifi/station:id5}}
\sphinxAtStartPar
请注意，输出，特别是输出的顺序，可能会因环境而异。

\sphinxAtStartPar
如果站连接到 AP 成功，控制台输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{589}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{ESP\PYGZus{}WIFI\PYGZus{}MODE\PYGZus{}STA}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{599}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{wifi} \PYG{n}{driver} \PYG{n}{task}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{n}{ffc08b4}\PYG{p}{,} \PYG{n}{prio}\PYG{p}{:}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{n}{stack}\PYG{p}{:}\PYG{l+m+mi}{3584}\PYG{p}{,} \PYG{n}{core}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{599}\PYG{p}{)} \PYG{n}{system\PYGZus{}api}\PYG{p}{:} \PYG{n}{Base} \PYG{n}{MAC} \PYG{n}{address} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n+nb}{set}\PYG{p}{,} \PYG{n}{read} \PYG{n}{default} \PYG{n}{base} \PYG{n}{MAC} \PYG{n}{address} \PYG{k+kn}{from} \PYG{n+nn}{BLK0} \PYG{n}{of} \PYG{n}{EFUSE}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{599}\PYG{p}{)} \PYG{n}{system\PYGZus{}api}\PYG{p}{:} \PYG{n}{Base} \PYG{n}{MAC} \PYG{n}{address} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n+nb}{set}\PYG{p}{,} \PYG{n}{read} \PYG{n}{default} \PYG{n}{base} \PYG{n}{MAC} \PYG{n}{address} \PYG{k+kn}{from} \PYG{n+nn}{BLK0} \PYG{n}{of} \PYG{n}{EFUSE}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{629}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{wifi} \PYG{n}{firmware} \PYG{n}{version}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{n}{d94f02}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{629}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{config} \PYG{n}{NVS} \PYG{n}{flash}\PYG{p}{:} \PYG{n}{enabled}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{629}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{config} \PYG{n}{nano} \PYG{n}{formating}\PYG{p}{:} \PYG{n}{disabled}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{629}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{dynamic} \PYG{n}{tx} \PYG{n}{buffer} \PYG{n}{num}\PYG{p}{:} \PYG{l+m+mi}{32}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{629}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{data} \PYG{n}{frame} \PYG{n}{dynamic} \PYG{n}{rx} \PYG{n}{buffer} \PYG{n}{num}\PYG{p}{:} \PYG{l+m+mi}{32}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{639}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{management} \PYG{n}{frame} \PYG{n}{dynamic} \PYG{n}{rx} \PYG{n}{buffer} \PYG{n}{num}\PYG{p}{:} \PYG{l+m+mi}{32}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{639}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{management} \PYG{n}{short} \PYG{n}{buffer} \PYG{n}{num}\PYG{p}{:} \PYG{l+m+mi}{32}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{649}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{static} \PYG{n}{rx} \PYG{n}{buffer} \PYG{n}{size}\PYG{p}{:} \PYG{l+m+mi}{1600}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{649}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{static} \PYG{n}{rx} \PYG{n}{buffer} \PYG{n}{num}\PYG{p}{:} \PYG{l+m+mi}{10}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{659}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{dynamic} \PYG{n}{rx} \PYG{n}{buffer} \PYG{n}{num}\PYG{p}{:} \PYG{l+m+mi}{32}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{759}\PYG{p}{)} \PYG{n}{phy}\PYG{p}{:} \PYG{n}{phy\PYGZus{}version}\PYG{p}{:} \PYG{l+m+mi}{4180}\PYG{p}{,} \PYG{n}{cb3948e}\PYG{p}{,} \PYG{n}{Sep} \PYG{l+m+mi}{12} \PYG{l+m+mi}{2019}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{39}\PYG{p}{:}\PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{769}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{mode} \PYG{p}{:} \PYG{n}{sta} \PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{:}\PYG{n}{ae}\PYG{p}{:}\PYG{n}{a4}\PYG{p}{:}\PYG{n}{d9}\PYG{p}{:}\PYG{n}{bc}\PYG{p}{:}\PYG{n}{c4}\PYG{p}{)}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{769}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{wifi\PYGZus{}init\PYGZus{}sta} \PYG{n}{finished}\PYG{o}{.}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{889}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{new}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{old}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{ap}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{255}\PYG{p}{,}\PYG{l+m+mi}{255}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{sta}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{prof}\PYG{p}{:}\PYG{l+m+mi}{1}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{889}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{state}\PYG{p}{:} \PYG{n}{init} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{auth} \PYG{p}{(}\PYG{n}{b0}\PYG{p}{)}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{899}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{state}\PYG{p}{:} \PYG{n}{auth} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{assoc} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{909}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{state}\PYG{p}{:} \PYG{n}{assoc} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{run} \PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{939}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{connected} \PYG{k}{with} \PYG{c+c1}{\PYGZsh{}!/bin/test, aid = 1, channel 6, BW20, bssid = ac:9e:17:7e:31:40}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{939}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{security} \PYG{n+nb}{type}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{phy}\PYG{p}{:} \PYG{n}{bgn}\PYG{p}{,} \PYG{n}{rssi}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{68}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{949}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{pm} \PYG{n}{start}\PYG{p}{,} \PYG{n+nb}{type}\PYG{p}{:} \PYG{l+m+mi}{1}

\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{1029}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{AP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s beacon interval = 102400 us, DTIM period = 3}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{2089}\PYG{p}{)} \PYG{n}{esp\PYGZus{}netif\PYGZus{}handlers}\PYG{p}{:} \PYG{n}{sta} \PYG{n}{ip}\PYG{p}{:} \PYG{l+m+mf}{192.168}\PYG{l+m+mf}{.77}\PYG{l+m+mf}{.89}\PYG{p}{,} \PYG{n}{mask}\PYG{p}{:} \PYG{l+m+mf}{255.255}\PYG{l+m+mf}{.255}\PYG{l+m+mf}{.0}\PYG{p}{,} \PYG{n}{gw}\PYG{p}{:} \PYG{l+m+mf}{192.168}\PYG{l+m+mf}{.77}\PYG{l+m+mf}{.1}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{2089}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{got} \PYG{n}{ip}\PYG{p}{:}\PYG{l+m+mf}{192.168}\PYG{l+m+mf}{.77}\PYG{l+m+mf}{.89}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{2089}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{connected} \PYG{n}{to} \PYG{n}{ap} \PYG{n}{SSID}\PYG{p}{:}\PYG{n}{myssid} \PYG{n}{password}\PYG{p}{:}\PYG{n}{mypassword}
\end{sphinxVerbatim}

\sphinxAtStartPar
站点连接 AP 失败时的控制台输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{589}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{ESP\PYGZus{}WIFI\PYGZus{}MODE\PYGZus{}STA}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{599}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{wifi} \PYG{n}{driver} \PYG{n}{task}\PYG{p}{:} \PYG{l+m+mi}{3}\PYG{n}{ffc08b4}\PYG{p}{,} \PYG{n}{prio}\PYG{p}{:}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{n}{stack}\PYG{p}{:}\PYG{l+m+mi}{3584}\PYG{p}{,} \PYG{n}{core}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{599}\PYG{p}{)} \PYG{n}{system\PYGZus{}api}\PYG{p}{:} \PYG{n}{Base} \PYG{n}{MAC} \PYG{n}{address} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n+nb}{set}\PYG{p}{,} \PYG{n}{read} \PYG{n}{default} \PYG{n}{base} \PYG{n}{MAC} \PYG{n}{address} \PYG{k+kn}{from} \PYG{n+nn}{BLK0} \PYG{n}{of} \PYG{n}{EFUSE}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{599}\PYG{p}{)} \PYG{n}{system\PYGZus{}api}\PYG{p}{:} \PYG{n}{Base} \PYG{n}{MAC} \PYG{n}{address} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{n+nb}{set}\PYG{p}{,} \PYG{n}{read} \PYG{n}{default} \PYG{n}{base} \PYG{n}{MAC} \PYG{n}{address} \PYG{k+kn}{from} \PYG{n+nn}{BLK0} \PYG{n}{of} \PYG{n}{EFUSE}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{629}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{wifi} \PYG{n}{firmware} \PYG{n}{version}\PYG{p}{:} \PYG{l+m+mi}{2}\PYG{n}{d94f02}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{629}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{config} \PYG{n}{NVS} \PYG{n}{flash}\PYG{p}{:} \PYG{n}{enabled}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{629}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{config} \PYG{n}{nano} \PYG{n}{formating}\PYG{p}{:} \PYG{n}{disabled}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{629}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{dynamic} \PYG{n}{tx} \PYG{n}{buffer} \PYG{n}{num}\PYG{p}{:} \PYG{l+m+mi}{32}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{629}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{data} \PYG{n}{frame} \PYG{n}{dynamic} \PYG{n}{rx} \PYG{n}{buffer} \PYG{n}{num}\PYG{p}{:} \PYG{l+m+mi}{32}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{639}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{management} \PYG{n}{frame} \PYG{n}{dynamic} \PYG{n}{rx} \PYG{n}{buffer} \PYG{n}{num}\PYG{p}{:} \PYG{l+m+mi}{32}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{639}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{management} \PYG{n}{short} \PYG{n}{buffer} \PYG{n}{num}\PYG{p}{:} \PYG{l+m+mi}{32}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{649}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{static} \PYG{n}{rx} \PYG{n}{buffer} \PYG{n}{size}\PYG{p}{:} \PYG{l+m+mi}{1600}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{649}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{static} \PYG{n}{rx} \PYG{n}{buffer} \PYG{n}{num}\PYG{p}{:} \PYG{l+m+mi}{10}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{659}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{Init} \PYG{n}{dynamic} \PYG{n}{rx} \PYG{n}{buffer} \PYG{n}{num}\PYG{p}{:} \PYG{l+m+mi}{32}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{759}\PYG{p}{)} \PYG{n}{phy}\PYG{p}{:} \PYG{n}{phy\PYGZus{}version}\PYG{p}{:} \PYG{l+m+mi}{4180}\PYG{p}{,} \PYG{n}{cb3948e}\PYG{p}{,} \PYG{n}{Sep} \PYG{l+m+mi}{12} \PYG{l+m+mi}{2019}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{:}\PYG{l+m+mi}{39}\PYG{p}{:}\PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{759}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{mode} \PYG{p}{:} \PYG{n}{sta} \PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{:}\PYG{n}{ae}\PYG{p}{:}\PYG{n}{a4}\PYG{p}{:}\PYG{n}{d9}\PYG{p}{:}\PYG{n}{bc}\PYG{p}{:}\PYG{n}{c4}\PYG{p}{)}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{769}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{wifi\PYGZus{}init\PYGZus{}sta} \PYG{n}{finished}\PYG{o}{.}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{889}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{new}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{old}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{ap}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{255}\PYG{p}{,}\PYG{l+m+mi}{255}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{sta}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{prof}\PYG{p}{:}\PYG{l+m+mi}{1}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{889}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{state}\PYG{p}{:} \PYG{n}{init} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{auth} \PYG{p}{(}\PYG{n}{b0}\PYG{p}{)}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{1889}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{state}\PYG{p}{:} \PYG{n}{auth} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{init} \PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{1889}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{new}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{old}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{ap}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{255}\PYG{p}{,}\PYG{l+m+mi}{255}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{sta}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{prof}\PYG{p}{:}\PYG{l+m+mi}{1}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{1889}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{retry} \PYG{n}{to} \PYG{n}{connect} \PYG{n}{to} \PYG{n}{the} \PYG{n}{AP}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{1899}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{connect} \PYG{n}{to} \PYG{n}{the} \PYG{n}{AP} \PYG{n}{fail}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{3949}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{retry} \PYG{n}{to} \PYG{n}{connect} \PYG{n}{to} \PYG{n}{the} \PYG{n}{AP}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{3949}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{connect} \PYG{n}{to} \PYG{n}{the} \PYG{n}{AP} \PYG{n}{fail}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{4069}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{new}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{old}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{ap}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{255}\PYG{p}{,}\PYG{l+m+mi}{255}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{sta}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{prof}\PYG{p}{:}\PYG{l+m+mi}{1}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{4069}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{state}\PYG{p}{:} \PYG{n}{init} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{auth} \PYG{p}{(}\PYG{n}{b0}\PYG{p}{)}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{5069}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{state}\PYG{p}{:} \PYG{n}{auth} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{init} \PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{5069}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{new}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{old}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{ap}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{255}\PYG{p}{,}\PYG{l+m+mi}{255}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{sta}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{prof}\PYG{p}{:}\PYG{l+m+mi}{1}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{5069}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{retry} \PYG{n}{to} \PYG{n}{connect} \PYG{n}{to} \PYG{n}{the} \PYG{n}{AP}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{5069}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{connect} \PYG{n}{to} \PYG{n}{the} \PYG{n}{AP} \PYG{n}{fail}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{7129}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{retry} \PYG{n}{to} \PYG{n}{connect} \PYG{n}{to} \PYG{n}{the} \PYG{n}{AP}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{7129}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{connect} \PYG{n}{to} \PYG{n}{the} \PYG{n}{AP} \PYG{n}{fail}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{7249}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{new}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{old}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{ap}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{255}\PYG{p}{,}\PYG{l+m+mi}{255}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{sta}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{prof}\PYG{p}{:}\PYG{l+m+mi}{1}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{7249}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{state}\PYG{p}{:} \PYG{n}{init} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{auth} \PYG{p}{(}\PYG{n}{b0}\PYG{p}{)}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{8249}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{state}\PYG{p}{:} \PYG{n}{auth} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{init} \PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{8249}\PYG{p}{)} \PYG{n}{wifi}\PYG{p}{:} \PYG{n}{new}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{old}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{ap}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{255}\PYG{p}{,}\PYG{l+m+mi}{255}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{sta}\PYG{p}{:}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{n}{prof}\PYG{p}{:}\PYG{l+m+mi}{1}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{8249}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{retry} \PYG{n}{to} \PYG{n}{connect} \PYG{n}{to} \PYG{n}{the} \PYG{n}{AP}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{8249}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{connect} \PYG{n}{to} \PYG{n}{the} \PYG{n}{AP} \PYG{n}{fail}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{10299}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{connect} \PYG{n}{to} \PYG{n}{the} \PYG{n}{AP} \PYG{n}{fail}
\PYG{n}{I} \PYG{p}{(}\PYG{l+m+mi}{10299}\PYG{p}{)} \PYG{n}{wifi} \PYG{n}{station}\PYG{p}{:} \PYG{n}{Failed} \PYG{n}{to} \PYG{n}{connect} \PYG{n}{to} \PYG{n}{SSID}\PYG{p}{:}\PYG{n}{myssid}\PYG{p}{,} \PYG{n}{password}\PYG{p}{:}\PYG{n}{mypassword}
\end{sphinxVerbatim}


\subsubsection{源代码参考}
\label{\detokenize{exp-esp32/wifi/station:id6}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}

\sphinxstepscope


\subsection{AP 接入点模式}
\label{\detokenize{exp-esp32/wifi/ap:ap}}\label{\detokenize{exp-esp32/wifi/ap::doc}}

\subsubsection{实验目的}
\label{\detokenize{exp-esp32/wifi/ap:id1}}
\sphinxAtStartPar
AP 模式（即 Soft\sphinxhyphen{}AP 模式或接入点模式），此时 ESP32 设备作为接入点，允许其他基站（如手机等其他设备）连接到 ESP32 设备。

\sphinxAtStartPar
本实验目的是如何设置 ESP32 设备为 AP 模式，并允许其他 STA 的接入。


\subsubsection{内容详解}
\label{\detokenize{exp-esp32/wifi/ap:id2}}

\paragraph{设置 WiFi 接入点参数}
\label{\detokenize{exp-esp32/wifi/ap:wifi}}
\sphinxAtStartPar
SoftAP 的主要参数包含：
\begin{itemize}
\item {} 
\sphinxAtStartPar
SSID

\item {} 
\sphinxAtStartPar
PASSWORD

\item {} 
\sphinxAtStartPar
AP 所在的频段

\item {} 
\sphinxAtStartPar
最大可连接 STA 数量

\end{itemize}

\sphinxAtStartPar
宏定义在\sphinxcode{\sphinxupquote{softap\_example\_main.c}}中，可直接在在文件中修改，也可使用 \sphinxcode{\sphinxupquote{idf.py menuconfig}}中修改

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}SSID      CONFIG\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}SSID      }\PYG{c+c1}{//WiFi热点名}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}PASS      CONFIG\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}PASSWORD	 }\PYG{c+c1}{//WiFi热点密码}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}CHANNEL   CONFIG\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}CHANNEL   }\PYG{c+c1}{//WiFi热点频段}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define EXAMPLE\PYGZus{}MAX\PYGZus{}STA\PYGZus{}CONN       CONFIG\PYGZus{}ESP\PYGZus{}MAX\PYGZus{}STA\PYGZus{}CONN   }\PYG{c+c1}{//能连接的最大节点数量，默认为4，最大为4}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//初始化WiFi的参数}
\PYG{n}{wifi\PYGZus{}config\PYGZus{}t}\PYG{+w}{ }\PYG{n}{wifi\PYGZus{}config}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{.}\PYG{n}{ap}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{p}{.}\PYG{n}{ssid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{EXAMPLE\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}SSID}\PYG{p}{,}
\PYG{+w}{        }\PYG{p}{.}\PYG{n}{ssid\PYGZus{}len}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{EXAMPLE\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}SSID}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{        }\PYG{p}{.}\PYG{n}{channel}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{EXAMPLE\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}CHANNEL}\PYG{p}{,}
\PYG{+w}{        }\PYG{p}{.}\PYG{n}{password}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{EXAMPLE\PYGZus{}ESP\PYGZus{}WIFI\PYGZus{}PASS}\PYG{p}{,}
\PYG{+w}{        }\PYG{p}{.}\PYG{n}{max\PYGZus{}connection}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{EXAMPLE\PYGZus{}MAX\PYGZus{}STA\PYGZus{}CONN}\PYG{p}{,}
\PYG{+w}{        }\PYG{p}{.}\PYG{n}{authmode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{WIFI\PYGZus{}AUTH\PYGZus{}WPA\PYGZus{}WPA2\PYGZus{}PSK}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\end{sphinxVerbatim}

\sphinxAtStartPar
这边主要用到了 wifi\_config\_t 这个结构体，它的内容如下所示

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Ctypedef}\PYG{+w}{ }\PYG{k}{struct}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{ssid}\PYG{p}{[}\PYG{l+m+mi}{32}\PYG{p}{]}\PYG{p}{;}\PYG{c+c1}{//SSID}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{password}\PYG{p}{[}\PYG{l+m+mi}{64}\PYG{p}{]}\PYG{p}{;}\PYG{c+c1}{//密码}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{ssid\PYGZus{}len}\PYG{p}{;}\PYG{c+c1}{//SSID长度，若设为0则会自动查找到终止字符；否则会在规定长度处截断}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{channel}\PYG{p}{;}\PYG{c+c1}{//AP的通道}
\PYG{+w}{    }\PYG{n}{wifi\PYGZus{}auth\PYGZus{}mode\PYGZus{}t}\PYG{+w}{ }\PYG{n}{authmode}\PYG{p}{;}\PYG{c+c1}{//授权模式}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{ssid\PYGZus{}hidden}\PYG{p}{;}\PYG{c+c1}{//是否广播SSID，默认为0\PYGZhy{}广播；设为1则不广播}
\PYG{+w}{    }\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{max\PYGZus{}connection}\PYG{p}{;}\PYG{c+c1}{//能连接的最大节点数量，默认为4，最大为4}
\PYG{+w}{    }\PYG{k+kt}{uint16\PYGZus{}t}\PYG{+w}{ }\PYG{n}{beacon\PYGZus{}interval}\PYG{p}{;}\PYG{c+c1}{//信标间隔，默认100ms，应设置在100\PYGZhy{}60000ms内}
\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{n}{wifi\PYGZus{}ap\PYGZus{}config\PYGZus{}t}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{API}
\label{\detokenize{exp-esp32/wifi/ap:api}}
\sphinxAtStartPar
WIFI 的 API 定义在\sphinxcode{\sphinxupquote{esp\_wifi.h}}头文件中，希望深入了解的同学可以自行前往该头文件进行阅读并理解 WiFi 深层次的知识。
\begin{itemize}
\item {} 
\sphinxAtStartPar
WiFi 驱动可以看成是黑盒，它对高层代码一无所知，比如 TCPIP 栈、应用程序任务、事件任务等，它所能做的就是接收来自高层的 API 调用或将事件队列发布到指定的队列，由 API esp\_wifi\_init() 初始化。

\item {} 
\sphinxAtStartPar
事件任务是一个守护任务，它接收来自 WiFi 驱动程序或其他子系统的事件，例如作为 TCPIP 栈，事件任务在接收到事件时会调用默认的回调函数。例如在接收到事件 SYSTEM\_EVENT\_STA\_CONNECTED 时，它会调用 tcpip\_adapter\_start() 来启动 DHCP 客户端在它的默认处理程序中。

\item {} 
\sphinxAtStartPar
应用可以通过 API esp\_event\_init 注册自己的事件回调函数，然后应用回调函数将在默认回调之后调用。此外，如果应用程序不想执行回调，在事件任务中，它需要做的是在应用回调函数中将相关事件发布到应用任务。

\item {} 
\sphinxAtStartPar
应用程序任务（代码）通常将所有这些东西混合在一起，它调用 API 来初始化系统/WiFi 和必要时处理事件。

\end{itemize}

\sphinxAtStartPar
AP 模式下的宏观场景，其中包含不同阶段的具体描述：

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220729105646806}.png}


\subsubsection{实验内容}
\label{\detokenize{exp-esp32/wifi/ap:id3}}
\sphinxAtStartPar
此示例说明如何使用 ESP 的 Wi\sphinxhyphen{}Fi 驱动程序实现softAP接入点功能。


\paragraph{配置项目参数}
\label{\detokenize{exp-esp32/wifi/ap:id4}}
\sphinxAtStartPar
打开项目配置菜单 ( \sphinxcode{\sphinxupquote{idf.py menuconfig}})。

\sphinxAtStartPar
在 \sphinxcode{\sphinxupquote{Example Configuration}} 菜单中：
\begin{itemize}
\item {} 
\sphinxAtStartPar
设置 WiFi SSID。

\item {} 
\sphinxAtStartPar
设置 WiFi Password。

\end{itemize}

\sphinxAtStartPar
可选：如果需要，请根据您的要求更改其他选项。


\paragraph{构建和烧录}
\label{\detokenize{exp-esp32/wifi/ap:id5}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出，共两种方法：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
在终端中进入命令行界面：

\end{enumerate}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idf.py \sphinxhyphen{}p PORT flash monitor}}

\sphinxAtStartPar
（要退出串行监视器，请键入 Ctrl\sphinxhyphen{}{]}。）
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Clion 界面：

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
选择 flash 并运行

\item {} 
\sphinxAtStartPar
选择 monitor 并运行

\end{itemize}

\sphinxAtStartPar
连接SoftAp

\sphinxAtStartPar
打开手机或其他设备，看是否可以接入到该AP上。


\paragraph{示例输出}
\label{\detokenize{exp-esp32/wifi/ap:id6}}
\sphinxAtStartPar
此示例有控制台输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{917}\PYG{o}{)} phy: phy\PYGZus{}version: \PYG{l+m}{3960}, \PYG{l+m}{5211945}, Jul \PYG{l+m}{18} \PYG{l+m}{2018}, \PYG{l+m}{10}:40:07, \PYG{l+m}{0}, \PYG{l+m}{0}
I \PYG{o}{(}\PYG{l+m}{917}\PYG{o}{)} wifi: mode : softAP \PYG{o}{(}\PYG{l+m}{30}:ae:a4:80:45:69\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{917}\PYG{o}{)} wifi softAP: wifi\PYGZus{}init\PYGZus{}softap finished.SSID:myssid password:mypassword
I \PYG{o}{(}\PYG{l+m}{26457}\PYG{o}{)} wifi: n:1 \PYG{l+m}{0}, o:1 \PYG{l+m}{0}, ap:1 \PYG{l+m}{1}, sta:255 \PYG{l+m}{255}, prof:1
I \PYG{o}{(}\PYG{l+m}{26457}\PYG{o}{)} wifi: station: \PYG{l+m}{70}:ef:00:43:96:67 join, \PYG{n+nv}{AID}\PYG{o}{=}\PYG{l+m}{1}, bg, \PYG{l+m}{20}
I \PYG{o}{(}\PYG{l+m}{26467}\PYG{o}{)} wifi softAP: station:70:ef:00:43:96:67 join, \PYG{n+nv}{AID}\PYG{o}{=}\PYG{l+m}{1}
I \PYG{o}{(}\PYG{l+m}{27657}\PYG{o}{)} tcpip\PYGZus{}adapter: softAP assign IP to station,IP is: \PYG{l+m}{192}.168.4.2
\end{sphinxVerbatim}


\subsubsection{源代码参考}
\label{\detokenize{exp-esp32/wifi/ap:id7}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}

\sphinxstepscope


\subsection{ESP\_NOW 协议}
\label{\detokenize{exp-esp32/wifi/esp-now:esp-now}}\label{\detokenize{exp-esp32/wifi/esp-now::doc}}
\sphinxAtStartPar
ESP\sphinxhyphen{}NOW是一种专为ESP8266和ESP32芯片设计的低功耗无线通信协议。它允许ESP8266和ESP32芯片之间通过Wi\sphinxhyphen{}Fi直接进行通信，而无需连接到传统的Wi\sphinxhyphen{}Fi网络。

\sphinxAtStartPar
ESP\sphinxhyphen{}NOW协议的特点包括：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
低功耗：ESP\sphinxhyphen{}NOW使用低功耗模式，能够在节能的情况下进行通信，适合电池供电的设备。

\item {} 
\sphinxAtStartPar
直连通信：ESP\sphinxhyphen{}NOW允许ESP8266和ESP32芯片之间直接进行通信，无需连接到路由器或Wi\sphinxhyphen{}Fi网络。

\item {} 
\sphinxAtStartPar
快速和简单：ESP\sphinxhyphen{}NOW提供了简单易用的API，使得设备之间的通信可以快速实现。

\item {} 
\sphinxAtStartPar
安全性：ESP\sphinxhyphen{}NOW协议支持数据包加密，可以提供一定的数据传输安全性。

\end{enumerate}

\sphinxAtStartPar
ESP\sphinxhyphen{}NOW广泛应用于物联网和嵌入式系统中，特别适合在局域网中的设备之间进行直连通信，如传感器节点之间的数据传输、设备间的控制和命令传递等。由于其低功耗和快速的特性，ESP\sphinxhyphen{}NOW在无线传感网络和智能家居等领域有广泛的应用。


\subsubsection{ESP\sphinxhyphen{}NOW编程}
\label{\detokenize{exp-esp32/wifi/esp-now:id1}}
\sphinxAtStartPar
在 ESP\sphinxhyphen{}NOW 中，应用程序数据被封装在各个供应商的动作帧中，然后在无连接的情况下，从一个 Wi\sphinxhyphen{}Fi 设备传输到另一个 Wi\sphinxhyphen{}Fi 设备。 CTR 与 CBC\sphinxhyphen{}MAC 协议 (CCMP) 可用来保护动作帧的安全。


\paragraph{帧格式}
\label{\detokenize{exp-esp32/wifi/esp-now:id2}}
\sphinxAtStartPar
ESP\sphinxhyphen{}NOW 使用各个供应商的动作帧传输数据，默认比特率为 1 Mbps。各个供应商的动作帧格式为：


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
MAC 报头
&\sphinxstyletheadfamily 
\sphinxAtStartPar
分类代码
&\sphinxstyletheadfamily 
\sphinxAtStartPar
组织标识符
&\sphinxstyletheadfamily 
\sphinxAtStartPar
随机值
&\sphinxstyletheadfamily 
\sphinxAtStartPar
供应商特定内容
&\sphinxstyletheadfamily 
\sphinxAtStartPar
FCS
\\
\hline
\sphinxAtStartPar
24 字节
&
\sphinxAtStartPar
1 字节
&
\sphinxAtStartPar
3 字节
&
\sphinxAtStartPar
4 字节
&
\sphinxAtStartPar
7\textasciitilde{}255 字节
&
\sphinxAtStartPar
4 字节
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{itemize}
\item {} 
\sphinxAtStartPar
分类代码：分类代码字段可用于指示各个供应商的类别（比如 127）。

\item {} 
\sphinxAtStartPar
组织标识符：组织标识符包含一个唯一标识符 (比如 0x18fe34)，为乐鑫指定的 MAC 地址的前三个字节。

\item {} 
\sphinxAtStartPar
随机值：防止重放攻击。

\item {} 
\sphinxAtStartPar
供应商特定内容：供应商特定内容包含供应商特定字段，如下所示：

\end{itemize}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
元素 ID
&\sphinxstyletheadfamily 
\sphinxAtStartPar
长度
&\sphinxstyletheadfamily 
\sphinxAtStartPar
组织标识符
&\sphinxstyletheadfamily 
\sphinxAtStartPar
类型
&\sphinxstyletheadfamily 
\sphinxAtStartPar
版本
&\sphinxstyletheadfamily 
\sphinxAtStartPar
正文
\\
\hline
\sphinxAtStartPar
1 字节
&
\sphinxAtStartPar
1 字节
&
\sphinxAtStartPar
3 字节
&
\sphinxAtStartPar
1 字节
&
\sphinxAtStartPar
1 字节
&
\sphinxAtStartPar
0～250 字节
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{itemize}
\item {} 
\sphinxAtStartPar
元素 ID：元素 ID 字段可用于指示特定于供应商的元素。

\item {} 
\sphinxAtStartPar
长度：长度是组织标识符、类型、版本和正文的总长度。

\item {} 
\sphinxAtStartPar
组织标识符：组织标识符包含一个唯一标识符 (比如 0x18fe34)，为乐鑫指定的 MAC 地址的前三个字节。

\item {} 
\sphinxAtStartPar
类型：类型字段设置为 4，代表 ESP\sphinxhyphen{}NOW。

\item {} 
\sphinxAtStartPar
版本：版本字段设置为 ESP\sphinxhyphen{}NOW 的版本。

\item {} 
\sphinxAtStartPar
正文：正文包含 ESP\sphinxhyphen{}NOW 数据。

\end{itemize}

\sphinxAtStartPar
由于 ESP\sphinxhyphen{}NOW 是无连接的，因此 MAC 报头与标准帧略有不同。\sphinxcode{\sphinxupquote{FrameControl}} 字段的 \sphinxcode{\sphinxupquote{FromDS}} 和 \sphinxcode{\sphinxupquote{ToDS}} 位均为 0。第一个地址字段用于配置目标地址。第二个地址字段用于配置源地址。第三个地址字段用于配置广播地址 (0xff:0xff:0xff:0xff:0xff:0xff)。


\paragraph{安全}
\label{\detokenize{exp-esp32/wifi/esp-now:id3}}
\sphinxAtStartPar
\sphinxstylestrong{ESP\sphinxhyphen{}NOW 采用 CCMP 方法保护供应商特定动作帧的安全，具体可参考 IEEE Std. 802.11\sphinxhyphen{}2012。Wi\sphinxhyphen{}Fi 设备维护一个初始主密钥 (PMK) 和若干本地主密钥 (LMK)，长度均为 16 个字节。}
\begin{itemize}
\item {} 
\sphinxAtStartPar
PMK 可使用 \sphinxcode{\sphinxupquote{AES\sphinxhyphen{}128}} 算法加密 LMK。请调用 \sphinxcode{\sphinxupquote{esp\_now\_set\_pmk()}} 设置 PMK。如果未设置 PMK，将使用默认 PMK。

\item {} 
\sphinxAtStartPar
LMK 可通过 CCMP 方法对供应商特定的动作帧进行加密，最多拥有 6 个不同的 LMK。如果未设置配对设备的 LMK，则动作帧不进行加密。

\end{itemize}

\sphinxAtStartPar
目前，不支持加密组播供应商特定的动作帧。


\paragraph{初始化和反初始化}
\label{\detokenize{exp-esp32/wifi/esp-now:id4}}
\sphinxAtStartPar
调用 \sphinxcode{\sphinxupquote{esp\_now\_init()}} 初始化 ESP\sphinxhyphen{}NOW，调用 \sphinxcode{\sphinxupquote{esp\_now\_deinit()}} 反初始化 ESP\sphinxhyphen{}NOW。ESP\sphinxhyphen{}NOW 数据必须在 Wi\sphinxhyphen{}Fi 启动后传输，因此建议在初始化 ESP\sphinxhyphen{}NOW 之前启动 Wi\sphinxhyphen{}Fi，并在反初始化 ESP\sphinxhyphen{}NOW 之后停止 Wi\sphinxhyphen{}Fi。 当调用 esp\_now\_deinit() 时，配对设备的所有信息都将被删除。


\paragraph{添加配对设备}
\label{\detokenize{exp-esp32/wifi/esp-now:id5}}
\sphinxAtStartPar
在将数据发送到其他设备之前，请先调用 \sphinxcode{\sphinxupquote{esp\_now\_add\_peer()}} 将其添加到配对设备列表中。配对设备的最大数量是 20。如果启用了加密，则必须设置 LMK。ESP\sphinxhyphen{}NOW 数据可以从 Station 或 Softap 接口发送。 确保在发送 ESP\sphinxhyphen{}NOW 数据之前已启用该接口。在发送广播数据之前必须添加具有广播 MAC 地址的设备。配对设备的信道范围是从 0 ～14。如果信道设置为 0，数据将在当前信道上发送。否则，必须使用本地设备所在的通道。


\paragraph{发送 ESP\sphinxhyphen{}NOW 数据}
\label{\detokenize{exp-esp32/wifi/esp-now:id6}}
\sphinxAtStartPar
调用 \sphinxcode{\sphinxupquote{esp\_now\_send()}} 发送 ESP\sphinxhyphen{}NOW 数据，调用 \sphinxcode{\sphinxupquote{esp\_now\_register\_send\_cb}} 注册发送回调函数。如果 MAC 层成功接收到数据，则该函数将返回 \sphinxcode{\sphinxupquote{ESP\_NOW\_SEND\_SUCCESS}} 事件。否则，它将返回 \sphinxcode{\sphinxupquote{ESP\_NOW\_SEND\_FAIL}}。ESP\sphinxhyphen{}NOW 数据发送失败可能有几种原因，比如目标设备不存在、设备的信道不相同、动作帧在传输过程中丢失等。应用层并不一定可以总能接收到数据。如果需要，应用层可在接收 ESP\sphinxhyphen{}NOW 数据时发回一个应答 (ACK) 数据。如果接收 ACK 数据超时，则将重新传输 ESP\sphinxhyphen{}NOW 数据。可以为 ESP\sphinxhyphen{}NOW 数据设置序列号，从而删除重复的数据。

\sphinxAtStartPar
如果有大量 ESP\sphinxhyphen{}NOW 数据要发送，则调用 \sphinxcode{\sphinxupquote{esp\_now\_send()}} 一次性发送不大于 250 字节的数据。 请注意，两个 ESP\sphinxhyphen{}NOW 数据包的发送间隔太短可能导致回调函数返回混乱。因此，建议在等到上一次回调函数返回 ACK 后再发送下一个 ESP\sphinxhyphen{}NOW 数据。发送回调函数从高优先级的 Wi\sphinxhyphen{}Fi 任务中运行。因此，不要在回调函数中执行冗长的操作。相反，将必要的数据发布到队列，并交给优先级较低的任务处理。


\paragraph{接收 ESP\sphinxhyphen{}NOW 数据}
\label{\detokenize{exp-esp32/wifi/esp-now:id7}}
\sphinxAtStartPar
调用 \sphinxcode{\sphinxupquote{esp\_now\_register\_recv\_cb}} 注册接收回调函数。当接收 ESP\sphinxhyphen{}NOW 数据时，需要调用接收回调函数。接收回调函数也在 Wi\sphinxhyphen{}Fi 任务任务中运行。因此，不要在回调函数中执行冗长的操作。 相反，将必要的数据发布到队列，并交给优先级较低的任务处理。


\subsubsection{实验内容}
\label{\detokenize{exp-esp32/wifi/esp-now:id8}}
\sphinxAtStartPar
本实验展示了如何使用 ESP\sphinxhyphen{}NOW协议。\sphinxstylestrong{本实验至少需要两个 ESP 设备}，由以下步骤组成：
\begin{itemize}
\item {} 
\sphinxAtStartPar
启动无线网络。

\item {} 
\sphinxAtStartPar
初始化 ESP\sphinxhyphen{}NOW。

\item {} 
\sphinxAtStartPar
注册 ESP\sphinxhyphen{}NOW 发送或接收回调函数。

\item {} 
\sphinxAtStartPar
添加 ESP\sphinxhyphen{}NOW 对等信息。

\item {} 
\sphinxAtStartPar
发送和接收 ESP\sphinxhyphen{}NOW 数据。
\begin{itemize}
\item {} 
\sphinxAtStartPar
为了获取另一台设备的 MAC 地址，Device1 首先发送广播 ESP\sphinxhyphen{}NOW 数据，并将 ‘state’ 设置为 0。

\item {} 
\sphinxAtStartPar
当 Device2 从 Device1 接收到 ‘state’ 为 0 的广播 ESP\sphinxhyphen{}NOW 数据时，将 Device1 添加到对等列表中。然后开始发送“状态”设置为 1 的广播 ESP\sphinxhyphen{}NOW 数据。

\item {} 
\sphinxAtStartPar
当 Device1 接收到 ‘state’ 为 1 的广播 ESP\sphinxhyphen{}NOW 数据时，将本地幻数与数据中的幻数进行比较。如果本地大于那个，停止发送广播 ESP\sphinxhyphen{}NOW 数据并开始向 Device2 发送单播 ESPNOW 数据。

\item {} 
\sphinxAtStartPar
如果 Device2 收到单播 ESP\sphinxhyphen{}NOW 数据，也停止发送广播 ESP\sphinxhyphen{}NOW 数据。

\end{itemize}

\end{itemize}

\sphinxAtStartPar
在实际应用中，如果其他设备的 MAC 地址已知，则不需要先发送/接收广播 ESPNOW 数据，只需将设备添加到对等列表并发送/接收单播 ESP\sphinxhyphen{}NOW 数据即可。


\paragraph{配置项目}
\label{\detokenize{exp-esp32/wifi/esp-now:id9}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
idf.py menuconfig
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
在示例配置选项下设置 WiFi 模式（站或 SoftAP）。

\item {} 
\sphinxAtStartPar
在示例配置选项下设置 ESPNOW 主主密钥。对于发送设备和接收设备，此参数必须设置为相同的值。

\item {} 
\sphinxAtStartPar
在示例配置选项下设置 ESPNOW 本地主密钥。对于发送设备和接收设备，此参数必须设置为相同的值。

\item {} 
\sphinxAtStartPar
在示例配置选项下设置通道。发送设备和接收设备必须在同一通道上。

\item {} 
\sphinxAtStartPar
在示例配置选项下设置发送计数和发送延迟。

\item {} 
\sphinxAtStartPar
在示例配置选项下设置发送 len。

\item {} 
\sphinxAtStartPar
设置启用远程选项。启用此参数后，ESP32 设备将以 512Kbps 或 256Kbps 的 PHY 速率发送数据，从而可以在两个 ESP32 设备之间远距离传输数据。

\end{itemize}


\paragraph{构建和烧录}
\label{\detokenize{exp-esp32/wifi/esp-now:id10}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：

\sphinxAtStartPar
\sphinxstylestrong{命令行界面：}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idf.py \sphinxhyphen{}p PORT flash monitor}} （要退出串行监视器，请键入Ctrl\sphinxhyphen{}{]}。）

\sphinxAtStartPar
\sphinxstylestrong{Clion界面：}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
选择 flash 并运行

\item {} 
\sphinxAtStartPar
选择 monitor 并运行

\end{enumerate}


\paragraph{示例输出}
\label{\detokenize{exp-esp32/wifi/esp-now:id11}}
\sphinxAtStartPar
这是 ESP\sphinxhyphen{}NOW 接收设备控制台输出的示例。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{898}\PYG{o}{)} phy: phy\PYGZus{}version: \PYG{l+m}{3960}, \PYG{l+m}{5211945}, Jul \PYG{l+m}{18} \PYG{l+m}{2018}, \PYG{l+m}{10}:40:07, \PYG{l+m}{0}, \PYG{l+m}{0}
I \PYG{o}{(}\PYG{l+m}{898}\PYG{o}{)} wifi: mode : sta \PYG{o}{(}\PYG{l+m}{30}:ae:a4:80:45:68\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{898}\PYG{o}{)} espnow\PYGZus{}example: WiFi started
I \PYG{o}{(}\PYG{l+m}{898}\PYG{o}{)} ESPNOW: espnow \PYG{o}{[}version: \PYG{l+m}{1}.0\PYG{o}{]} init
I \PYG{o}{(}\PYG{l+m}{5908}\PYG{o}{)} espnow\PYGZus{}example: Start sending broadcast data
I \PYG{o}{(}\PYG{l+m}{6908}\PYG{o}{)} espnow\PYGZus{}example: send data to ff:ff:ff:ff:ff:ff
I \PYG{o}{(}\PYG{l+m}{7908}\PYG{o}{)} espnow\PYGZus{}example: send data to ff:ff:ff:ff:ff:ff
I \PYG{o}{(}\PYG{l+m}{52138}\PYG{o}{)} espnow\PYGZus{}example: send data to ff:ff:ff:ff:ff:ff
I \PYG{o}{(}\PYG{l+m}{52138}\PYG{o}{)} espnow\PYGZus{}example: Receive 0th broadcast data from: \PYG{l+m}{30}:ae:a4:0c:34:ec, len: \PYG{l+m}{200}
I \PYG{o}{(}\PYG{l+m}{53158}\PYG{o}{)} espnow\PYGZus{}example: send data to ff:ff:ff:ff:ff:ff
I \PYG{o}{(}\PYG{l+m}{53158}\PYG{o}{)} espnow\PYGZus{}example: Receive 1th broadcast data from: \PYG{l+m}{30}:ae:a4:0c:34:ec, len: \PYG{l+m}{200}
I \PYG{o}{(}\PYG{l+m}{54168}\PYG{o}{)} espnow\PYGZus{}example: send data to ff:ff:ff:ff:ff:ff
I \PYG{o}{(}\PYG{l+m}{54168}\PYG{o}{)} espnow\PYGZus{}example: Receive 2th broadcast data from: \PYG{l+m}{30}:ae:a4:0c:34:ec, len: \PYG{l+m}{200}
I \PYG{o}{(}\PYG{l+m}{54168}\PYG{o}{)} espnow\PYGZus{}example: Receive 0th unicast data from: \PYG{l+m}{30}:ae:a4:0c:34:ec, len: \PYG{l+m}{200}
I \PYG{o}{(}\PYG{l+m}{54678}\PYG{o}{)} espnow\PYGZus{}example: Receive 1th unicast data from: \PYG{l+m}{30}:ae:a4:0c:34:ec, len: \PYG{l+m}{200}
I \PYG{o}{(}\PYG{l+m}{55668}\PYG{o}{)} espnow\PYGZus{}example: Receive 2th unicast data from: \PYG{l+m}{30}:ae:a4:0c:34:ec, len: \PYG{l+m}{200}
\end{sphinxVerbatim}

\sphinxAtStartPar
这是 ESP\sphinxhyphen{}NOW 发送设备控制台输出的示例。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{915}\PYG{o}{)} phy: phy\PYGZus{}version: \PYG{l+m}{3960}, \PYG{l+m}{5211945}, Jul \PYG{l+m}{18} \PYG{l+m}{2018}, \PYG{l+m}{10}:40:07, \PYG{l+m}{0}, \PYG{l+m}{0}
I \PYG{o}{(}\PYG{l+m}{915}\PYG{o}{)} wifi: mode : sta \PYG{o}{(}\PYG{l+m}{30}:ae:a4:0c:34:ec\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{915}\PYG{o}{)} espnow\PYGZus{}example: WiFi started
I \PYG{o}{(}\PYG{l+m}{915}\PYG{o}{)} ESPNOW: espnow \PYG{o}{[}version: \PYG{l+m}{1}.0\PYG{o}{]} init
I \PYG{o}{(}\PYG{l+m}{5915}\PYG{o}{)} espnow\PYGZus{}example: Start sending broadcast data
I \PYG{o}{(}\PYG{l+m}{5915}\PYG{o}{)} espnow\PYGZus{}example: Receive 41th broadcast data from: \PYG{l+m}{30}:ae:a4:80:45:68, len: \PYG{l+m}{200}
I \PYG{o}{(}\PYG{l+m}{5915}\PYG{o}{)} espnow\PYGZus{}example: Receive 42th broadcast data from: \PYG{l+m}{30}:ae:a4:80:45:68, len: \PYG{l+m}{200}
I \PYG{o}{(}\PYG{l+m}{5925}\PYG{o}{)} espnow\PYGZus{}example: Receive 44th broadcast data from: \PYG{l+m}{30}:ae:a4:80:45:68, len: \PYG{l+m}{200}
I \PYG{o}{(}\PYG{l+m}{5935}\PYG{o}{)} espnow\PYGZus{}example: Receive 45th broadcast data from: \PYG{l+m}{30}:ae:a4:80:45:68, len: \PYG{l+m}{200}
I \PYG{o}{(}\PYG{l+m}{6965}\PYG{o}{)} espnow\PYGZus{}example: send data to ff:ff:ff:ff:ff:ff
I \PYG{o}{(}\PYG{l+m}{6965}\PYG{o}{)} espnow\PYGZus{}example: Receive 46th broadcast data from: \PYG{l+m}{30}:ae:a4:80:45:68, len: \PYG{l+m}{200}
I \PYG{o}{(}\PYG{l+m}{7975}\PYG{o}{)} espnow\PYGZus{}example: send data to ff:ff:ff:ff:ff:ff
I \PYG{o}{(}\PYG{l+m}{7975}\PYG{o}{)} espnow\PYGZus{}example: Receive 47th broadcast data from: \PYG{l+m}{30}:ae:a4:80:45:68, len: \PYG{l+m}{200}
I \PYG{o}{(}\PYG{l+m}{7975}\PYG{o}{)} espnow\PYGZus{}example: Start sending unicast data
I \PYG{o}{(}\PYG{l+m}{7975}\PYG{o}{)} espnow\PYGZus{}example: send data to \PYG{l+m}{30}:ae:a4:80:45:68
I \PYG{o}{(}\PYG{l+m}{9015}\PYG{o}{)} espnow\PYGZus{}example: send data to \PYG{l+m}{30}:ae:a4:80:45:68
I \PYG{o}{(}\PYG{l+m}{9015}\PYG{o}{)} espnow\PYGZus{}example: Receive 48th broadcast data from: \PYG{l+m}{30}:ae:a4:80:45:68, len: \PYG{l+m}{200}
I \PYG{o}{(}\PYG{l+m}{10015}\PYG{o}{)} espnow\PYGZus{}example: send data to \PYG{l+m}{30}:ae:a4:80:45:68
I \PYG{o}{(}\PYG{l+m}{16075}\PYG{o}{)} espnow\PYGZus{}example: send data to \PYG{l+m}{30}:ae:a4:80:45:68
I \PYG{o}{(}\PYG{l+m}{17075}\PYG{o}{)} espnow\PYGZus{}example: send data to \PYG{l+m}{30}:ae:a4:80:45:68
I \PYG{o}{(}\PYG{l+m}{24125}\PYG{o}{)} espnow\PYGZus{}example: send data to \PYG{l+m}{30}:ae:a4:80:45:68
\end{sphinxVerbatim}


\paragraph{故障排除}
\label{\detokenize{exp-esp32/wifi/esp-now:id12}}
\sphinxAtStartPar
如果无法从其他设备接收到 ESP\sphinxhyphen{}NOW 数据，可能是两个设备不在同一个频道上，或者主秘钥和本地秘钥不同。

\sphinxAtStartPar
在实际应用中，如果接收设备仅处于工作站模式并且连接到 AP，则应禁用调制解调器睡眠。否则，它可能无法从其他设备接收 ESP\sphinxhyphen{}NOW 数据。


\subsubsection{源代码参考}
\label{\detokenize{exp-esp32/wifi/esp-now:id13}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}

\sphinxstepscope


\subsection{WiFi测距FTM}
\label{\detokenize{exp-esp32/wifi/ftm:wififtm}}\label{\detokenize{exp-esp32/wifi/ftm::doc}}\begin{quote}

\sphinxAtStartPar
❗注意

\sphinxAtStartPar
​	本实验为选做!!!

\sphinxAtStartPar
​	目前只支持ESP32\sphinxhyphen{}C3	ESP32\sphinxhyphen{}S2	ESP32\sphinxhyphen{}S3 这三款ESP芯片

\sphinxAtStartPar
​	我们平时使用的ESP\sphinxhyphen{}WROVER\sphinxhyphen{}KIT开发板是ESP32芯片，无法进行此实验
\end{quote}


\subsubsection{测距原理}
\label{\detokenize{exp-esp32/wifi/ftm:id1}}
\sphinxAtStartPar
启用 WiFi 的设备可以测量其与接入点的距离的方法之一是测量 Wi\sphinxhyphen{}Fi 往返时间 (Wi\sphinxhyphen{}Fi RTT)。Wi\sphinxhyphen{}Fi RTT 是 WiFi 信号从 Station 传输到 AP 所需的时间。这个时间与它们之间的实际距离成正比。给定 RTT，可以使用以下简单公式计算距离
\begin{quote}

\sphinxAtStartPar
距离 = RTT * c / 2（其中 c 是光速）
\end{quote}

\sphinxAtStartPar
Wi\sphinxhyphen{}Fi RTT 是使用称为精细定时测量 (FTM) 的程序计算的。在 FTM 过程中，一个动作帧的突发由一个设备（FTM 响应者）传输到另一个（FTM 发起者），并且每个设备都被确认。两个设备中的硬件都标记动作帧及其 ACK 的到达时间 (TOA) 和离开时间 (TOD)。最后，FTM Initiator 收集所有 Action frame 和 ACK 对的数据，并使用以下公式计算每对的 RTT \sphinxhyphen{}
\begin{quote}

\sphinxAtStartPar
RTT{[}i{]} = (T4{[}i{]} \sphinxhyphen{} T1{[}i{]}) \sphinxhyphen{} (T3{[}i{]} \sphinxhyphen{} T2{[}i{]}) 其中 T1{[}i{]} ：来自响应者的第 i 个动作帧的 TOD T2{[}i{]} ：TOA 的发起者 T3{[}i{]} 处的第 i 个动作帧：来自发起者 T4{[}i{]} 的第 i 个 ACK 的 TOD：响应者处的第 i 个 ACK 的 TOA
\end{quote}

\sphinxAtStartPar
计算所有此类对的平均 RTT 以获得更准确的结果。使用此示例在 Station 和 SoftAP 或支持 FTM Responder 模式的外部 AP 之间执行 FTM。Station 和 SoftAP 都需要在支持 FTM 的受支持的 ESP 目标上运行并启用它。


\subsubsection{实验内容}
\label{\detokenize{exp-esp32/wifi/ftm:id2}}
\sphinxAtStartPar
通过本实验，用户可以扫描支持 FTM Responder 角色的 AP，并使用不同的配置执行 FTM 程序。以下步骤显示了如何在 Station 和 SoftAP 模式下使用 2 个设备来执行此操作。


\paragraph{配置}
\label{\detokenize{exp-esp32/wifi/ftm:id3}}
\sphinxAtStartPar
首先确保WiFi FTM在项目配置菜单 ( \sphinxcode{\sphinxupquote{idf.py menuconfig}}) 中启用。此选项位于\sphinxcode{\sphinxupquote{Component config \sphinxhyphen{}> Wi\sphinxhyphen{}Fi}}. \sphinxcode{\sphinxupquote{FTM Initiator supportStation}}侧\sphinxcode{\sphinxupquote{FTM Responder support}}需要开启，\sphinxcode{\sphinxupquote{SoftAP}}侧需要开启，默认开启。

\sphinxAtStartPar
此外，要获取有关 FTM 会话的详细报告，\sphinxcode{\sphinxupquote{FTM Report logging}}请启用\sphinxcode{\sphinxupquote{Example Configuration}}. 在支持的设备上构建并刷新示例以查看以下输出 \sphinxhyphen{}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 ==========================================================
 |                      Steps to test FTM                 |
 |                                                        |
 |  1. Use \PYGZsq{}help\PYGZsq{} for detailed information on parameters  |
 |  2. Start SoftAP with command \PYGZsq{}ap \PYGZlt{}SSID\PYGZgt{} \PYGZlt{}password\PYGZgt{}\PYGZsq{}   |
 |                          OR                            |
 |  2. Use \PYGZsq{}scan\PYGZsq{} command to search for external AP\PYGZsq{}s     |
 |  3. On second device initiate FTM with an AP using     |

 |     command \PYGZsq{}ftm \PYGZhy{}I \PYGZhy{}s \PYGZlt{}SSID\PYGZgt{}\PYGZsq{}                         |

ftm\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
用于help获取可用命令和选项的列表。使用scan命令扫描支持 \sphinxcode{\sphinxupquote{FTM Responder}} 模式的 AP。在使用外部 AP 启动 FTM 之前，请确保该FTM Responder标签在相应的扫描结果条目中可见。或者，使用命令在另一台设备上启动 SoftAP ap，它默认支持 FTM Responder。如果外部 FTM 启动器在使用 SoftAP 的距离读数中出现较大误差，请记下以厘米为单位的零距离读数，例如cm0. 可以使用命令偏移此距离，以便通过ftm \sphinxhyphen{}R \sphinxhyphen{}o Initiator 提供准确的读数。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ftm\PYGZgt{} scan
I \PYG{o}{(}\PYG{l+m}{476765}\PYG{o}{)} ftm\PYGZus{}station: sta start to scan
ftm\PYGZgt{} I \PYG{o}{(}\PYG{l+m}{478805}\PYG{o}{)} ftm\PYGZus{}station: \PYG{o}{[}Abeeys Palace\PYG{o}{]}\PYG{o}{[}\PYG{n+nv}{rssi}\PYG{o}{=}\PYG{l+m}{84}\PYG{o}{]}
I \PYG{o}{(}\PYG{l+m}{478805}\PYG{o}{)} ftm\PYGZus{}station: \PYG{o}{[}privateproperty\PYG{o}{]}\PYG{o}{[}\PYG{n+nv}{rssi}\PYG{o}{=}\PYG{l+m}{76}\PYG{o}{]}
I \PYG{o}{(}\PYG{l+m}{478805}\PYG{o}{)} ftm\PYGZus{}station: \PYG{o}{[}C904\PYG{o}{]}\PYG{o}{[}\PYG{n+nv}{rssi}\PYG{o}{=}\PYG{l+m}{69}\PYG{o}{]}
I \PYG{o}{(}\PYG{l+m}{478815}\PYG{o}{)} ftm\PYGZus{}station: \PYG{o}{[}FTM\PYG{o}{]}\PYG{o}{[}\PYG{n+nv}{rssi}\PYG{o}{=}\PYGZhy{}94\PYG{o}{]}\PYG{o}{[}FTM Responder\PYG{o}{]}
I \PYG{o}{(}\PYG{l+m}{478815}\PYG{o}{)} ftm\PYGZus{}station: \PYG{o}{[}Velop\PYG{o}{]}\PYG{o}{[}\PYG{n+nv}{rssi}\PYG{o}{=}\PYGZhy{}115\PYG{o}{]}
I \PYG{o}{(}\PYG{l+m}{478825}\PYG{o}{)} ftm\PYGZus{}station: sta scan \PYG{k}{done}
\end{sphinxVerbatim}

\sphinxAtStartPar
在扫描结果中可以看到支持 FTM Responder 模式的 AP。或者使用以下命令在另一台设备上设置 SoftAP ap\sphinxhyphen{}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ftm\PYGZgt{} ap FTM password
I \PYG{o}{(}\PYG{l+m}{91271}\PYG{o}{)} ftm\PYGZus{}ap: Starting SoftAP with FTM Responder support, SSID \PYGZhy{} FTM, Password \PYGZhy{} password
ftm\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
使用 32 FTMftm \sphinxhyphen{}I帧的默认配置启动会话。如需更多配置，可使用以下选项

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{} ftm {[}\sphinxhyphen{}I{]} {[}\sphinxhyphen{}c <0/8/16/24/32/64>{]} {[}\sphinxhyphen{}p <2\sphinxhyphen{}255 (x 100 mSec)>{]} {[}\sphinxhyphen{}s SSID{]}}} ，其中
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}I或\sphinxhyphen{}\sphinxhyphen{}ftm\_initiator}}：FTM 发起者模式

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}cOR \sphinxhyphen{}\sphinxhyphen{}frm\_count}}：要交换的 FTM 帧（有效值：0=无偏好，8、16、24、32、64，默认值：32）

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}p或\sphinxhyphen{}\sphinxhyphen{}burst\_period}}：FTM 以 100 毫秒为单位的周期性突发（0：无偏好，默认值：2）

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}sOR \sphinxhyphen{}\sphinxhyphen{}ssid=SSID:}} 支持 FTM Responder 模式的 AP 的 SSID

\end{itemize}

\sphinxAtStartPar
目前仅在以下配置中支持 FTM \sphinxhyphen{}

\sphinxAtStartPar
在受支持的 ESP 设备上，Station 作为发起者，SoftAP 作为响应者
作为发起者的站和在响应者模式下支持 FTM 的外部 AP 应首选第一个选项，因为 ESP 设备已针对高分辨率测量进行了自我校准。


\paragraph{构建和烧录}
\label{\detokenize{exp-esp32/wifi/ftm:id4}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：

\sphinxAtStartPar
\sphinxstylestrong{命令行界面：}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{idf.py \sphinxhyphen{}p PORT flash monitor}} （要退出串行监视器，请键入Ctrl\sphinxhyphen{}{]}。）

\sphinxAtStartPar
\sphinxstylestrong{Clion界面：}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
选择 flash 并运行

\item {} 
\sphinxAtStartPar
选择 monitor 并运行

\end{enumerate}


\paragraph{示例输出}
\label{\detokenize{exp-esp32/wifi/ftm:id5}}
\sphinxAtStartPar
FTM 程序的示例输出 \sphinxhyphen{}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ftm\PYGZgt{} scan
I \PYG{o}{(}\PYG{l+m}{356414}\PYG{o}{)} ftm\PYGZus{}station: sta start to scan
I \PYG{o}{(}\PYG{l+m}{358514}\PYG{o}{)} ftm\PYGZus{}station: \PYG{o}{[}DigitalFortress\PYG{o}{]}\PYG{o}{[}\PYG{n+nv}{rssi}\PYG{o}{=}\PYG{l+m}{114}\PYG{o}{]}
I \PYG{o}{(}\PYG{l+m}{358524}\PYG{o}{)} ftm\PYGZus{}station: \PYG{o}{[}TEST\PYG{o}{]}\PYG{o}{[}\PYG{n+nv}{rssi}\PYG{o}{=}\PYGZhy{}96\PYG{o}{]}\PYG{o}{[}FTM Responder\PYG{o}{]}
I \PYG{o}{(}\PYG{l+m}{358524}\PYG{o}{)} ftm\PYGZus{}station: sta scan \PYG{k}{done}
ftm\PYGZgt{} ftm \PYGZhy{}I \PYGZhy{}s TEST
Starting FTM with \PYG{l+m}{18}:fe:34:72:50:c9 on channel \PYG{l+m}{1}
I \PYG{o}{(}\PYG{l+m}{391824}\PYG{o}{)} ftm\PYGZus{}station: Starting FTM Initiator with Frm Count \PYG{l+m}{32}, Burst Period \PYGZhy{} 200mSec
W \PYG{o}{(}\PYG{l+m}{391834}\PYG{o}{)} wifi:Starting FTM session \PYG{k}{in} \PYG{l+m}{0}.200 Sec
W \PYG{o}{(}\PYG{l+m}{393564}\PYG{o}{)} wifi:FTM session ends with \PYG{l+m}{26} valid readings out of \PYG{l+m}{31}, Avg raw RTT: \PYG{l+m}{49}.218 nSec, Avg RSSI: \PYGZhy{}1
I \PYG{o}{(}\PYG{l+m}{393564}\PYG{o}{)} ftm\PYGZus{}station: Estimated RTT \PYGZhy{} \PYG{l+m}{33} nSec, Estimated Distance \PYGZhy{} \PYG{l+m}{5}.07 meters
\end{sphinxVerbatim}

\sphinxAtStartPar
最后的语句给出了平均计算的 RTT 以及站点和 AP 之间的估计距离。通过首先使用任何物理模拟延迟和校准增量调整 RTT 来测量此距离。使用 RTT 测量的距离并不完全准确，并且会受到各种误差的影响，例如射频干扰、多路径、路径损耗、方向等。该设计需要具有直接传播路径且 RSSI 不低于 \sphinxhyphen{}70dBm 的视距以获得更好的结果。


\subsubsection{源代码参考}
\label{\detokenize{exp-esp32/wifi/ftm:id6}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}

\sphinxstepscope


\section{Socket over WiFi}
\label{\detokenize{exp-esp32/socket/index:socket-over-wifi}}\label{\detokenize{exp-esp32/socket/index::doc}}

\subsection{Socket简介}
\label{\detokenize{exp-esp32/socket/index:socket}}
\sphinxAtStartPar
Socket（套接字）是计算机网络中用于实现网络通信的一种抽象概念。它提供了一种通用的编程接口，使得应用程序能够通过网络进行数据交换。

\sphinxAtStartPar
Socket可以被看作是一个端点，用于建立网络连接的起点或终点。在网络通信中，通信的两个端点分别使用不同的Socket，它们通过Socket之间的连接进行数据的发送和接收。

\sphinxAtStartPar
Socket通常用于实现客户端\sphinxhyphen{}服务器模式的网络通信。在这种模式下，客户端应用程序使用Socket连接到服务器的Socket，然后通过Socket进行数据的发送和接收。服务器端应用程序则监听某个特定的Socket端口，等待客户端的连接请求，并通过建立的Socket与客户端进行通信。

\sphinxAtStartPar
Socket通信可以基于不同的传输协议，例如TCP（传输控制协议）或UDP（用户数据报协议）。TCP提供可靠的、面向连接的通信，确保数据按照顺序传输且不丢失；而UDP则提供无连接的通信，适用于对实时性要求较高但不要求可靠性的应用场景。

\sphinxAtStartPar
在编程中，Socket通常由操作系统提供的网络库或网络框架来实现。不同编程语言提供了各自的Socket API，开发者可以使用这些API来创建、连接和管理Socket。常见的编程语言如C、Java、Python等都提供了Socket编程的支持。

\sphinxAtStartPar
总而言之，Socket是一种实现网络通信的抽象概念，它提供了一种通用的编程接口，使得应用程序能够通过网络进行数据交换。通过Socket，开发者可以实现客户端\sphinxhyphen{}服务器模式的网络通信，并选择适合的传输协议来满足通信需求。


\subsection{Socket通信基本原理}
\label{\detokenize{exp-esp32/socket/index:id1}}
\sphinxAtStartPar
Socket通信是基于网络的一种通信方式，它的原理如下：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
创建Socket：在通信的两端，即客户端和服务器端，分别创建一个Socket对象。Socket可以简单理解为一个端点，它包含了IP地址和端口号。

\item {} 
\sphinxAtStartPar
建立连接：客户端通过指定服务器的IP地址和端口号，向服务器发起连接请求。服务器监听指定端口，并接受客户端的连接请求。一旦连接建立成功，客户端和服务器端就可以进行通信。

\item {} 
\sphinxAtStartPar
数据传输：通过已建立的连接，客户端和服务器端可以进行数据的发送和接收。在TCP协议中，数据以字节流的形式传输，而在UDP协议中，数据以数据报的形式传输。

\item {} 
\sphinxAtStartPar
关闭连接：通信完成后，客户端或服务器端可以选择关闭连接。关闭连接会释放网络资源，并使得两端的Socket不再可用。

\end{enumerate}

\sphinxAtStartPar
在TCP协议中，Socket通信采用面向连接的方式。它通过三次握手来建立可靠的连接，确保数据的可靠性和顺序性。而在UDP协议中，Socket通信是无连接的，每个数据包都是独立发送的，不保证数据的可靠性和顺序性。

\sphinxAtStartPar
Socket通信的原理是基于网络协议栈的实现。它利用底层的网络协议（如IP、TCP、UDP）来传输数据，并通过Socket接口提供了简单而强大的编程接口，使得程序能够方便地进行网络通信。


\subsection{实验内容}
\label{\detokenize{exp-esp32/socket/index:id2}}
\sphinxAtStartPar
本节的实验内容是在ESP32设备连接到WiFi之后，在WiFi之上建立socket连接，共有两个实验，分别实现TCP以及UDP协议，在每个实验中，ESP32设备分别充当Server以及Client的角色。

\sphinxAtStartPar
主要实验内容包括如下：

\sphinxstepscope


\subsubsection{TCP Server and Client}
\label{\detokenize{exp-esp32/socket/tcp:tcp-server-and-client}}\label{\detokenize{exp-esp32/socket/tcp::doc}}
\sphinxAtStartPar
TCP即传输控制协议（TCP Transmission Control Protocol）,其基本原理是：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
TCP是面向连接的运输层协议。 这就是说， 应用程序在使用TCP协议之前， 必须先建立TCP连接。 在传送数据完毕后， 必须释放已经建立的TCP连接。 也就是说， 应用进程之间的通信好像在 “ 打电话”：通话前要先拨号建立连接， 通话结束后要挂机释放连接。

\item {} 
\sphinxAtStartPar
每一条TCP连接只能有两个端点（endpoint）， 每一条TCP连接只能是点对点的（一对一 ）。

\item {} 
\sphinxAtStartPar
TCP提供可靠交付的服务。 通过TCP连接传送的数据， 无差错、 不丢失、 不重复，并且按序到达。

\item {} 
\sphinxAtStartPar
TCP 提供全双工通信。 TCP允许通信双方的应用进程在任何时候都能发送数据。 TCP连接的两端都设有发送缓存和接收缓存， 用来临时存放双向通信的数据。 在发送时，应用程序在把数据传送给TCP的缓存后， 就可以做自己的事， 而TCP在合适的时候把数据发送出去。 在接收时， TCP把收到的数据放入缓存， 上层的应用进程在合适的时候读取缓 存中的数据。

\item {} 
\sphinxAtStartPar
面向字节流。 TCP中的 “ 流” （stream）指的是流入到进程或从进程流出的字节序列。 面向字节流” 的含义是： 虽然应用程序和TCP的交互是一次 一个数据块（大小不等）， 但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

\end{enumerate}


\paragraph{ESP\sphinxhyphen{}IDF TCP API详解}
\label{\detokenize{exp-esp32/socket/tcp:esp-idf-tcp-api}}

\subparagraph{\sphinxstyleliteralintitle{\sphinxupquote{socket()}}}
\label{\detokenize{exp-esp32/socket/tcp:socket}}
\sphinxAtStartPar
socket这个函数的功能是向内核申请一个套接字

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define socket(domain,type,protocol)   lwip\PYGZus{}socket(domain,type,protocol)}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{lwip\PYGZus{}socket}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{domain}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{type}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{protocol}\PYG{p}{)}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define AF\PYGZus{}UNSPEC       0}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define AF\PYGZus{}INET         2}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{if LWIP\PYGZus{}IPV6}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define AF\PYGZus{}INET6        10}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else }\PYG{c+cm}{/* LWIP\PYGZus{}IPV6 */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define AF\PYGZus{}INET6        AF\PYGZus{}UNSPEC}

\PYG{c+cm}{/* Socket 服务类型 (TCP/UDP/RAW) */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SOCK\PYGZus{}STREAM 1}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SOCK\PYGZus{}DGRAM 2}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SOCK\PYGZus{}RAW 3}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{函数形参含义如下：}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{\sphinxcode{\sphinxupquote{domain}} ：} 表示该套接字使用的协议簇，对于 TCP/IP 协议来说，IPv4为 AF\_INET；IPv6为AF\_INET6。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Type}}： 指定了套接字使用的服务类型，可能的类型有 3 种：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SOCK\_STREAM}}：提供可靠的（即能保证数据正确传送到对方）面向连接的 Socket 服务，多
用于资料（如文件）传输，如 TCP 协议。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SOCK\_DGRAM}}：是提供无保障的面向消息的 Socket 服务，主要用于在网络上发广播信息，
如 UDP 协议，提供无连接不可靠的数据报交付服务。

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SOCK\_RAW}}：表示原始套接字，它允许应用程序访问网络层的原始数据包，这个套接字用得比较少，暂时不用理会它。

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{protocol}} ：指定了套接字使用的协议，在 IPv4 中，只有 TCP 协议提供 \sphinxcode{\sphinxupquote{SOCK\_STREAM}} 这种可靠的服务，只有 UDP 协议提供 \sphinxcode{\sphinxupquote{SOCK\_DGRAM}} 服务，对于这两种协议，protocol 的值均为 0。当申请套接字成功的时候，该函数返回一个 int 类型的值，也是 Socket 描述符，用户通过这个值可以索引到一个 Socket 连接结构——\sphinxcode{\sphinxupquote{lwip\_sock}}，当申请套接字失败时，该函数返回\sphinxhyphen{}1。

\end{itemize}


\subparagraph{\sphinxstyleliteralintitle{\sphinxupquote{sendto()}}}
\label{\detokenize{exp-esp32/socket/tcp:sendto}}
\sphinxAtStartPar
这个函数主要是用于 UDP 协议传输数据中，它向另一端的 UDP 主机发送一个 UDP 报文，
\begin{itemize}
\item {} 
\sphinxAtStartPar
参数 \sphinxcode{\sphinxupquote{dataptr}} 指定了要发送数据的起始地址，而 参数size 则指定数据的长度，

\item {} 
\sphinxAtStartPar
参数 \sphinxcode{\sphinxupquote{flag}} 指定了发送时候的一些处理，比如外带数据等，此时我们不需要理会它，一般设置为 0 即可，

\item {} 
\sphinxAtStartPar
参数 \sphinxcode{\sphinxupquote{to}} 是一个指向 \sphinxcode{\sphinxupquote{sockaddr}} 结构体的指针，在这里需要我们自己提供远端主机的 IP 地址与端口号，并且用 \sphinxcode{\sphinxupquote{tolen}} 参数指定这些信息的长度，具体如下

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define sendto(s,dataptr,size,flags,to,tolen)  lwip\PYGZus{}sendto(s,dataptr,size,flags,to,tolen)}
\PYG{k+kt}{ssize\PYGZus{}t}\PYG{+w}{ }\PYG{n}{lwip\PYGZus{}sendto}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{flags}\PYG{p}{,}\PYG{k}{const}\PYG{+w}{ }\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{sockaddr}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{to}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{socklen\PYGZus{}t}\PYG{+w}{ }\PYG{n}{tolen}\PYG{p}{)}
\end{sphinxVerbatim}


\subparagraph{\sphinxstyleliteralintitle{\sphinxupquote{read()、recv()、recvfrom()}}}
\label{\detokenize{exp-esp32/socket/tcp:read-recv-recvfrom}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{read()}} 与 \sphinxcode{\sphinxupquote{recv()}} 函数的核心是调用 \sphinxcode{\sphinxupquote{recvfrom()}} 函数，\sphinxcode{\sphinxupquote{recv()}} 与 \sphinxcode{\sphinxupquote{read()}} 函数用于从 Socket 中接收数据，它们可以是 TCP 协议和 UDP 协议。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define read(s,mem,len)   lwip\PYGZus{}read(s,mem,len)}
\PYG{k+kt}{ssize\PYGZus{}t}\PYG{+w}{ }\PYG{n+nf}{lwip\PYGZus{}read}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{mem}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{len}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{k}{return}\PYG{+w}{ }\PYG{n}{lwip\PYGZus{}recvfrom}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{mem}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{len}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define recv(s,mem,len,flags)  lwip\PYGZus{}recv(s,mem,len,flags)}
\PYG{k+kt}{ssize\PYGZus{}t}\PYG{+w}{ }\PYG{n+nf}{lwip\PYGZus{}recv}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{mem}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{len}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{flags}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{k}{return}\PYG{+w}{ }\PYG{n}{lwip\PYGZus{}recvfrom}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{mem}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{len}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{flags}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define recvfrom(s,mem,len,flags,from,fromlen)  lwip\PYGZus{}recvfrom(s,mem,len,flags,from,fromlen)}
\PYG{k+kt}{ssize\PYGZus{}t}\PYG{+w}{ }\PYG{n}{lwip\PYGZus{}recvfrom}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{mem}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{len}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{flags}\PYG{p}{,}\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{sockaddr}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{from}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{socklen\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{fromlen}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
**men 参数 ** 记录了接收数据的缓存起始地址，

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{len参数} 用于指定接收数据的最大长度，如果函数能正确接收到数据，将会返回一个接收到数据的长度，否则将返回\sphinxhyphen{}1，若返回值为 0，表示连接已经终止，应用程序可以根据返回的值进行不一样的操作。

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{flags 参数}我们暂时可以直接忽略它，设置为 0 即可。
注意，如果接收的数据大于用户提供的缓存区，那么多余的数据会被直接丢弃。

\end{itemize}


\subparagraph{\sphinxstyleliteralintitle{\sphinxupquote{close()}}}
\label{\detokenize{exp-esp32/socket/tcp:close}}
\sphinxAtStartPar
close() 函数是用于关闭一个指定的套接字，在关闭套接字后，将无法使用对应的套接字描述符索引到连接结构，该函数的本质是对 netconn\_delete() 函数的封装（真正处理的函数是 net\sphinxhyphen{}conn\_prepare\_delete()），如果连接是 TCP 协议，将产生一个请求终止连接的报文发送到对端主机中，如果是 UDP 协议，将直接释放 UDP 控制块的内容，具体如下

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define close(s)   lwip\PYGZus{}close(s)}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{lwip\PYGZus{}close}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}
\end{sphinxVerbatim}


\subparagraph{\sphinxstyleliteralintitle{\sphinxupquote{connect()}}}
\label{\detokenize{exp-esp32/socket/tcp:connect}}
\sphinxAtStartPar
connect这个函数用于客户端中，将 Socket 与远端 IP 地址、端口号进行绑定，在 TCP 客户端连接中，调用这个函数将发生握手过程（会发送一个 TCP 连接请求），并最终建立新的 TCP 连接，而对于 UDP协议来说，调用这个函数只是在 UDP 控制块中记录远端 IP 地址与端口号，而不发送任何数据，参数信息与 bind() 函数是一样的

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define connect(s,name,namelen)  lwip\PYGZus{}connect(s,name,namelen)}
\PYG{n}{intlwip\PYGZus{}connect}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{k}{const}\PYG{+w}{ }\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{sockaddr}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{name}\PYG{p}{,}\PYG{k+kt}{socklen\PYGZus{}t}\PYG{+w}{ }\PYG{n}{namelen}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subparagraph{\sphinxstyleliteralintitle{\sphinxupquote{send()}}}
\label{\detokenize{exp-esp32/socket/tcp:send}}
\sphinxAtStartPar
send() 函数可以用于 UDP 协议和 TCP 连接发送数据。在调用 send() 函数之前，必须使用 connect()函数将远端主机的 IP 地址、端口号与 Socket 连接结构进行绑定。对于 UDP 协议，send() 函数将调用 lwip\_sendto() 函数发送数据，而对于 TCP 协议，将调用 netconn\_write\_partly() 函数发送数据。相对于 sendto() 函数，参数基本是没啥区别的，但无需我们设置远端主机的信息，更加方便操作，因此这个函数在实际中使用也是很多的，具体

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define send(s,dataptr,size,flags)   lwip\PYGZus{}send(s,dataptr,size,flags)}
\PYG{k+kt}{ssize\PYGZus{}t}\PYG{+w}{ }\PYG{n}{lwip\PYGZus{}send}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{size\PYGZus{}t}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{flags}\PYG{p}{)}
\end{sphinxVerbatim}


\subparagraph{\sphinxstyleliteralintitle{\sphinxupquote{bind()}}}
\label{\detokenize{exp-esp32/socket/tcp:bind}}
\sphinxAtStartPar
bind该函数用于服务器端绑定套接字与网卡信息

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define bind(s,name,namelen)   lwip\PYGZus{}bind(s,name,namelen)}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{lwip\PYGZus{}bind}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{k}{const}\PYG{+w}{ }\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{sockaddr}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{name}\PYG{p}{,}\PYG{k+kt}{socklen\PYGZus{}t}\PYG{+w}{ }\PYG{n}{namelen}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{参数 s} 是表示要绑定的 Socket 套接字，注意了，这个套接字必须是从 socket() 函数中返回的索引，否则将无法完成绑定操作。

\sphinxAtStartPar
\sphinxstylestrong{参数 name} 是一个指向 sockaddr 结构体的指针，其中包含了网卡的 IP 地址、端口号等重要的信息，LwIP 为了更好描述这些信息，使用了 sockaddr 结构体来定义了必要的信息的字段，它常被用于Socket API 的很多函数中，我们在使用 bind() 的时候，只需要直接填写相关字段即可，sockaddr 结构体如下

\sphinxAtStartPar
参数 s 是表示要绑定的 Socket 套接字，注意了，这个套接字必须是从 socket() 函数中返回的索引，否则将无法完成绑定操作。
参数 name 是一个指向 sockaddr 结构体的指针，其中包含了网卡的 IP 地址、端口号等重要的信息，LwIP 为了更好描述这些信息，使用了 sockaddr 结构体来定义了必要的信息的字段，它常被用于Socket API 的很多函数中，我们在使用 bind() 的时候，只需要直接填写相关字段即可，sockaddr 结构体如下

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{sockaddr}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{u8\PYGZus{}t}\PYG{+w}{        }\PYG{n}{sa\PYGZus{}len}\PYG{p}{;}\PYG{+w}{        }\PYG{c+cm}{/*长度*/}
\PYG{+w}{  }\PYG{n}{sa\PYGZus{}family\PYGZus{}t}\PYG{+w}{ }\PYG{n}{sa\PYGZus{}family}\PYG{p}{;}\PYG{+w}{     }\PYG{c+cm}{/*协议簇*/}
\PYG{+w}{  }\PYG{k+kt}{char}\PYG{+w}{        }\PYG{n}{sa\PYGZus{}data}\PYG{p}{[}\PYG{l+m+mi}{14}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{   }\PYG{c+cm}{/* 连续的 14 字节信息 */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
我们需要填写的 IP 地址与端口号等信息，都在 sa\_data 连续的 14 字节信息里面，但是这个数据对我们不友好，因此 LwIP还定义了另一个对开发者更加友好的结构体——sockaddr\_in，我们一般也是用这个结构体

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{sockaddr\PYGZus{}in}
\PYG{p}{\PYGZob{}}
\PYG{+w}{	}\PYG{n}{u8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{sin\PYGZus{}len}\PYG{p}{;}
\PYG{+w}{	}\PYG{n}{sa\PYGZus{}family\PYGZus{}t}\PYG{+w}{ }\PYG{n}{sin\PYGZus{}family}\PYG{p}{;}
\PYG{+w}{	}\PYG{n}{in\PYGZus{}port\PYGZus{}t}\PYG{+w}{ }\PYG{n}{sin\PYGZus{}port}\PYG{p}{;}
\PYG{+w}{	}\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{in\PYGZus{}addr}\PYG{+w}{ }\PYG{n}{sin\PYGZus{}addr}\PYG{p}{;}
\PYG{+w}{	}\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SIN\PYGZus{}ZERO\PYGZus{}LEN 8}
\PYG{+w}{	}\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{sin\PYGZus{}zero}\PYG{p}{[}\PYG{n}{SIN\PYGZus{}ZERO\PYGZus{}LEN}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
这个结构体的前两个字段是与 sockaddr 结构体的前两个字段一致，而剩下的字段就是 sa\_data 连续的 14 字节信息里面的内容，只不过从新定义了成员变量而已，sin\_port 字段是我们需要填写的端口号信息，sin\_addr 字段是我们需要填写的 IP 地址信息，剩下 sin\_zero 区域的 8 字节保留未用。
但在本章实验中为了兼容IPv6，所以初始定义时都是使用sockaddr\_in6结构体，如下所示

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{sockaddr\PYGZus{}in6}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{  }\PYG{n}{u8\PYGZus{}t}\PYG{+w}{            }\PYG{n}{sin6\PYGZus{}len}\PYG{p}{;}\PYG{+w}{      }\PYG{c+cm}{/* length of this structure    */}
\PYG{+w}{  }\PYG{n}{sa\PYGZus{}family\PYGZus{}t}\PYG{+w}{     }\PYG{n}{sin6\PYGZus{}family}\PYG{p}{;}\PYG{+w}{   }\PYG{c+cm}{/* AF\PYGZus{}INET6                    */}
\PYG{+w}{  }\PYG{n}{in\PYGZus{}port\PYGZus{}t}\PYG{+w}{       }\PYG{n}{sin6\PYGZus{}port}\PYG{p}{;}\PYG{+w}{     }\PYG{c+cm}{/* Transport layer port \PYGZsh{}      */}
\PYG{+w}{  }\PYG{n}{u32\PYGZus{}t}\PYG{+w}{           }\PYG{n}{sin6\PYGZus{}flowinfo}\PYG{p}{;}\PYG{+w}{ }\PYG{c+cm}{/* IPv6 flow information       */}
\PYG{+w}{  }\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{in6\PYGZus{}addr}\PYG{+w}{ }\PYG{n}{sin6\PYGZus{}addr}\PYG{p}{;}\PYG{+w}{     }\PYG{c+cm}{/* IPv6 address                */}
\PYG{+w}{  }\PYG{n}{u32\PYGZus{}t}\PYG{+w}{           }\PYG{n}{sin6\PYGZus{}scope\PYGZus{}id}\PYG{p}{;}\PYG{+w}{ }\PYG{c+cm}{/* Set of interfaces for scope */}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
如果使用的是IPv4则会强制转化为sockaddr\_in

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{sockaddr\PYGZus{}in6}\PYG{+w}{ }\PYG{n}{dest\PYGZus{}addr}\PYG{p}{;}
\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{addr\PYGZus{}family}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{AF\PYGZus{}INET}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{   }\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{sockaddr\PYGZus{}in}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{dest\PYGZus{}addr\PYGZus{}ip4}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{sockaddr\PYGZus{}in}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{dest\PYGZus{}addr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subparagraph{\sphinxstyleliteralintitle{\sphinxupquote{listen()}}}
\label{\detokenize{exp-esp32/socket/tcp:listen}}
\sphinxAtStartPar
该函数只能在 TCP 服务器中使用，让服务器进入监听状态，等待远端的连接请求，LwIP 中可以接收多个客户端的连接，因此参数 backlog 指定了请求队列的大小，具体如下

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define listen(s,backlog)   lwip\PYGZus{}listen(s,backlog)}
\PYG{n}{intlwip\PYGZus{}listen}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{backlog}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{参数 s} 是表示要绑定的 Socket 套接字，注意了，这个套接字必须是从 socket() 函数中返回的索引，否则将无法完成绑定操作。

\sphinxAtStartPar
\sphinxstylestrong{参数 backlog}指定服务器可连接客户端的数量。


\subparagraph{\sphinxstyleliteralintitle{\sphinxupquote{accept()}}}
\label{\detokenize{exp-esp32/socket/tcp:accept}}
\sphinxAtStartPar
accept() 函数用于 TCP 服务器中，等待着远程主机的连接请求，并且建立一个新的 TCP 连接，在调用这个函数之前需要通过调用 listen() 函数让服务器进入监听状态。accept() 函数的调用会阻塞应用线程直至与远程主机建立 TCP 连接。同时函数返回一个 int 类型的套接字描述符，根据它能索引到连接结构，如果连接失败则返回\sphinxhyphen{}1，具体如下

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define accept(s,addr,addrlen)   lwip\PYGZus{}accept(s,addr,addrlen)}
\PYG{k+kt}{int}\PYG{+w}{  }\PYG{n}{lwip\PYGZus{}accept}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{sockaddr}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{addr}\PYG{p}{,}\PYG{k+kt}{socklen\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{addrlen}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{参数 s} 是表示要绑定的 Socket 套接字，注意了，这个套接字必须是从 socket() 函数中返回的索引，否则将无法完成绑定操作。

\sphinxAtStartPar
\sphinxstylestrong{参数 addr} 是一个返回结果参数，其实就是远程主机的地址与端口号等信息，当新的连接已经建立后，远端主机的信息将保存在连接句柄中，它能够唯一的标识某个连接对象。


\subparagraph{\sphinxstyleliteralintitle{\sphinxupquote{setsockopt()}}}
\label{\detokenize{exp-esp32/socket/tcp:setsockopt}}
\sphinxAtStartPar
看名字就知道，这个函数是用于设置套接字的一些选项的，参数 level 有多个常见的选项，如：
• SOL\_SOCKET：表示在 Socket 层。
• IPPROTO\_TCP：表示在 TCP 层。
• IPPROTO\_IP：表示在 IP 层。
参数 optname 表示该层的具体选项名称，比如：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
对于 SOL\_SOCKET 选项，可以是 SO\_REUSEADDR（允许重用本地地址和端口） 、SO\_SNDTIMEO（设置发送数据超时时间）、SO\_SNDTIMEO（设置接收数据超时时间）、SO\_RCVBUF（设置发送数据缓冲区大小）等等。

\item {} 
\sphinxAtStartPar
对于 IPPROTO\_TCP 选项，可以是 TCP\_NODELAY（不使用 Nagle 算法）、TCP\_KEEPALIVE
（设置 TCP 保活时间）等等。

\item {} 
\sphinxAtStartPar
对于 IPPROTO\_IP 选项，可以是 IP\_TTL（设置生存时间）、IP\_TOS（设置服务类型）等等。

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define setsockopt(s,level,optname,opval,optlen) \PYGZbs{}}
\PYG{c+cp}{lwip\PYGZus{}setsockopt(s,level,optname,opval,optlen)}
\PYG{k+kt}{int}
\PYG{n}{lwip\PYGZus{}setsockopt}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{level}\PYG{p}{,}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{optname}\PYG{p}{,}
\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{void}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{optval}\PYG{p}{,}
\PYG{k+kt}{socklen\PYGZus{}t}\PYG{+w}{ }\PYG{n}{optlen}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{实验内容}
\label{\detokenize{exp-esp32/socket/tcp:id1}}
\sphinxAtStartPar
包含以下两个实验：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
ESP32作TCP server，网络调试助手\sphinxcode{\sphinxupquote{Netcat}}作TCP client

\item {} 
\sphinxAtStartPar
ESP32作TCP client，网络调试助手\sphinxcode{\sphinxupquote{Netcat}}做TCP server

\end{enumerate}


\subparagraph{网络调试助手\sphinxstyleliteralintitle{\sphinxupquote{netcat}}}
\label{\detokenize{exp-esp32/socket/tcp:netcat}}
\sphinxAtStartPar
Netcat，也称为nc，是一个网络工具，用于在计算机网络上进行数据传输和调试。它可以在不同计算机之间建立连接，并允许通过TCP或UDP协议发送和接收数据。

\sphinxAtStartPar
Netcat具有多种用途和功能，例如：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
端口扫描：通过指定目标IP地址和端口范围，可以使用Netcat来扫描目标主机上开放的端口。

\item {} 
\sphinxAtStartPar
文件传输：Netcat可以在两台计算机之间传输文件，作为简单的文件传输工具使用。

\item {} 
\sphinxAtStartPar
远程控制：通过建立反向连接或反向shell，可以使用Netcat来远程控制另一台计算机。

\item {} 
\sphinxAtStartPar
网络调试：Netcat可以用于测试网络连接、发送和接收数据，以及检查网络服务的可用性。

\end{enumerate}

\sphinxAtStartPar
Netcat的命令行界面简单易用，具有许多选项和参数，可以根据需要进行配置和定制。它在计算机安全领域、系统管理和网络开发中广泛使用，并被认为是一种功能强大的网络工具。

\sphinxAtStartPar
输入：\sphinxcode{\sphinxupquote{nc \sphinxhyphen{}h}}查看使用帮助。


\subparagraph{所需硬件}
\label{\detokenize{exp-esp32/socket/tcp:id2}}
\sphinxAtStartPar
ESP32开发板、microUSB 线、电脑。


\subparagraph{配置项目}
\label{\detokenize{exp-esp32/socket/tcp:id3}}
\sphinxAtStartPar
\sphinxstylestrong{命令行界面}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} /示例对应的目录
get\PYGZhy{}idf
idf.py menuconfig
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Clion界面}
\begin{itemize}
\item {} 
\sphinxAtStartPar
选择示例的文件夹并用Clion打开

\item {} 
\sphinxAtStartPar
添加各项配置（参考Clion下ESP\sphinxhyphen{}IDF的配置与开发）

\item {} 
\sphinxAtStartPar
选择 menuconfig 并运行

\item {} 
\sphinxAtStartPar
配置WIFI连接热点，PC和ESP32连接到同一个AP接入点，即必须在同一个网络中。

\item {} 
\sphinxAtStartPar
设置WiFi SSID

\item {} 
\sphinxAtStartPar
设置WiFi Password

\item {} 
\sphinxAtStartPar
选择 示例名.elf|Debug  并运行

\end{itemize}


\subparagraph{构建和烧录}
\label{\detokenize{exp-esp32/socket/tcp:id4}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：

\sphinxAtStartPar
\sphinxstylestrong{命令行界面：}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
idf.py \PYGZhy{}p PORT flash monitor
\end{sphinxVerbatim}

\sphinxAtStartPar
（要退出串行监视器，请键入Ctrl\sphinxhyphen{}{]}。）

\sphinxAtStartPar
\sphinxstylestrong{Clion界面：}
\begin{itemize}
\item {} 
\sphinxAtStartPar
选择 flash 并运行

\item {} 
\sphinxAtStartPar
选择 monitor 并运行

\end{itemize}


\subparagraph{交互操作与输出}
\label{\detokenize{exp-esp32/socket/tcp:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ESP32作TCP server，网络调试助手作TCP client时}

\end{itemize}

\sphinxAtStartPar
在烧录完成代码开始运行并打开监视器后，新打开一个终端，输入

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nc esp32\PYGZhy{}ipaddr \PYG{l+m}{3333}
\PYG{c+c1}{\PYGZsh{} esp32\PYGZhy{}ipaddr esp32链接wifi后自身的ip地址 }
\PYG{c+c1}{\PYGZsh{} 你设置的端口，默认为3333}
\end{sphinxVerbatim}

\sphinxAtStartPar
然后即可向ESP32发送字符，ESP32收到后会在监视器中显示，如图：

\sphinxAtStartPar
\sphinxincludegraphics{{2023-02-24173814}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ESP32作TCP client，网络调试助手做TCP server}，

\end{itemize}

\sphinxAtStartPar
请在配置时设置ip和端口，并且保证ip为电脑的ip，使用以下代码查看,如果报错提示未安装安装即可，

\sphinxAtStartPar
请以\sphinxcode{\sphinxupquote{ifconfig}}或\sphinxcode{\sphinxupquote{ip \sphinxhyphen{}4 a}}获取本机ip地址，请以自己的为准！！！

\begin{sphinxVerbatim}[commandchars=\\\{\}]
@ubuntu:\PYGZti{}\PYGZdl{} ifconfig
ens33: \PYG{n+nv}{flags}\PYG{o}{=}\PYG{l+m}{4163}\PYGZlt{}UP,BROADCAST,RUNNING,MULTICAST\PYGZgt{}  mtu \PYG{l+m}{1500}
        inet \PYG{l+m}{192}.168.131.133  netmask \PYG{l+m}{255}.255.255.3  broadcast \PYG{l+m}{192}.168.31.255
        inet6 fe80::68cbe0:7248  prefixlen \PYG{l+m}{64}  scopeid 0x20\PYGZlt{}link\PYGZgt{}
        ether \PYG{l+m}{00}:0c:29:82:fd:0e  txqueuelen \PYG{l+m}{1000}  \PYG{o}{(}以太网\PYG{o}{)}
        RX packets \PYG{l+m}{950}  bytes \PYG{l+m}{225709} \PYG{o}{(}\PYG{l+m}{225}.7 KB\PYG{o}{)}
        RX errors \PYG{l+m}{0}  dropped \PYG{l+m}{0}  overruns \PYG{l+m}{0}  frame \PYG{l+m}{0}
        TX packets \PYG{l+m}{669}  bytes \PYG{l+m}{83405} \PYG{o}{(}\PYG{l+m}{83}.4 KB\PYG{o}{)}
        TX errors \PYG{l+m}{0}  dropped \PYG{l+m}{0} overruns \PYG{l+m}{0}  carrier \PYG{l+m}{0}  collisions \PYG{l+m}{0}

lo: \PYG{n+nv}{flags}\PYG{o}{=}\PYG{l+m}{7}\PYGZlt{}UP,LOOPBACK,RUNNING\PYGZgt{}  mtu 
        inet \PYG{l+m}{127}.0.0.1  netmask \PYG{l+m}{255}.0.0.0
        inet6 ::1  prefixlen \PYG{l+m}{128}  scopeid 0x10\PYGZlt{}host\PYGZgt{}
        loop  txqueuelen \PYG{l+m}{1000}  \PYG{o}{(}本地环回\PYG{o}{)}
        RX packets \PYG{l+m}{206}  bytes \PYG{l+m}{18250} \PYG{o}{(}\PYG{l+m}{18}.2 KB\PYG{o}{)}
        RX errors \PYG{l+m}{0}  dropped \PYG{l+m}{0}  overruns \PYG{l+m}{0}  frame \PYG{l+m}{0}
        TX packets \PYG{l+m}{206}  bytes \PYG{l+m}{18250} \PYG{o}{(}\PYG{l+m}{18}.2 KB\PYG{o}{)}
        TX errors \PYG{l+m}{0}  dropped \PYG{l+m}{0} overruns \PYG{l+m}{0}  carrier \PYG{l+m}{0}  collisions \PYG{l+m}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
在烧录完成后，开始运行并打开监视器，新打开一个终端，输入

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nc \PYGZhy{}l \PYG{l+m}{3333}
\PYG{c+c1}{\PYGZsh{}（对应自设置的端口，默认3333）}
\end{sphinxVerbatim}

\sphinxAtStartPar
然后即可收到ESP32发送的字符，ESP32也能收到电脑端发送的并会在监视器中显示，如图。

\sphinxAtStartPar
\sphinxincludegraphics{{2023-02-24201434}.png}


\paragraph{源代码参考}
\label{\detokenize{exp-esp32/socket/tcp:id6}}
\sphinxAtStartPar
参见{\hyperref[\detokenize{reference::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{参考资料与源代码}}}}

\sphinxstepscope


\subsubsection{UDP Server and Client}
\label{\detokenize{exp-esp32/socket/udp:udp-server-and-client}}\label{\detokenize{exp-esp32/socket/udp::doc}}
\sphinxAtStartPar
coming soon

\sphinxstepscope


\section{WebSocket over WiFi}
\label{\detokenize{exp-esp32/websocket:websocket-over-wifi}}\label{\detokenize{exp-esp32/websocket::doc}}

\subsection{概述}
\label{\detokenize{exp-esp32/websocket:id1}}
\sphinxAtStartPar
WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。


\subsection{特征}
\label{\detokenize{exp-esp32/websocket:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
支持基于 TCP 的 WebSocket、带有 mbedtls 的 TLS

\item {} 
\sphinxAtStartPar
使用 URI 轻松设置

\item {} 
\sphinxAtStartPar
多个实例（一个应用程序中可以有多个客户端）

\end{itemize}


\subsection{配置}
\label{\detokenize{exp-esp32/websocket:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
支持ws,wss计划

\item {} 
\sphinxAtStartPar
WebSocket 示例：
\begin{itemize}
\item {} 
\sphinxAtStartPar
ws://echo.websocket.org：基于 TCP 的 WebSocket，默认端口 80

\item {} 
\sphinxAtStartPar
wss://echo.websocket.org：基于 SSL 的 WebSocket，默认端口 443

\end{itemize}

\end{itemize}


\subsection{发送文本数据}
\label{\detokenize{exp-esp32/websocket:id4}}
\sphinxAtStartPar
WebSocket 客户端支持以文本数据帧的形式发送数据，它通知应用层负载数据是编码为 UTF\sphinxhyphen{}8 的文本数据。例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}send\PYGZus{}text}\PYG{p}{(}\PYG{n}{client}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{len}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{portMAX\PYGZus{}DELAY}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{API 参考}
\label{\detokenize{exp-esp32/websocket:api}}

\subsubsection{功能}
\label{\detokenize{exp-esp32/websocket:id5}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}handle\PYGZus{}tesp\PYGZus{}websocket\PYGZus{}client\PYGZus{}init}\PYG{p}{(}\PYG{n}{constesp\PYGZus{}websocket\PYGZus{}client\PYGZus{}config\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{config}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
启动 Websocket 会话 该函数必须是第一个调用的函数，它返回一个 esp\_websocket\_client\_handle\_t，您必须将其用作接口中其他函数的输入。当操作完成时，此调用必须有对 esp\_websocket\_client\_destroy 的相应调用。

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
esp\_websocket\_client\_handle\_t

\item {} 
\sphinxAtStartPar
如果有任何错误，则为 NULL

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}in{]} config: 配置

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}tesp\PYGZus{}websocket\PYGZus{}client\PYGZus{}set\PYGZus{}uri}\PYG{p}{(}\PYG{n}{esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}handle\PYGZus{}tclient}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{uri}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
为客户端设置 URL，执行此行为时，URL 中的选项将替换旧选项 如果客户端已连接，则必须在设置 URI 之前停止 WebSocket 客户端。

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
esp\_err\_t

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}in{]} client： 客户端

\item {} 
\sphinxAtStartPar
{[}in{]} uri: URI

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}t}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}start}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}handle\PYGZus{}tclient}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
打开 WebSocket 连接。

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
esp\_err\_t

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}in{]} client： 客户端

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}t}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}stop}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}handle\PYGZus{}tclient}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
在没有 websocket 关闭握手的情况下停止 WebSocket 连接。

\sphinxAtStartPar
此 API 停止 ws 客户端并直接关闭 TCP 连接，而不发送关闭帧。使用 esp\_websocket\_client\_close() 以干净的方式关闭连接是一个好习惯。

\sphinxAtStartPar
注意：
\begin{itemize}
\item {} 
\sphinxAtStartPar
无法从 websocket 事件处理程序调用

\end{itemize}

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
esp\_err\_t

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}in{]} client： 客户端

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}t}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}destroy}\PYG{p}{(}\PYG{+w}{ }\PYG{n}{esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}handle\PYGZus{}tclient}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
销毁 WebSocket 连接并释放所有资源。此函数必须是调用会话的最后一个函数。它与 esp\_websocket\_client\_init 函数相反，必须使用与 esp\_websocket\_client\_init 调用返回的输入相同的句柄来调用。这可能会关闭此句柄已使用的所有连接。

\sphinxAtStartPar
注意：
\begin{itemize}
\item {} 
\sphinxAtStartPar
无法从 websocket 事件处理程序调用

\end{itemize}

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
esp\_err\_t

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}in{]} client： 客户端

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}tesp\PYGZus{}websocket\PYGZus{}client\PYGZus{}close}\PYG{p}{(}\PYG{n}{esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}handle\PYGZus{}tclient}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{TickType\PYGZus{}t}\PYG{+w}{ }\PYG{n}{timeout}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
以干净的方式关闭 WebSocket 连接。

\sphinxAtStartPar
客户端发起的干净关闭顺序：
\begin{itemize}
\item {} 
\sphinxAtStartPar
客户端发送 CLOSE 帧

\item {} 
\sphinxAtStartPar
客户端等待服务器回显 CLOSE 帧

\item {} 
\sphinxAtStartPar
客户端等待服务器关闭连接

\item {} 
\sphinxAtStartPar
客户端停止的方式与esp\_websocket\_client\_stop()

\end{itemize}

\sphinxAtStartPar
注意：
\begin{itemize}
\item {} 
\sphinxAtStartPar
无法从 websocket 事件处理程序调用

\end{itemize}

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
esp\_err\_t

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}in{]} client： 客户端

\item {} 
\sphinxAtStartPar
{[}in{]} timeout: RTOS 计时超时等待

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{esp\PYGZus{}err\PYGZus{}tesp\PYGZus{}websocket\PYGZus{}client\PYGZus{}close\PYGZus{}with\PYGZus{}code}\PYG{p}{(}\PYG{n}{esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}handle\PYGZus{}tclient}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{code}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{data}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{len}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{TickType\PYGZus{}t}\PYG{+w}{ }\PYG{n}{timeout}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
使用自定义代码/数据以干净的方式关闭 WebSocket 连接关闭顺序与 esp\_websocket\_client\_close() 相同

\sphinxAtStartPar
注意：
\begin{itemize}
\item {} 
\sphinxAtStartPar
无法从 websocket 事件处理程序调用

\end{itemize}

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
esp\_err\_t

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}in{]} client： 客户端

\item {} 
\sphinxAtStartPar
{[}in{]} code: 关闭状态码定义在 RFC6455 section\sphinxhyphen{}7.4

\item {} 
\sphinxAtStartPar
{[}in{]} data：关闭消息的附加数据

\item {} 
\sphinxAtStartPar
{[}in{]} len: 附加数据的长度

\item {} 
\sphinxAtStartPar
{[}in{]} timeout: RTOS 计时超时等待

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}is\PYGZus{}connected（esp\PYGZus{}websocket\PYGZus{}client\PYGZus{}handle\PYGZus{}tclient）
\end{sphinxVerbatim}

\sphinxAtStartPar
检查 WebSocket 客户端连接状态。

\sphinxAtStartPar
返回
\begin{itemize}
\item {} 
\sphinxAtStartPar
true

\item {} 
\sphinxAtStartPar
false

\end{itemize}

\sphinxAtStartPar
参数
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}in{]} client: 客户端句柄

\end{itemize}

\sphinxAtStartPar
❗以上为部分常见常用API，更多请参考乐鑫官方 ESP\sphinxhyphen{}IDF编程指南\sphinxhyphen{}API参考\sphinxhyphen{}协议


\subsection{Websocket 示例应用程序}
\label{\detokenize{exp-esp32/websocket:websocket}}
\sphinxAtStartPar
这个示例将展示如何通过 websocket 进行设置和通信。


\subsection{配置项目}
\label{\detokenize{exp-esp32/websocket:id6}}
\sphinxAtStartPar
命令行界面

\sphinxAtStartPar
打开项目配置菜单 ( idf.py menuconfig)

\sphinxAtStartPar
Clion界面

\sphinxAtStartPar
选择示例的文件夹并用Clion打开

\sphinxAtStartPar
添加各项配置（参考Clion下ESP\sphinxhyphen{}IDF的配置与开发）

\sphinxAtStartPar
选择 menuconfig 并运行
\begin{itemize}
\item {} 
\sphinxAtStartPar
在“Example Connection Configuration”菜单下配置 Wi\sphinxhyphen{}Fi 或以太网。

\item {} 
\sphinxAtStartPar
在“Example Connection Configuration”下配置 websocket 端点 URI，如果选择“WEBSOCKET\_URI\_FROM\_STDIN”，则示例应用程序将连接到它从标准输入读取的 URI（用于测试）

\end{itemize}


\subsection{构建和烧录}
\label{\detokenize{exp-esp32/websocket:id7}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：

\sphinxAtStartPar
命令行界面：

\sphinxAtStartPar
idf.py \sphinxhyphen{}p PORT flash monitor
（要退出串行监视器，请键入Ctrl\sphinxhyphen{}{]}。）

\sphinxAtStartPar
Clion界面：

\sphinxAtStartPar
选择 flash 并运行

\sphinxAtStartPar
选择 monitor 并运行


\subsection{示例输出}
\label{\detokenize{exp-esp32/websocket:id8}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{482}\PYG{o}{)} system\PYGZus{}api: Base MAC address is not set, \PYG{n+nb}{read} default base MAC address from BLK0 of EFUSE
I \PYG{o}{(}\PYG{l+m}{2492}\PYG{o}{)} example\PYGZus{}connect: Ethernet Link Up
I \PYG{o}{(}\PYG{l+m}{4472}\PYG{o}{)} tcpip\PYGZus{}adapter: eth ip: \PYG{l+m}{192}.168.2.137, mask: \PYG{l+m}{255}.255.255.0, gw: \PYG{l+m}{192}.168.2.2
I \PYG{o}{(}\PYG{l+m}{4472}\PYG{o}{)} example\PYGZus{}connect: Connected to Ethernet
I \PYG{o}{(}\PYG{l+m}{4472}\PYG{o}{)} example\PYGZus{}connect: IPv4 address: \PYG{l+m}{192}.168.2.137
I \PYG{o}{(}\PYG{l+m}{4472}\PYG{o}{)} example\PYGZus{}connect: IPv6 address: fe80:0000:0000:0000:bedd:c2ff:fed4:a92b
I \PYG{o}{(}\PYG{l+m}{4482}\PYG{o}{)} WEBSOCKET: Connecting to ws://echo.websocket.org...
I \PYG{o}{(}\PYG{l+m}{5012}\PYG{o}{)} WEBSOCKET: WEBSOCKET\PYGZus{}EVENT\PYGZus{}CONNECTED
I \PYG{o}{(}\PYG{l+m}{5492}\PYG{o}{)} WEBSOCKET: Sending hello \PYG{l+m}{0000}
I \PYG{o}{(}\PYG{l+m}{6052}\PYG{o}{)} WEBSOCKET: WEBSOCKET\PYGZus{}EVENT\PYGZus{}DATA
W \PYG{o}{(}\PYG{l+m}{6052}\PYG{o}{)} WEBSOCKET: \PYG{n+nv}{Received}\PYG{o}{=}hello \PYG{l+m}{0000}

I \PYG{o}{(}\PYG{l+m}{6492}\PYG{o}{)} WEBSOCKET: Sending hello \PYG{l+m}{0001}
I \PYG{o}{(}\PYG{l+m}{7052}\PYG{o}{)} WEBSOCKET: WEBSOCKET\PYGZus{}EVENT\PYGZus{}DATA
W \PYG{o}{(}\PYG{l+m}{7052}\PYG{o}{)} WEBSOCKET: \PYG{n+nv}{Received}\PYG{o}{=}hello \PYG{l+m}{0001}

I \PYG{o}{(}\PYG{l+m}{7492}\PYG{o}{)} WEBSOCKET: Sending hello \PYG{l+m}{0002}
I \PYG{o}{(}\PYG{l+m}{8082}\PYG{o}{)} WEBSOCKET: WEBSOCKET\PYGZus{}EVENT\PYGZus{}DATA
W \PYG{o}{(}\PYG{l+m}{8082}\PYG{o}{)} WEBSOCKET: \PYG{n+nv}{Received}\PYG{o}{=}hello \PYG{l+m}{0002}

I \PYG{o}{(}\PYG{l+m}{8492}\PYG{o}{)} WEBSOCKET: Sending hello \PYG{l+m}{0003}
I \PYG{o}{(}\PYG{l+m}{9152}\PYG{o}{)} WEBSOCKET: WEBSOCKET\PYGZus{}EVENT\PYGZus{}DATA
W \PYG{o}{(}\PYG{l+m}{9162}\PYG{o}{)} WEBSOCKET: \PYG{n+nv}{Received}\PYG{o}{=}hello \PYG{l+m}{0003}
\end{sphinxVerbatim}

\sphinxstepscope


\section{HTTP over WiFi}
\label{\detokenize{exp-esp32/http:http-over-wifi}}\label{\detokenize{exp-esp32/http::doc}}

\subsection{概述}
\label{\detokenize{exp-esp32/http:id1}}
\sphinxAtStartPar
超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。

\sphinxAtStartPar
HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。

\sphinxAtStartPar
尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。

\sphinxAtStartPar
通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，以及返回的内容，如请求的文件、错误消息、或者其它信息。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220810095606808}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
基于 请求\sphinxhyphen{}响应 的模式

\sphinxAtStartPar
HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应。

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220810100611513}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
无状态保存

\sphinxAtStartPar
HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于发送过的请求或响应都不做持久化处理。

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220810100908429}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
无连接

\sphinxAtStartPar
无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是现在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间。

\end{itemize}


\subsection{代码API}
\label{\detokenize{exp-esp32/http:api}}
\sphinxAtStartPar
对于HTTP Server 和 Client的API函数，此次不做赘述，具体可参考乐鑫ESP开发文档
\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP HTTP Server

\sphinxAtStartPar
https://docs.espressif.com/projects/esp\sphinxhyphen{}idf/zh\_CN/v4.4.1/esp32/api\sphinxhyphen{}reference/protocols/esp\_http\_server.html

\item {} 
\sphinxAtStartPar
ESP HTTP Client

\sphinxAtStartPar
https://docs.espressif.com/projects/esp\sphinxhyphen{}idf/zh\_CN/v4.4.1/esp32/api\sphinxhyphen{}reference/protocols/esp\_http\_client.html

\end{itemize}


\subsection{简单的 HTTPD 服务器示例}
\label{\detokenize{exp-esp32/http:httpd}}
\sphinxAtStartPar
httpd是Apache超文本传输协议(HTTP)服务器的主程序。被设计为一个独立运行的后台进程，它会建立一个处理请求的子进程或线程的池。

\sphinxAtStartPar
该示例由 HTTPD 服务器演示和 URI 处理演示组成： 1. URI \textbackslash{}hello for GET 命令返回“Hello World！” 消息 2. URI \textbackslash{}echo for POST 命令回显 POSTed 消息


\subsubsection{软件准备：}
\label{\detokenize{exp-esp32/http:id2}}
\sphinxAtStartPar
后续测试需要用到CURL，使用CURL进行测试时，需要先安装CURL,命令行如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt install curl
\end{sphinxVerbatim}

\sphinxAtStartPar
安装完成成功后输入

\begin{sphinxVerbatim}[commandchars=\\\{\}]
curl \PYGZhy{}\PYGZhy{}version
\end{sphinxVerbatim}

\sphinxAtStartPar
如果有如下输出则安装成功

\begin{sphinxVerbatim}[commandchars=\\\{\}]
curl \PYG{l+m}{7}.68.0 \PYG{o}{(}x86\PYGZus{}64\PYGZhy{}pc\PYGZhy{}linux\PYGZhy{}gnu\PYG{o}{)} libcurl/7.68.0 OpenSSL/1.1.1f zlib/1.2.11 brotli/1.0.7 libidn2/2.2.0 libpsl/0.21.0 \PYG{o}{(}+libidn2/2.2.0\PYG{o}{)} libssh/0.9.3/openssl/zlib nghttp2/1.40.0 librtmp/2.3
Release\PYGZhy{}Date: \PYG{l+m}{2020}\PYGZhy{}01\PYGZhy{}08
Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp scp sftp smb smbs smtp smtps telnet tftp 
Features: AsynchDNS brotli GSS\PYGZhy{}API HTTP2 HTTPS\PYGZhy{}proxy IDN IPv6 Kerberos Largefile libz NTLM NTLM\PYGZus{}WB PSL SPNEGO SSL TLS\PYGZhy{}SRP UnixSockets
\end{sphinxVerbatim}


\subsubsection{配置项目}
\label{\detokenize{exp-esp32/http:id3}}
\sphinxAtStartPar
命令行界面

\sphinxAtStartPar
打开项目配置菜单 ( idf.py menuconfig)

\sphinxAtStartPar
Clion界面

\sphinxAtStartPar
选择示例的文件夹并用Clion打开

\sphinxAtStartPar
添加各项配置（参考Clion下ESP\sphinxhyphen{}IDF的配置与开发）

\sphinxAtStartPar
选择 menuconfig 并运行

\sphinxAtStartPar
在“Example Connection Configuration”菜单下配置 Wi\sphinxhyphen{}Fi 或以太网。


\subsection{构建和烧录}
\label{\detokenize{exp-esp32/http:id4}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：

\sphinxAtStartPar
命令行界面：

\sphinxAtStartPar
idf.py \sphinxhyphen{}p PORT flash monitor
（要退出串行监视器，请键入Ctrl\sphinxhyphen{}{]}。）

\sphinxAtStartPar
Clion界面：

\sphinxAtStartPar
选择 flash 并运行

\sphinxAtStartPar
选择 monitor 并运行


\subsubsection{示例输出}
\label{\detokenize{exp-esp32/http:id5}}
\sphinxAtStartPar
打开监视器后，查看esp32接入WiFi后取得的IP地址

\sphinxAtStartPar
打开终端，例如IP地址为192.168.43.130时，在终端中输入如下命令：（注意：端口  :80  不要更改，只更改IP）

\begin{sphinxVerbatim}[commandchars=\\\{\}]
curl \PYG{l+m}{192}.168.43.130:80/hello
\end{sphinxVerbatim}

\sphinxAtStartPar
接下来您会看到如下图情况：

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220809174013410}.png}

\sphinxAtStartPar
并且监视器中会有如下输出：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{9580}\PYG{o}{)} example\PYGZus{}connect: \PYGZhy{} IPv4 address: \PYG{l+m}{192}.168.194.219
I \PYG{o}{(}\PYG{l+m}{9580}\PYG{o}{)} example\PYGZus{}connect: \PYGZhy{} IPv6 address: fe80:0000:0000:0000:266f:28ff:fe80:2c74, type: ESP\PYGZus{}IP6\PYGZus{}ADDR\PYGZus{}IS\PYGZus{}LINK\PYGZus{}LOCAL
I \PYG{o}{(}\PYG{l+m}{9590}\PYG{o}{)} example: Starting server on port: \PYG{l+s+s1}{\PYGZsq{}80\PYGZsq{}}
I \PYG{o}{(}\PYG{l+m}{9600}\PYG{o}{)} example: Registering URI handlers
I \PYG{o}{(}\PYG{l+m}{66450}\PYG{o}{)} example: Found \PYG{n+nv}{header} \PYG{o}{=}\PYGZgt{} Host: \PYG{l+m}{192}.168.194.219
I \PYG{o}{(}\PYG{l+m}{66460}\PYG{o}{)} example: Request headers lost
\end{sphinxVerbatim}


\subsubsection{故障排除}
\label{\detokenize{exp-esp32/http:id6}}
\sphinxAtStartPar
如果服务器日志显示“httpd\_parse: parse\_block: request URI/header too long”，尤其是在处理POST请求时，那么你可能需要增加HTTPD\_MAX\_REQ\_HDR\_LEN，你可以在项目配置菜单（idf.py menuconfig）中找到：Component config \sphinxhyphen{}> HTTP Server \sphinxhyphen{}> Max HTTP Request Header Length

\sphinxAtStartPar
官方测试提示：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
run the \PYG{n+nb}{test} script : \PYG{l+s+s2}{\PYGZdq{}python scripts/client.py \PYGZbs{}\PYGZlt{}IP\PYGZbs{}\PYGZgt{} \PYGZbs{}\PYGZlt{}port\PYGZbs{}\PYGZgt{} \PYGZbs{}\PYGZlt{}MSG\PYGZbs{}\PYGZgt{}\PYGZdq{}}

the provided \PYG{n+nb}{test} script first does a GET \PYG{l+s+se}{\PYGZbs{}h}ello and displays the response

the script does a POST to \PYG{l+s+se}{\PYGZbs{}e}cho with the user input \PYG{l+s+se}{\PYGZbs{}\PYGZlt{}}MSG\PYG{l+s+se}{\PYGZbs{}\PYGZgt{}} and displays the response

or use curl \PYG{o}{(}asssuming IP is \PYG{l+m}{192}.168.43.130\PYG{o}{)}:

\PYG{l+s+s2}{\PYGZdq{}curl 192.168.43.130:80/hello\PYGZdq{}}  \PYGZhy{} tests the GET \PYG{l+s+s2}{\PYGZdq{}\PYGZbs{}hello\PYGZdq{}} handler

\PYG{l+s+s2}{\PYGZdq{}curl \PYGZhy{}X POST \PYGZhy{}\PYGZhy{}data\PYGZhy{}binary @anyfile 192.168.43.130:80/echo \PYGZgt{} tmpfile\PYGZdq{}}

\PYG{l+s+s2}{\PYGZdq{}anyfile\PYGZdq{}} is the file being sent as request body and \PYG{l+s+s2}{\PYGZdq{}tmpfile\PYGZdq{}} is where the body of the response is saved

since the server echoes back the request body, the two files should be same, as can be confirmed using : \PYG{l+s+s2}{\PYGZdq{}cmp anyfile tmpfile\PYGZdq{}}

\PYG{l+s+s2}{\PYGZdq{}curl \PYGZhy{}X PUT \PYGZhy{}d \PYGZdq{}}\PYG{l+m}{0}\PYG{l+s+s2}{\PYGZdq{} 192.168.43.130:80/ctrl\PYGZdq{}} \PYGZhy{} disable /hello and /echo handlers

\PYG{l+s+s2}{\PYGZdq{}curl \PYGZhy{}X PUT \PYGZhy{}d \PYGZdq{}}\PYG{l+m}{1}\PYG{l+s+s2}{\PYGZdq{} 192.168.43.130:80/ctrl\PYGZdq{}} \PYGZhy{}  \PYG{n+nb}{enable} /hello and /echo handlers
\end{sphinxVerbatim}


\subsection{HTTP 请求 示例}
\label{\detokenize{exp-esp32/http:http}}
\sphinxAtStartPar
使用 POSIX 套接字发出非常简单的 HTTP 请求。


\subsubsection{配置项目}
\label{\detokenize{exp-esp32/http:id7}}
\sphinxAtStartPar
命令行界面

\sphinxAtStartPar
打开项目配置菜单 ( idf.py menuconfig)

\sphinxAtStartPar
Clion界面

\sphinxAtStartPar
选择示例的文件夹并用Clion打开

\sphinxAtStartPar
添加各项配置（参考Clion下ESP\sphinxhyphen{}IDF的配置与开发）

\sphinxAtStartPar
选择 menuconfig 并运行

\sphinxAtStartPar
在“Example Connection Configuration”菜单下配置 Wi\sphinxhyphen{}Fi 或以太网。


\subsubsection{构建和烧录}
\label{\detokenize{exp-esp32/http:id8}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：

\sphinxAtStartPar
命令行界面：

\sphinxAtStartPar
idf.py \sphinxhyphen{}p PORT flash monitor
（要退出串行监视器，请键入Ctrl\sphinxhyphen{}{]}。）

\sphinxAtStartPar
Clion界面：

\sphinxAtStartPar
选择 flash 并运行

\sphinxAtStartPar
选择 monitor 并运行


\subsubsection{示例输出}
\label{\detokenize{exp-esp32/http:id9}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
I \PYG{o}{(}\PYG{l+m}{10557}\PYG{o}{)} example\PYGZus{}connect: \PYGZhy{} IPv4 address: \PYG{l+m}{192}.168.194.219
I \PYG{o}{(}\PYG{l+m}{10557}\PYG{o}{)} example\PYGZus{}connect: \PYGZhy{} IPv6 address: fe80:0000:0000:0000:266f:28ff:fe80:2c74, type: ESP\PYGZus{}IP6\PYGZus{}ADDR\PYGZus{}IS\PYGZus{}LINK\PYGZus{}LOCAL
W \PYG{o}{(}\PYG{l+m}{10577}\PYG{o}{)} wifi:\PYGZlt{}ba\PYGZhy{}add\PYGZgt{}idx:0 \PYG{o}{(}ifx:0, ee:6d:19:60:f6:0e\PYG{o}{)}, tid:0, ssn:3, winSize:64
I \PYG{o}{(}\PYG{l+m}{10587}\PYG{o}{)} example: DNS lookup succeeded. \PYG{n+nv}{IP}\PYG{o}{=}\PYG{l+m}{93}.184.216.34
I \PYG{o}{(}\PYG{l+m}{10587}\PYG{o}{)} example: ... allocated socket
I \PYG{o}{(}\PYG{l+m}{10917}\PYG{o}{)} example: ... connected
I \PYG{o}{(}\PYG{l+m}{10917}\PYG{o}{)} example: ... socket send success
I \PYG{o}{(}\PYG{l+m}{10927}\PYG{o}{)} example: ... \PYG{n+nb}{set} socket receiving timeout success
HTTP/1.0 \PYG{l+m}{200} OK
Age: \PYG{l+m}{317271}
Cache\PYGZhy{}Control: max\PYGZhy{}age\PYG{o}{=}\PYG{l+m}{604800}
Content\PYGZhy{}Type: text/html\PYG{p}{;} \PYG{n+nv}{charset}\PYG{o}{=}UTF\PYGZhy{}8
Date: Mon, \PYG{l+m}{06} Sep \PYG{l+m}{2021} \PYG{l+m}{08}:09:49 GMT
Etag: \PYG{l+s+s2}{\PYGZdq{}3147526947+ident\PYGZdq{}}
Expires: Mon, \PYG{l+m}{13} Sep \PYG{l+m}{2021} \PYG{l+m}{08}:09:49 GMT
Last\PYGZhy{}Modified: Thu, \PYG{l+m}{17} Oct \PYG{l+m}{2019} \PYG{l+m}{07}:18:26 GMT
Server: ECS \PYG{o}{(}nyb/1D2B\PYG{o}{)}
Vary: Accept\PYGZhy{}Encoding
X\PYGZhy{}Cache: HIT
Content\PYGZhy{}Length: \PYG{l+m}{1256}
Connection: close

\PYGZlt{}!doctype html\PYGZgt{}
\PYGZlt{}html\PYGZgt{}

\PYGZlt{}head\PYGZgt{}
    \PYGZlt{}title\PYGZgt{}Example Domain\PYGZlt{}/title\PYGZgt{}

\PYGZlt{}meta \PYG{n+nv}{charset}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}utf\PYGZhy{}8\PYGZdq{}} /\PYGZgt{}
\PYGZlt{}meta http\PYGZhy{}equiv\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}Content\PYGZhy{}type\PYGZdq{}} \PYG{n+nv}{content}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}text/html; charset=utf\PYGZhy{}8\PYGZdq{}} /\PYGZgt{}
\PYGZlt{}meta \PYG{n+nv}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}viewport\PYGZdq{}} \PYG{n+nv}{content}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}width=device\PYGZhy{}width, initial\PYGZhy{}scale=1\PYGZdq{}} /\PYGZgt{}
\PYGZlt{}style \PYG{n+nv}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}text/css\PYGZdq{}}\PYGZgt{}
body \PYG{o}{\PYGZob{}}
    background\PYGZhy{}color: \PYG{c+c1}{\PYGZsh{}f0f0f2;}
    margin: \PYG{l+m}{0}\PYG{p}{;}
    padding: \PYG{l+m}{0}\PYG{p}{;}
    font\PYGZhy{}family: \PYGZhy{}apple\PYGZhy{}system, system\PYGZhy{}ui, BlinkMacSystemFont, \PYG{l+s+s2}{\PYGZdq{}Segoe UI\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}Open Sans\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}Helvetica Neue\PYGZdq{}}, Helvetica, Arial, sans\PYGZhy{}serif\PYG{p}{;}

\PYG{o}{\PYGZcb{}}
div \PYG{o}{\PYGZob{}}
    width: 600px\PYG{p}{;}
    margin: 5em auto\PYG{p}{;}
    padding: 2em\PYG{p}{;}
    background\PYGZhy{}color: \PYG{c+c1}{\PYGZsh{}fdfdff;}
    border\PYGZhy{}radius: \PYG{l+m}{0}.5em\PYG{p}{;}
    box\PYGZhy{}shadow: 2px 3px 7px 2px rgba\PYG{o}{(}\PYG{l+m}{0},0,0,0.02\PYG{o}{)}\PYG{p}{;}
\PYG{o}{\PYGZcb{}}
a:link, a:visited \PYG{o}{\PYGZob{}}
    color: \PYG{c+c1}{\PYGZsh{}38488f;}
    text\PYGZhy{}decoration: none\PYG{p}{;}
\PYG{o}{\PYGZcb{}}
@media \PYG{o}{(}max\PYGZhy{}width: 700px\PYG{o}{)} \PYG{o}{\PYGZob{}}
    div \PYG{o}{\PYGZob{}}
        margin: \PYG{l+m}{0} auto\PYG{p}{;}
        width: auto\PYG{p}{;}
    \PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\PYGZlt{}/style\PYGZgt{}    

\PYGZlt{}/head\PYGZgt{}

\PYGZlt{}body\PYGZgt{}

\PYGZlt{}div\PYGZgt{}
    \PYGZlt{}h1\PYGZgt{}Example Domain\PYGZlt{}/h1\PYGZgt{}
    \PYGZlt{}p\PYGZgt{}This domain is \PYG{k}{for} use \PYG{k}{in} illustrative examples \PYG{k}{in} documents. You may use this
    domain \PYG{k}{in} literature without prior coordination or asking \PYG{k}{for} permission.\PYGZlt{}/p\PYGZgt{}
    \PYGZlt{}p\PYGZgt{}\PYGZlt{}a \PYG{n+nv}{href}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}https://www.iana.org/domains/example\PYGZdq{}}\PYGZgt{}More information...\PYGZlt{}/a\PYGZgt{}\PYGZlt{}/p\PYGZgt{}
\PYGZlt{}/div\PYGZgt{}

\PYGZlt{}/body\PYGZgt{}
\PYGZlt{}/html\PYGZgt{}
I \PYG{o}{(}\PYG{l+m}{11467}\PYG{o}{)} example: ... \PYG{k}{done} reading from socket. Last \PYG{n+nb}{read} \PYG{k}{return}\PYG{o}{=}\PYG{l+m}{0} \PYG{n+nv}{errno}\PYG{o}{=}\PYG{l+m}{128}.
I \PYG{o}{(}\PYG{l+m}{11477}\PYG{o}{)} example: \PYG{l+m}{10}... 
I \PYG{o}{(}\PYG{l+m}{12477}\PYG{o}{)} example: \PYG{l+m}{9}... 
I \PYG{o}{(}\PYG{l+m}{13477}\PYG{o}{)} example: \PYG{l+m}{8}... 
\end{sphinxVerbatim}

\sphinxstepscope


\section{MQTT over WiFi}
\label{\detokenize{exp-esp32/mqtt:mqtt-over-wifi}}\label{\detokenize{exp-esp32/mqtt::doc}}

\subsection{实验目的}
\label{\detokenize{exp-esp32/mqtt:id1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
了解MQTT代理，主题，发布、订阅模式等概念

\item {} 
\sphinxAtStartPar
编写代码实现ESP32作为发布者向EMQX发布主题

\item {} 
\sphinxAtStartPar
编写代码实现ESP32作为订阅者向EMQX订阅主题

\end{itemize}


\subsection{MQTT简介}
\label{\detokenize{exp-esp32/mqtt:mqtt}}
\sphinxAtStartPar
MQTT（Message Queuing Telemetry Transport）是一种轻量级的通信协议，专门设计用于物联网（IoT）设备之间的通信。它是一个基于发布/订阅模式的协议，允许设备通过中间代理（broker）进行异步通信。

\sphinxAtStartPar
以下是MQTT的一些关键特点和概念：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
轻量级：MQTT协议设计简单，通信消息头部开销小，适用于低带宽和不稳定网络环境，以及资源受限的设备。

\item {} 
\sphinxAtStartPar
发布/订阅模式：MQTT使用发布/订阅模式进行消息传递。设备可以作为发布者（publisher）将消息发布到主题（topic），而其他设备可以作为订阅者（subscriber）订阅感兴趣的主题。这种解耦的模式使得设备之间的通信更加灵活和可扩展。

\item {} 
\sphinxAtStartPar
主题（Topic）：主题是MQTT中消息的分类标识符。发布者发布消息到特定主题，而订阅者可以订阅一个或多个主题以接收相应的消息。

\item {} 
\sphinxAtStartPar
代理（Broker）：MQTT通信的中间代理称为代理或者消息代理（broker）。代理负责接收发布者的消息，并将其分发给订阅了相应主题的订阅者。代理可以处理订阅者的注册和管理，确保消息的可靠传递。

\item {} 
\sphinxAtStartPar
QoS（Quality of Service）：MQTT定义了三个不同级别的消息传递质量：QoS 0（至多一次）、QoS 1（至少一次）和QoS 2（恰好一次）。QoS级别决定了消息的可靠性和传递机制。

\item {} 
\sphinxAtStartPar
连接和会话：MQTT使用基于TCP/IP的长连接进行通信。设备通过建立连接到代理并保持会话，以便进行消息的发布和订阅。这种长连接的机制可以减少网络开销和延迟。

\end{enumerate}

\sphinxAtStartPar
MQTT广泛应用于物联网领域，特别适合于传感器、嵌入式设备和其他资源受限的设备之间的通信。它的轻量级和灵活性使得MQTT成为连接大规模设备网络的理想选择。


\subsection{EMQX简介}
\label{\detokenize{exp-esp32/mqtt:emqx}}
\sphinxAtStartPar
\sphinxhref{https://www.emqx.io/zh}{EMQX}是一款开源的高度可扩展的MQTT消息代理（broker），它是建立在Erlang/OTP平台上的，专为物联网和实时通信应用而设计。

\sphinxAtStartPar
EMQ X具有以下主要特点：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
高可扩展性：EMQ X使用Erlang/OTP的并发模型和可伸缩性，能够轻松处理大规模设备网络的消息传递。它支持水平扩展，可以通过增加节点来增加系统的容量和吞吐量。

\item {} 
\sphinxAtStartPar
MQTT支持：作为一款MQTT消息代理，EMQ X完全兼容MQTT协议版本3.1和3.1.1。它支持发布/订阅模式、QoS级别、保留消息、遗嘱消息和持久化订阅等核心功能。

\item {} 
\sphinxAtStartPar
安全性：EMQ X提供多种安全机制来保护消息传递的机密性和完整性。它支持TLS/SSL加密传输，可以使用用户名和密码进行身份验证，还支持访问控制列表（ACL）以限制设备的访问权限。

\item {} 
\sphinxAtStartPar
多协议支持：除了MQTT，EMQ X还支持其他通信协议，如MQTT\sphinxhyphen{}SN、CoAP、AMQP等。这使得它能够与不同类型的设备和应用集成，并提供统一的消息中间件解决方案。

\item {} 
\sphinxAtStartPar
实时数据处理：EMQ X内置了强大的实时数据处理和规则引擎，称为EMQ X Rule Engine。它可以对设备发送的消息进行筛选、转发、转换和存储等操作，实现实时数据的处理和分析。

\item {} 
\sphinxAtStartPar
高可用性和容错性：EMQ X支持集群模式和故障转移，确保系统的高可用性和容错性。当一个节点发生故障时，其他节点可以接管服务，保证消息传递的连续性。

\end{enumerate}

\sphinxAtStartPar
EMQ X广泛应用于物联网、智能家居、工业自动化、智能交通等领域，为设备之间的可靠通信提供了可靠的基础架构和强大的功能。作为开源软件，它也得到了一个活跃的社区的支持和贡献。


\subsection{实验内容}
\label{\detokenize{exp-esp32/mqtt:id2}}

\subsubsection{所需软硬件}
\label{\detokenize{exp-esp32/mqtt:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP32开发板

\item {} 
\sphinxAtStartPar
PC机

\item {} 
\sphinxAtStartPar
EMQX Broker：
\begin{itemize}
\item {} 
\sphinxAtStartPar
地址：\sphinxcode{\sphinxupquote{8.134.62.44}}

\item {} 
\sphinxAtStartPar
web UI：\sphinxcode{\sphinxupquote{http://8.134.62.44:8082}}

\end{itemize}

\item {} 
\sphinxAtStartPar
EMQX client：\sphinxcode{\sphinxupquote{MQTT X}}

\end{itemize}


\subsubsection{实验方案}
\label{\detokenize{exp-esp32/mqtt:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
ESP32作为publisher，MQTT X作为subcriber，通过EMQX Broker交换数据

\item {} 
\sphinxAtStartPar
ESP32作为subcriber，MQTT X作为publisher，通过EMQX Broker交换数据

\end{itemize}


\subsubsection{安装客户端MQTTX}
\label{\detokenize{exp-esp32/mqtt:mqttx}}
\sphinxAtStartPar
MQTT X为跨平台的MQTT客户端，可在官方页面\sphinxhref{https://mqttx.app/zh}{下载}安装。对于UBUNTU系统可直接通过以下命令安装

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{snap} \PYG{n}{install} \PYG{n}{mqttx}
\end{sphinxVerbatim}


\subsubsection{主题与负载定义}
\label{\detokenize{exp-esp32/mqtt:id5}}
\sphinxAtStartPar
在EMQX，可以自定义主题，为了配合和下一节的thingsboard使用，本节实验使用已定义的主题内容：


\paragraph{主题}
\label{\detokenize{exp-esp32/mqtt:id6}}
\sphinxAtStartPar
1 遥测数据

\begin{sphinxVerbatim}[commandchars=\\\{\}]
v1/devices/me/telemetry
\end{sphinxVerbatim}

\sphinxAtStartPar
2 设备属性

\begin{sphinxVerbatim}[commandchars=\\\{\}]
v1/devices/me/attributes
\end{sphinxVerbatim}


\paragraph{负载}
\label{\detokenize{exp-esp32/mqtt:id7}}
\sphinxAtStartPar
负载以json数据格式表达：行如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}key1\PYGZdq{}}\PYG{o}{:}\PYG{l+s+s2}{\PYGZdq{}value1\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}key2\PYGZdq{}}\PYG{o}{:}\PYG{l+s+s2}{\PYGZdq{}value2\PYGZdq{}}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{ESP32作为publisher}
\label{\detokenize{exp-esp32/mqtt:esp32publisher}}

\subsubsection{ESP32作为subscriber}
\label{\detokenize{exp-esp32/mqtt:esp32subscriber}}
\sphinxstepscope


\section{CoAP over WiFi}
\label{\detokenize{exp-esp32/coap:coap-over-wifi}}\label{\detokenize{exp-esp32/coap::doc}}

\subsection{概述}
\label{\detokenize{exp-esp32/coap:id1}}
\sphinxAtStartPar
Coap（Constrained Application Protocol）是一种在物联网世界的类web协议，它的详细规范定义在 RFC 7252。COAP名字翻译来就是“受限应用协议”，顾名思义，使用在资源受限的物联网设备上。物联网设备的ram，rom都通常非常小，运行TCP和HTTP是不可以接受的。
\sphinxincludegraphics{{image-20220808102849628}.png}


\subsection{Coap协议介绍}
\label{\detokenize{exp-esp32/coap:coap}}

\subsubsection{Coap协议特点}
\label{\detokenize{exp-esp32/coap:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
COAP协议网络传输层由TCP改为UDP。

\item {} 
\sphinxAtStartPar
它基于REST，server的资源地址和互联网一样也有类似url的格式，客户端同样有POST，GET,PUT,DELETE方法来访问server，HTTP做了简化。

\item {} 
\sphinxAtStartPar
COAP是二进制格式的，HTTP是文本格式的，COAP比HTTP更加紧凑。

\item {} 
\sphinxAtStartPar
轻量化，COAP最小长度仅仅4B，一个HTTP的头都几十个B了。

\item {} 
\sphinxAtStartPar
支持可靠传输，数据重传，块传输。确保数据可靠到达。

\item {} 
\sphinxAtStartPar
支持IP多播，即可以同时向多个设备发送请求。

\item {} 
\sphinxAtStartPar
非长连接通信，适用于低功耗物联网场景。

\end{itemize}


\subsubsection{Coap协议消息类型}
\label{\detokenize{exp-esp32/coap:id3}}
\sphinxAtStartPar
COAP协议有4种消息类型：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
CON—— 需要被确认的请求，如果CON请求被发送，那么对方必须做出响应。这有点像TCP，对方必须给确认收到消息，用以可靠消息传输。

\item {} 
\sphinxAtStartPar
NON—— 不需要被确认的请求，如果NON请求被发送，那么对方不必做出回应。这适用于消息会重复频繁的发送，丢包不影响正常操作。这个和UDP很像。用以不可靠消息传输。

\item {} 
\sphinxAtStartPar
ACK —— 应答消息，对应的是CON消息的应答。

\item {} 
\sphinxAtStartPar
RST —— 复位消息，可靠传输时候接收的消息不认识或错误时，不能回ACK消息，必须回RST消息。

\end{enumerate}


\subsubsection{Coap消息格式}
\label{\detokenize{exp-esp32/coap:id4}}
\sphinxAtStartPar
CoAP的消息格式是很紧凑的，默认运行在UDP上（每个CoAP消息都是UDP数据包中的数据部分）。
CoAP也可以运行在DTLS协议上和其它传输协议上，例如SMS，TCP或SCTP（CoAP不支持UDP\sphinxhyphen{}lite{[}RFC3828{]}和UDP zero checksum{[}RFC6936{]}）。

\sphinxAtStartPar
CoAP消息用二进制格式进行编码。 这个消息格式以一个固定4个字节的头部开始。
此后是一个长度在0到8字节之间的Token。Token值之后是0个或多个Type\sphinxhyphen{}Length\sphinxhyphen{}Value(TLV)格式的选项(Option)。之后到整个数据报的结尾都是payload部分，payload可以为空。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220808103353815}.png}


\subsection{CoAP Client 示例}
\label{\detokenize{exp-esp32/coap:coap-client}}
\sphinxAtStartPar
这个 CoAP 客户端示例是对 libcoap示例之一的非常简化的改编。

\sphinxAtStartPar
CoAP 客户端示例将您的 ESP32 设备连接到 CoAP 服务器，发送 GET 请求并从 CoAP 服务器获取响应数据。客户端可以扩展为 PUT / POST / DELETE 请求，以及支持观察者扩展RFC7641。

\sphinxAtStartPar
如果 URI 以 coaps:// 而不是 coap:// 为前缀，则 CoAP 客户端将尝试使用 CoAP 服务器所需的定义的预共享密钥 (PSK) 或公钥基础设施 (PKI) 使用 DTLS 协议要知道。

\sphinxAtStartPar
如果 URI 以 coap+tcp:// 为前缀，则 CoAP 将尝试使用 TCP 进行通信。

\sphinxAtStartPar
注意：目前不支持 coaps+tcp://，即使 libcoap 和 MbedTLS 都支持它。

\sphinxAtStartPar
受限应用协议 (CoAP) 是一种专门的 Web 传输协议，用于物联网中的受限节点和受限网络。
该协议专为智能能源和大厦自动化等机器对机器 (M2M) 应用而设计。


\subsubsection{配置项目}
\label{\detokenize{exp-esp32/coap:id5}}
\sphinxAtStartPar
命令行界面

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} /示例对应的目录
get\PYGZhy{}idf
idf.py menuconfig
\end{sphinxVerbatim}

\sphinxAtStartPar
Clion界面

\sphinxAtStartPar
选择示例的文件夹并用Clion打开

\sphinxAtStartPar
添加各项配置（参考Clion下ESP\sphinxhyphen{}IDF的配置与开发）

\sphinxAtStartPar
选择 menuconfig 并运行

\sphinxAtStartPar
Example Connection Configuration —>
\begin{itemize}
\item {} 
\sphinxAtStartPar
在 Example Configuration 下设置 WiFi SSID

\item {} 
\sphinxAtStartPar
在 Example Configuration Example  CoAP Client Configuration —>下设置 WiFi 密码

\item {} 
\sphinxAtStartPar
设置 CoAP 目标 Uri

\item {} 
\sphinxAtStartPar
如果是 PSK，设置 CoAP 预共享密钥以用于连接到服务器

\item {} 
\sphinxAtStartPar
如果是 PSK，设置 CoAP PSK 客户端身份（用户名） Component config —> CoAP Configuration —>
\begin{itemize}
\item {} 
\sphinxAtStartPar
设置加密方法定义，PSK（默认）或 PKI

\item {} 
\sphinxAtStartPar
如果需要，启用 CoAP 调试高分辨率计时器 (esp\_timer) —>

\item {} 
\sphinxAtStartPar
用于 esp\_timer 的硬件定时器 \sphinxhyphen{} 如果需要可更改（QEMU 的 FRC2）

\end{itemize}

\end{itemize}


\subsubsection{构建和烧录}
\label{\detokenize{exp-esp32/coap:id6}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：

\sphinxAtStartPar
命令行界面：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
idf.py \PYGZhy{}p PORT flash monitor
\end{sphinxVerbatim}

\sphinxAtStartPar
（要退出串行监视器，请键入Ctrl\sphinxhyphen{}{]}。）

\sphinxAtStartPar
Clion界面：

\sphinxAtStartPar
选择 flash 并运行

\sphinxAtStartPar
选择 monitor 并运行


\subsubsection{示例输出}
\label{\detokenize{exp-esp32/coap:id7}}
\sphinxAtStartPar
前提条件：我们在coap server example上启动一个CoAP server，或者使用默认的coap://californium.eclipseprojects.io。

\sphinxAtStartPar
如果成功，您可以从 CoAP 服务器接收数据，
例如以下日志：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
b...
I \PYG{o}{(}\PYG{l+m}{332}\PYG{o}{)} wifi: mode : sta \PYG{o}{(}\PYG{l+m}{30}:ae:a4:04:1b:7c\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{1672}\PYG{o}{)} wifi: n:11 \PYG{l+m}{0}, o:1 \PYG{l+m}{0}, ap:255 \PYG{l+m}{255}, sta:11 \PYG{l+m}{0}, prof:1
I \PYG{o}{(}\PYG{l+m}{1672}\PYG{o}{)} wifi: state: init \PYGZhy{}\PYGZgt{} auth \PYG{o}{(}b0\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{1682}\PYG{o}{)} wifi: state: auth \PYGZhy{}\PYGZgt{} assoc \PYG{o}{(}\PYG{l+m}{0}\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{1692}\PYG{o}{)} wifi: state: assoc \PYGZhy{}\PYGZgt{} run \PYG{o}{(}\PYG{l+m}{10}\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{1692}\PYG{o}{)} wifi: connected with huawei\PYGZus{}cw, channel \PYG{l+m}{11}
I \PYG{o}{(}\PYG{l+m}{1692}\PYG{o}{)} wifi: pm start, type: \PYG{l+m}{1}

I \PYG{o}{(}\PYG{l+m}{2582}\PYG{o}{)} event: sta ip: \PYG{l+m}{192}.168.3.89, mask: \PYG{l+m}{255}.255.255.0, gw: \PYG{l+m}{192}.168.3.1
I \PYG{o}{(}\PYG{l+m}{2582}\PYG{o}{)} CoAP\PYGZus{}client: Connected to AP
I \PYG{o}{(}\PYG{l+m}{2582}\PYG{o}{)} CoAP\PYGZus{}client: DNS lookup succeeded. \PYG{n+nv}{IP}\PYG{o}{=}\PYG{l+m}{35}.185.40.182
Received:

****************************************************************

CoAP RFC \PYG{l+m}{7252}                                  Cf \PYG{l+m}{3}.0.0\PYGZhy{}SNAPSHOT

****************************************************************

This server is using the Eclipse Californium \PYG{o}{(}Cf\PYG{o}{)} CoAP framework
published under EPL+EDL: http://www.eclipse.org/californium/

\PYG{o}{(}c\PYG{o}{)} \PYG{l+m}{2014}\PYGZhy{}2020 Institute \PYG{k}{for} Pervasive Computing, ETH Zurich and others

****************************************************************
...
\end{sphinxVerbatim}


\subsubsection{libcoap 文档}
\label{\detokenize{exp-esp32/coap:libcoap}}
\sphinxAtStartPar
这可以在libcoap 文档中找到。当前的 API 是 4.3.0。

\sphinxAtStartPar
https://libcoap.net/documentation.html


\subsubsection{故障排除}
\label{\detokenize{exp-esp32/coap:id8}}
\sphinxAtStartPar
请确保 Target Url 包含 valid host、 optional port、 optionalpath和以 开头coap://，coaps://或者coap+tcp:// 对于支持 TCP 的 coap 服务器（并非所有都包括 coap+tcp://californium.eclipseprojects.io）。

\sphinxAtStartPar
可以通过运行“idf.py menuconfig \sphinxhyphen{}> Component config \sphinxhyphen{}> CoAP Configuration”并设置适当的日志级别来启用 CoAP 日志记录。


\subsection{CoAP Server示例}
\label{\detokenize{exp-esp32/coap:coap-server}}
\sphinxAtStartPar
这个 CoAP 服务器示例是对libcoap 示例 之一的非常简化的改编 。

\sphinxAtStartPar
CoAP 服务器示例将启动一个守护任务，从 CoAP 客户端接收请求/数据并将数据传输到 CoAP 客户端。

\sphinxAtStartPar
如果传入的请求请求使用 DTLS（连接到端口 5684），则 CoAP 服务器将尝试使用先前定义的预共享密钥 (PSK) 建立 DTLS 会话 \sphinxhyphen{} 这必须与 CoAP 的相同客户端正在使用，或公钥基础设施 (PKI)，其中 PKI 信息必须按请求匹配。

\sphinxAtStartPar
注意：当前不支持尝试使用 coaps+tcp:// 的客户端会话，即使 libcoap 和 MbedTLS 都支持它。

\sphinxAtStartPar
受限应用协议 (CoAP) 是一种专门的 Web 传输协议，用于物联网中的受限节点和受限网络。
该协议专为智能能源和大厦自动化等机器对机器 (M2M) 应用而设计。


\subsubsection{配置项目}
\label{\detokenize{exp-esp32/coap:id9}}
\sphinxAtStartPar
命令行界面

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} /示例对应的目录
get\PYGZhy{}idf
idf.py menuconfig
\end{sphinxVerbatim}

\sphinxAtStartPar
Clion界面

\sphinxAtStartPar
选择示例的文件夹并用Clion打开

\sphinxAtStartPar
添加各项配置（参考Clion下ESP\sphinxhyphen{}IDF的配置与开发）

\sphinxAtStartPar
选择 menuconfig 并运行

\sphinxAtStartPar
Example Connection Configuration —>
\begin{itemize}
\item {} 
\sphinxAtStartPar
在 Example Configuration 下设置 WiFi SSID

\item {} 
\sphinxAtStartPar
在 Example Configuration Example  CoAP Client Configuration —>下设置 WiFi 密码

\item {} 
\sphinxAtStartPar
设置 CoAP 目标 Uri

\item {} 
\sphinxAtStartPar
如果是 PSK，设置 CoAP 预共享密钥以用于连接到服务器

\item {} 
\sphinxAtStartPar
如果是 PSK，设置 CoAP PSK 客户端身份（用户名） Component config —> CoAP Configuration —>
\begin{itemize}
\item {} 
\sphinxAtStartPar
设置加密方法定义，PSK（默认）或 PKI

\item {} 
\sphinxAtStartPar
如果需要，启用 CoAP 调试高分辨率计时器 (esp\_timer) —>

\item {} 
\sphinxAtStartPar
用于 esp\_timer 的硬件定时器 \sphinxhyphen{} 如果需要可更改（QEMU 的 FRC2）

\end{itemize}

\end{itemize}


\subsubsection{构建和烧录}
\label{\detokenize{exp-esp32/coap:id10}}
\sphinxAtStartPar
构建项目并将其烧写到板上，然后运行监控工具查看串行输出：

\sphinxAtStartPar
命令行界面：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
idf.py \PYGZhy{}p PORT flash monitor
\end{sphinxVerbatim}

\sphinxAtStartPar
（要退出串行监视器，请键入Ctrl\sphinxhyphen{}{]}。）

\sphinxAtStartPar
Clion界面：

\sphinxAtStartPar
选择 flash 并运行

\sphinxAtStartPar
选择 monitor 并运行


\subsubsection{示例输出}
\label{\detokenize{exp-esp32/coap:id11}}
\sphinxAtStartPar
当前的 CoAP 服务器会启动一个 daemon 任务，
日志如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
...
I \PYG{o}{(}\PYG{l+m}{332}\PYG{o}{)} wifi: mode : sta \PYG{o}{(}\PYG{l+m}{30}:ae:a4:04:1b:7c\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{1672}\PYG{o}{)} wifi: n:11 \PYG{l+m}{0}, o:1 \PYG{l+m}{0}, ap:255 \PYG{l+m}{255}, sta:11 \PYG{l+m}{0}, prof:1
I \PYG{o}{(}\PYG{l+m}{1672}\PYG{o}{)} wifi: state: init \PYGZhy{}\PYGZgt{} auth \PYG{o}{(}b0\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{1682}\PYG{o}{)} wifi: state: auth \PYGZhy{}\PYGZgt{} assoc \PYG{o}{(}\PYG{l+m}{0}\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{1692}\PYG{o}{)} wifi: state: assoc \PYGZhy{}\PYGZgt{} run \PYG{o}{(}\PYG{l+m}{10}\PYG{o}{)}
I \PYG{o}{(}\PYG{l+m}{1692}\PYG{o}{)} wifi: connected with huawei\PYGZus{}cw, channel \PYG{l+m}{11}
I \PYG{o}{(}\PYG{l+m}{1692}\PYG{o}{)} wifi: pm start, type: \PYG{l+m}{1}

I \PYG{o}{(}\PYG{l+m}{2622}\PYG{o}{)} event: sta ip: \PYG{l+m}{192}.168.3.84, mask: \PYG{l+m}{255}.255.255.0, gw: \PYG{l+m}{192}.168.3.1
I \PYG{o}{(}\PYG{l+m}{2622}\PYG{o}{)} CoAP\PYGZus{}server: Connected to AP
...
\end{sphinxVerbatim}

\sphinxAtStartPar
如果 CoAP 客户端查询/Espressif资源，CoAP 服务器将返回”Hello World!”
，直到 CoAP 客户端使用不同的数据执行 PUT。


\subsubsection{libcoap 文档}
\label{\detokenize{exp-esp32/coap:id12}}
\sphinxAtStartPar
这可以在libcoap 文档中找到。当前的 API 是 4.3.0。

\sphinxAtStartPar
https://libcoap.net/documentation.html


\subsubsection{故障排除}
\label{\detokenize{exp-esp32/coap:id13}}
\sphinxAtStartPar
请确保 CoAP 客户端在 path:/Espressif或fetches 下获取或放置数据/.well\sphinxhyphen{}known/core

\sphinxAtStartPar
可以通过运行“idf.py menuconfig \sphinxhyphen{}> Component config \sphinxhyphen{}> CoAP Configuration”并设置适当的日志级别来启用 CoAP 日志记录

\sphinxstepscope


\section{接入IoT 云平台 ThingsBoard}
\label{\detokenize{exp-esp32/iot-cloud:iot-thingsboard}}\label{\detokenize{exp-esp32/iot-cloud::doc}}
\sphinxAtStartPar
一般而言，IoT设备接入到云平台，IoT设备接入到云平台进行管理有以下几个重要原因：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
集中管理和监控：通过将设备接入云平台，可以实现对大量设备的集中管理和监控。云平台提供了统一的管理界面和工具，使用户能够轻松管理设备的注册、配置、升级和故障排查等操作。同时，云平台还能够提供实时监控和告警功能，帮助用户及时发现设备异常和故障。

\item {} 
\sphinxAtStartPar
数据收集和存储：云平台提供了可靠的数据收集和存储机制，能够有效地收集来自各个设备的数据。通过将设备数据存储在云平台中，用户可以随时访问和查询设备数据，进行数据分析、业务决策和优化。

\item {} 
\sphinxAtStartPar
远程维护和更新：通过云平台管理设备，用户可以远程进行设备的维护和更新。无需亲临设备现场，用户可以通过云平台进行远程配置、固件升级和故障排查等操作，提高设备的运维效率和灵活性。

\item {} 
\sphinxAtStartPar
数据分析和智能决策：云平台具备强大的数据分析和智能决策能力，能够对设备数据进行实时分析和挖掘。通过对设备数据的深入分析，用户可以获得洞察力和业务价值，优化设备性能、提高生产效率和降低成本。

\item {} 
\sphinxAtStartPar
安全和权限控制：云平台提供了安全和权限控制机制，保护设备数据和系统的安全。通过设备接入云平台，可以进行身份验证、访问控制和数据加密等安全措施，防止未经授权的访问和数据泄露。

\end{enumerate}

\sphinxAtStartPar
综上，将IoT设备接入到云平台进行管理能够提升设备的运维效率、数据的价值和系统的安全性。云平台提供了集中管理、实时监控、数据存储和分析等功能，帮助用户更好地管理和利用设备数据，推动业务创新和增长。

\sphinxAtStartPar
\sphinxstylestrong{本手册实验采用开源IoT云平台ThingsBoard。其他平台，同学们可以自行实验。}


\subsection{ThingsBoard简介}
\label{\detokenize{exp-esp32/iot-cloud:thingsboard}}
\sphinxAtStartPar
ThingsBoard是一个开源的物联网平台，旨在帮助用户快速搭建和扩展物联网解决方案。它提供了丰富的功能和工具，用于设备管理、数据收集、实时监控、数据分析和可视化等方面。

\sphinxAtStartPar
以下是ThingsBoard的主要特点和功能：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
设备管理：ThingsBoard提供了设备注册、认证和管理的功能。用户可以轻松地添加、配置和监控物联网设备，并对设备进行远程操作和管理。

\item {} 
\sphinxAtStartPar
数据收集与存储：ThingsBoard支持从设备中收集传感器数据、遥测数据和事件数据。它提供了灵活的API和协议支持，包括MQTT、CoAP、HTTP等，以便与各种类型的设备进行通信。收集的数据可以存储在数据库中，并进行后续的查询和分析。

\item {} 
\sphinxAtStartPar
实时监控和控制：ThingsBoard提供了实时监控和控制设备的功能。用户可以通过仪表盘和控制面板实时查看设备数据、状态和报警信息，并对设备进行远程控制操作。

\item {} 
\sphinxAtStartPar
数据分析和规则引擎：ThingsBoard内置了强大的数据分析和规则引擎。用户可以定义规则和条件来实时处理和分析设备数据，并触发特定的操作和通知。

\item {} 
\sphinxAtStartPar
可视化和报表：ThingsBoard提供了可视化工具和报表功能，用于将设备数据转化为图表、图形和仪表盘展示。用户可以根据需要创建自定义的可视化界面，以便更好地理解和分析数据。

\item {} 
\sphinxAtStartPar
可扩展性：ThingsBoard具有良好的可扩展性，支持分布式部署和集群模式。它可以在水平和垂直方向上扩展以适应不断增长的设备和数据量。

\item {} 
\sphinxAtStartPar
开源和社区支持：ThingsBoard是开源的，基于Java和JavaScript技术栈开发。它拥有一个活跃的社区，提供了丰富的文档、教程和支持资源。

\end{enumerate}

\sphinxAtStartPar
ThingsBoard的灵活性和丰富的功能使其成为构建物联网解决方案的理想选择。它适用于各种行业和应用场景，包括智能城市、工业自动化、农业、能源管理等。


\subsection{实验内容}
\label{\detokenize{exp-esp32/iot-cloud:id1}}
\sphinxAtStartPar
在TB云平在中管理设备和用户


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
ThingsBoard UI
&\sphinxstyletheadfamily 
\sphinxAtStartPar
http://8.134.62.44:8080
\\
\hline
\sphinxAtStartPar
ACCOUNT
&
\sphinxAtStartPar
iot@gdpu.edu.cn
\\
\hline
\sphinxAtStartPar
Password
&
\sphinxAtStartPar
iot@Tb3721
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{创建设备}
\label{\detokenize{exp-esp32/iot-cloud:id2}}
\sphinxAtStartPar
\sphinxhref{https://thingsboard.io/docs/getting-started-guides/helloworld/}{参考}


\subsubsection{管理设备}
\label{\detokenize{exp-esp32/iot-cloud:id3}}
\sphinxAtStartPar
\sphinxhref{https://thingsboard.io/docs/reference/mqtt-api/}{API参考}


\paragraph{发布遥测数据}
\label{\detokenize{exp-esp32/iot-cloud:id4}}\begin{quote}

\sphinxAtStartPar
参考MQTT节的代码实现
\end{quote}


\paragraph{发布设备属性}
\label{\detokenize{exp-esp32/iot-cloud:id5}}

\paragraph{订阅设备属性}
\label{\detokenize{exp-esp32/iot-cloud:id6}}
\sphinxstepscope


\chapter{LoRa实验篇}
\label{\detokenize{exp-lora/index:lora}}\label{\detokenize{exp-lora/index::doc}}
\sphinxAtStartPar
本章实验包含如下几个部分：

\sphinxstepscope


\section{LoRa AT指令操作}
\label{\detokenize{exp-lora/at-command:lora-at}}\label{\detokenize{exp-lora/at-command::doc}}
\sphinxAtStartPar
目前的 AT （Attention）指令着重应用在蜂窝模块（NB\sphinxhyphen{}IOT、2G/3G/4G等）、WiFi 模块、BLE 模块、LoRa模块中，目的是为了简化嵌入式设备联网的复杂度。

\sphinxAtStartPar
实验箱上的LoRa模块（RAK3172模块）集成了STM32WLE5CC MCU芯片，是专为简化LoRaWAN和LoRa® P2P（点对点）通信而设计的设备。使用UART接口发送AT命令，可轻松完成模块配置，将LoRa技术集成到项目中。可通过AT命令配置LoRa P2P和LoRaWAN通信所需的参数。也可以使用任何带有UART接口的微控制器来配置RAK3172模块。本章节我们将利用RAK3172模块来初步了解如何使用AT指令。参考链接:link: \sphinxhref{https://docs.rakwireless.com.cn/Product-Categories/WisDuo/RAK3172-Module/Overview/}{RAK3172 WisDuo LPWAN模块}


\subsection{实验目的}
\label{\detokenize{exp-lora/at-command:id1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
了解实验箱上的RAK3172模块

\item {} 
\sphinxAtStartPar
学习AT指令的使用

\end{itemize}


\subsection{准备工作}
\label{\detokenize{exp-lora/at-command:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
ubuntu系统中安装CoolTerm和ch340驱动

\item {} 
\sphinxAtStartPar
初步了解AT指令语法

\end{itemize}
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
命令输入：命令以 “AT”开头， 以（即\textbackslash{}r\textbackslash{}n）结束，本文中的命令介绍都省略了“\textbackslash{}r\textbackslash{}n”。AT命令的标准格式“AT+XXX”，其中”XXX”表示命令。

\sphinxAtStartPar
\sphinxstylestrong{四种可用的命令操作：}

\sphinxAtStartPar
AT+XXX?，结尾为“?”，用于获取XXX命令的帮助，例如\sphinxstylestrong{AT+DEVEUI？}

\sphinxAtStartPar
AT+XXX，结尾没有“?”、“=?”和“”，执行命令，例如\sphinxstylestrong{ATZ}

\sphinxAtStartPar
AT+XXX=?，结尾为“=?”，获取XXX命令的取值，例如\sphinxstylestrong{AT+CFS=?}

\sphinxAtStartPar
AT+XXX=与，结尾为，用于给XXX命令赋值，例如\sphinxstylestrong{AT+SEND=2:Hello}

\item {} 
\sphinxAtStartPar
命令应答：命令输出通过UART端口返回。返回格式分为两部分：返回值和状态返回码。

\sphinxAtStartPar


\sphinxAtStartPar


\sphinxAtStartPar
:exclamation:注意：代表“回车”，代表“换行”
\begin{itemize}
\item {} 
\sphinxAtStartPar
运行 “AT+XXX?”或“AT+XXX=?” 命令时，将返回和。“AT+XXX”和“AT+XXX=”命令，没有返回值，只返回状态返回码。

\item {} 
\sphinxAtStartPar
每个命令(除了用于MCU复位的ATZ命令)都会返回一个状态字符串，格式为前后都是的。可能的状态:

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220929094848388}.png}

\end{enumerate}

\sphinxAtStartPar
关于AT指令的介绍到此为止，更详细的说明请参考RAK文档:link: \sphinxhref{https://docs.rakwireless.com.cn/Product-Categories/WisDuo/RAK3172-Module/Overview/}{RAK3172 WisDuo LPWAN模块}
\end{quote}


\subsubsection{硬件}
\label{\detokenize{exp-lora/at-command:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
LoRa模块

\item {} 
\sphinxAtStartPar
USB 数据线

\end{itemize}


\subsubsection{软件}
\label{\detokenize{exp-lora/at-command:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
CoolTerm

\end{itemize}


\subsection{相关电路原理}
\label{\detokenize{exp-lora/at-command:id5}}
\sphinxAtStartPar
实验所用的LoRa模块上有两个串口，串口1有USB转TTL芯片（ch340），可以用usb线直接与电脑连接进行通信，串口2用于与其他带有UART接口的微控制器来配置RAK3172模块。


\subsection{实验步骤}
\label{\detokenize{exp-lora/at-command:id6}}\begin{itemize}
\item {} 
\sphinxAtStartPar
通过USB接口与电脑通信，注意跳线帽的接法

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220929092849979}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
CoolTerm的设置，Port号可能不一样，根据实际情况进行设置，波特率为115200

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220929093506009}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220929093601507}.png}
\begin{quote}

\sphinxAtStartPar
:exclamation:注意：在官方Linux内核版本中自Kernel2.6就默认包含了对USB转串口芯片CH340/CH341/CH9341/CH343芯片的驱动支持，其驱动所在位置：/lib/modules/5.15.0\sphinxhyphen{}46\sphinxhyphen{}generic/kernel/drivers/usb/serial，但并没有设置成开机加载，所以需要先加载CH340串口驱动。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo modprobe ch341
\end{sphinxVerbatim}

\sphinxAtStartPar
然后查看系统工作情况。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
dmesg
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220929160127345}.png}

\sphinxAtStartPar
可以看到ch340驱动加载成功
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
选择ttyUSB0，点击\sphinxstylestrong{Connect}，不出意外的话会提示error，原因是使用USB端口时需要权限，普通用户没有权限，需要设置ttyUSB0的权限，但这样子会在电脑重启后又恢复系统默认的权限，还要重新设置，永久解决方法请自行百度了解。

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo chmod \PYG{l+m}{777} /dev/ttyUSB0
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220929161041170}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
发送AT指令

\end{itemize}

\sphinxAtStartPar
在下面的输入框中输入AT指令，不用带\textbackslash{}r\textbackslash{}n，因为设置里面默认发送时自动加上\textbackslash{}r\textbackslash{}n，

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220929225100483}.png}

\sphinxAtStartPar
该命令将返回LoRa模块的固件版本，如图为RUI\_3.4.11\_RAK3172\sphinxhyphen{}E，OK为状态返回码，命令运行正确，无错误就会返回OK。

\sphinxAtStartPar
\sphinxincludegraphics{{image-20220929225128724}.png}


\subsection{常用AT指令}
\label{\detokenize{exp-lora/at-command:at}}
\sphinxAtStartPar
AT指令有很多，接下来列举在使用RAK3172模块时，常用的AT指令。
\begin{quote}

\sphinxAtStartPar
AT+VER：固件版本，此命令允许用户访问固件的版本。

\sphinxAtStartPar
AT+NJM：LoRa网络加入模式，此命令允许用户访问和配置网络加入模式。

\sphinxAtStartPar
AT+BAND：区域频段，此命令用于访问和配置区域频段。

\sphinxAtStartPar
AT+MASK：设置信道掩码，打开或关闭信道，此命令通过设置十六进制信道掩码来配置设备的信道。

\sphinxAtStartPar
AT+CLASS：LoRaWAN®节点工作模式，此命令允许用户访问和配置LoRaWAN®节点工作模式。

\sphinxAtStartPar
AT+DEVEUI：设备EUI，此命令允许用户访问和配置全局终端设备ID。

\sphinxAtStartPar
AT+APPEUI：应用程序标识符，此命令允许用户访问和配置全局应用程序标识符。

\sphinxAtStartPar
AT+APPKEY：应用程序密钥，此命令允许用户访问和配置应用程序密钥。

\sphinxAtStartPar
AT+CFM：确认模式，此命令允许用户访问和配置设备的负载类型。

\sphinxAtStartPar
AT+JOIN：加入LoRa® 网络，此命令向LoRa®网络发出加入请求。

\sphinxAtStartPar
AT+SEND：发送数据，此命令提供了在专用端口号上发送数据的格式。

\sphinxAtStartPar
AT+NWM：LoRa®网络工作模式，此命令允许用户访问和配置LoRa®网络工作模式，切换到P2P或LoRaWAN，0：P2P，1：LoRaWAN。

\sphinxAtStartPar
AT+P2P：P2P参数统一配置，此命令允许用户访问和配置P2P模式所有参数。

\sphinxAtStartPar
AT+PSEND：P2P发送数据，此命令提供P2P发送数据的格式。

\sphinxAtStartPar
ATE：设置命令回显，此命令设置命令回显打开或关闭。

\sphinxAtStartPar
AT+DEVEUI：设备EUI，此命令允许用户访问和配置全局终端设备ID。

\sphinxAtStartPar
AT+NJS：LoRa® 网络加入状态，此命令允许用户访问LoRa®网络连接的当前状态。
\end{quote}

\sphinxAtStartPar
其余AT指令请参考:link: \sphinxhref{https://docs.rakwireless.com.cn/Product-Categories/WisDuo/RAK3172-Module/Overview/}{RAK3172 WisDuo LPWAN模块}

\sphinxstepscope


\section{基于STM32的LoRa节点P2P通信}
\label{\detokenize{exp-lora/p2p-stm32:stm32lorap2p}}\label{\detokenize{exp-lora/p2p-stm32::doc}}
\sphinxAtStartPar
除了前面章节演示的Lora节点直接与Lorawan网关通信的模式之外，Lora还支持P2P通信，关于LoRa的P2P模式，就是点对点传输，可以不用网关，两个节点之间就可以完成。配置P2P的参数时，不需要输入对方地址，其实原理就是在某个固定的频点上发消息，另一个人在这个频点上监听接收。

\sphinxAtStartPar
本章节将介绍如何设置和连接两个RAK3172，以在LoRa P2P模式下工作。模块的配置通过使用USB转UART来完成。每个RAK3172的设置可以单独进行，但测试LoRa P2P模式需要同时连接两个模块。在我们的实验箱中，有两个Lora模块，可以接到PC机上，打开两个串口调试助手分别设置。


\subsection{实验目的}
\label{\detokenize{exp-lora/p2p-stm32:id1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
测试LoRa的P2P模式

\end{itemize}


\subsection{实验步骤}
\label{\detokenize{exp-lora/p2p-stm32:id2}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
首先需要把模块设置为P2P模式，命令为：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AT}\PYG{o}{+}\PYG{n}{NWM}\PYG{o}{=}\PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ AT+NWM}} 参数：0=LoRa P2P，1=LoRaWAN。
\begin{quote}

\sphinxAtStartPar
注意：

\sphinxAtStartPar
如果将模式从LoRaWAN更改为LoRa P2P，设备将自动启动，反之亦然。
可能需要再次输入“ATE”命令，以确保P2P模式下的后续命令在终端上回显
\end{quote}

\item {} 
\end{enumerate}

\sphinxstepscope


\section{基于STM32的LoRaWan节点通信}
\label{\detokenize{exp-lora/lorawan-stm32:stm32lorawan}}\label{\detokenize{exp-lora/lorawan-stm32::doc}}
\sphinxAtStartPar
在LoRa AT指令操作章节中，我们使用LoRa模块上的usb接口与直接与电脑通信，但在实际应用中，通常是用另一个带串口的微控制器发送AT指令来配置RAK3172模块，两者配合工作。或者直接使用LoRa模组工作。本章节我们将学习如何使用实验箱上的STM32开发板发送AT指令配置RAK3172模块，从而完成LoRaWan节点通信实验。

\sphinxAtStartPar
为了方便理解和演示实验效果，本章节通过stm32的串口1与电脑的串口助手通信，通过串口1控制stm32的串口2与LoRa模块通信，进行AT指令配置，让LoRa模块连接上chirpstack。

\sphinxAtStartPar
通信流程如图：

\sphinxAtStartPar
\sphinxincludegraphics{{image-20230224104004544}.png}


\subsection{实验目的}
\label{\detokenize{exp-lora/lorawan-stm32:id1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
学习AT指令的使用

\item {} 
\sphinxAtStartPar
了解实验箱上的RAK3172模块

\item {} 
\sphinxAtStartPar
实现LoRa连接上chirpstack并通信

\end{itemize}


\subsection{准备工作}
\label{\detokenize{exp-lora/lorawan-stm32:id2}}

\subsubsection{硬件}
\label{\detokenize{exp-lora/lorawan-stm32:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
物联网实验箱、LoRaWan网关

\end{itemize}


\subsubsection{软件}
\label{\detokenize{exp-lora/lorawan-stm32:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Serial Port Terminal

\end{itemize}


\subsection{实验步骤}
\label{\detokenize{exp-lora/lorawan-stm32:id5}}

\subsubsection{STM32CubeMX创建工程}
\label{\detokenize{exp-lora/lorawan-stm32:stm32cubemx}}\begin{itemize}
\item {} 
\sphinxAtStartPar
配置usart1和usart2，打开中断（usart2进行同样的配置）

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{image-20230224103031152}.png}


\subsubsection{代码编写及运行结果}
\label{\detokenize{exp-lora/lorawan-stm32:id6}}\begin{itemize}
\item {} 
\sphinxAtStartPar
包含头文件，定义全局变量等

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Private includes \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* USER CODE BEGIN Includes */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}stdio.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZdq{}string.h\PYGZdq{}}
\PYG{c+cm}{/* USER CODE END Includes */}
\PYG{c+c1}{//......................................}

\PYG{c+cm}{/* Private define \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* USER CODE BEGIN PD */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define RXBUFFERSIZE  256     }\PYG{c+c1}{//最大接收字节数}
\PYG{c+cm}{/* USER CODE END PD */}

\PYG{c+cm}{/* Private macro \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}*/}
\PYG{c+cm}{/* USER CODE BEGIN PM */}
\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{Uart1\PYGZus{}RxBuffer}\PYG{p}{[}\PYG{n}{RXBUFFERSIZE}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{//接收数据}
\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{Uart1\PYGZus{}aRxBuffer}\PYG{p}{;}\PYG{+w}{			}\PYG{c+c1}{//接收中断缓冲}
\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{		}\PYG{c+c1}{//接收缓冲计数}

\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{Uart2\PYGZus{}RxBuffer}\PYG{p}{[}\PYG{n}{RXBUFFERSIZE}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{//接收数据}
\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{Uart2\PYGZus{}aRxBuffer}\PYG{p}{;}\PYG{+w}{			}\PYG{c+c1}{//接收中断缓冲}
\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{n}{Uart2\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{		}\PYG{c+c1}{//接收缓冲计数}
\PYG{c+cm}{/* USER CODE END PM */}
\PYG{c+c1}{//......................................}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
先调用一次中断接受函数

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE BEGIN 2 */}
\PYG{+w}{  }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Receive\PYGZus{}IT}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{Uart1\PYGZus{}aRxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Receive\PYGZus{}IT}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart2}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{Uart2\PYGZus{}aRxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{  }\PYG{c+cm}{/* USER CODE END 2 */}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
重定向串口中断回调函数

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* USER CODE BEGIN 4 */}
\PYG{c+c1}{//可接收不定长度的数据，以\PYGZbs{}r\PYGZbs{}n为结束位，收到的数据存在Uart1\PYGZus{}RxBuffer中}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{HAL\PYGZus{}UART\PYGZus{}RxCpltCallback}\PYG{p}{(}\PYG{n}{UART\PYGZus{}HandleTypeDef}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{huart}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+cm}{/* Prevent unused argument(s) compilation warning */}
\PYG{+w}{    }\PYG{n}{UNUSED}\PYG{p}{(}\PYG{n}{huart}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+cm}{/* NOTE: This function Should not be modified, when the callback is needed,}
\PYG{c+cm}{             the HAL\PYGZus{}UART\PYGZus{}TxCpltCallback could be implemented in the user file}
\PYG{c+cm}{     */}
\PYG{+w}{    }\PYG{c+c1}{// uart1}
\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{huart}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Instance}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{USART1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{p}{(}\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{+w}{  }\PYG{c+c1}{//溢出判断}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{memset}\PYG{p}{(}\PYG{n}{Uart1\PYGZus{}RxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0x00}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{Uart1\PYGZus{}RxBuffer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Transmit}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{数据溢出}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mh}{0xFFFF}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{else}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Uart1\PYGZus{}RxBuffer}\PYG{p}{[}\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Uart1\PYGZus{}aRxBuffer}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{//接收数据转存}
\PYG{+w}{            }\PYG{c+c1}{//0x0A 是 \PYGZbs{}r 的 ASCII码，0x0D 是 \PYGZbs{}n 的 ASCII码}
\PYG{+w}{            }\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{Uart1\PYGZus{}RxBuffer}\PYG{p}{[}\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mh}{0x0A}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{Uart1\PYGZus{}RxBuffer}\PYG{p}{[}\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mh}{0x0D}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{c+c1}{//判断结束位，以\PYGZbs{}r\PYGZbs{}n结尾为一组数据}
\PYG{+w}{            }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{c+cm}{/*}
\PYG{c+cm}{                HAL\PYGZus{}UART\PYGZus{}Transmit(\PYGZam{}huart1, (uint8\PYGZus{}t *)\PYGZam{}Uart1\PYGZus{}RxBuffer, Uart1\PYGZus{}Rx\PYGZus{}Cnt, 0xFFFF); //将收到的信息发送出去}
\PYG{c+cm}{                while(HAL\PYGZus{}UART\PYGZus{}GetState(\PYGZam{}huart1) == HAL\PYGZus{}UART\PYGZus{}STATE\PYGZus{}BUSY\PYGZus{}TX);//检测UART发送结束}
\PYG{c+cm}{                */}

\PYG{+w}{                }\PYG{c+c1}{// 将uart1接收到的内容发送给uart2}
\PYG{+w}{                }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Transmit}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart2}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{Uart1\PYGZus{}RxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0xFFFF}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//将收到的信息发送出去}
\PYG{+w}{                }\PYG{k}{while}\PYG{p}{(}\PYG{n}{HAL\PYGZus{}UART\PYGZus{}GetState}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}STATE\PYGZus{}BUSY\PYGZus{}TX}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//检测UART发送结束}

\PYG{+w}{                }\PYG{n}{Uart1\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{memset}\PYG{p}{(}\PYG{n}{Uart1\PYGZus{}RxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0x00}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{Uart1\PYGZus{}RxBuffer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//清空数组}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{c+c1}{// uart2}
\PYG{+w}{    }\PYG{k}{if}\PYG{p}{(}\PYG{n}{huart}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{Instance}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{USART2}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{p}{(}\PYG{n}{Uart2\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{+w}{  }\PYG{c+c1}{//溢出判断}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Uart2\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{memset}\PYG{p}{(}\PYG{n}{Uart2\PYGZus{}RxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0x00}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{Uart2\PYGZus{}RxBuffer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Transmit}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{数据溢出}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mh}{0xFFFF}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{else}
\PYG{+w}{        }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{Uart2\PYGZus{}RxBuffer}\PYG{p}{[}\PYG{n}{Uart2\PYGZus{}Rx\PYGZus{}Cnt}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Uart2\PYGZus{}aRxBuffer}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{//接收数据转存}
\PYG{+w}{            }\PYG{c+c1}{//0x0A 是 \PYGZbs{}r 的 ASCII码，0x0D 是 \PYGZbs{}n 的 ASCII码}
\PYG{+w}{            }\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{Uart2\PYGZus{}RxBuffer}\PYG{p}{[}\PYG{n}{Uart2\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mh}{0x0A}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{Uart2\PYGZus{}RxBuffer}\PYG{p}{[}\PYG{n}{Uart2\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mh}{0x0D}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{c+c1}{//判断结束位，以\PYGZbs{}r\PYGZbs{}n结尾为一组数据}
\PYG{+w}{            }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{c+cm}{/*}
\PYG{c+cm}{                HAL\PYGZus{}UART\PYGZus{}Transmit(\PYGZam{}huart2, (uint8\PYGZus{}t *)\PYGZam{}Uart2\PYGZus{}RxBuffer, Uart2\PYGZus{}Rx\PYGZus{}Cnt, 0xFFFF); //将收到的信息发送出去}
\PYG{c+cm}{                while(HAL\PYGZus{}UART\PYGZus{}GetState(\PYGZam{}huart2) == HAL\PYGZus{}UART\PYGZus{}STATE\PYGZus{}BUSY\PYGZus{}TX);//检测UART发送结束}
\PYG{c+cm}{                */}

\PYG{+w}{                }\PYG{c+c1}{// 将uart1接收到的内容发送给uart2}
\PYG{+w}{                }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Transmit}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{Uart2\PYGZus{}RxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{Uart2\PYGZus{}Rx\PYGZus{}Cnt}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0xFFFF}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//将收到的信息发送出去}
\PYG{+w}{                }\PYG{k}{while}\PYG{p}{(}\PYG{n}{HAL\PYGZus{}UART\PYGZus{}GetState}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}STATE\PYGZus{}BUSY\PYGZus{}TX}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//检测UART发送结束}

\PYG{+w}{                }\PYG{n}{Uart2\PYGZus{}Rx\PYGZus{}Cnt}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{memset}\PYG{p}{(}\PYG{n}{Uart2\PYGZus{}RxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mh}{0x00}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{Uart2\PYGZus{}RxBuffer}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{//清空数组}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Receive\PYGZus{}IT}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart1}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{Uart1\PYGZus{}aRxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{//再次调用中断接收函数}
\PYG{+w}{    }\PYG{n}{HAL\PYGZus{}UART\PYGZus{}Receive\PYGZus{}IT}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{huart2}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{uint8\PYGZus{}t}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{n}{Uart2\PYGZus{}aRxBuffer}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{//再次调用中断接收函数}
\PYG{p}{\PYGZcb{}}
\PYG{c+cm}{/* USER CODE END 4 */}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
实验步骤

\end{itemize}

\sphinxAtStartPar
打开串口调试助手，发送想要发送的AT指令。以下是让Lora连接上chirpstack的AT指令，具体功能和参数请到官网查询，最需要注意的是DEVEUI和APPKEY，APPEUI没用到的话，跟DEVEUI一致即可。
\begin{quote}

\sphinxAtStartPar
查询固件版本：AT+VER=?\textbackslash{}r\textbackslash{}n

\sphinxAtStartPar
配置网络加入模式，0为ABP模式，1为OTAA模式：AT+NJM=1

\sphinxAtStartPar
配置区域频段，1为CN470，中国所用的频段：AT+BAND=1

\sphinxAtStartPar
设置信道掩码：AT+MASK=0400

\sphinxAtStartPar
设置节点工作模式为A：AT+CLASS=A

\sphinxAtStartPar
配置设备EUI：AT+DEVEUI=2022060615490001

\sphinxAtStartPar
配置应用程序标识符：AT+APPEUI=2022060615490001

\sphinxAtStartPar
配置应用程序密钥：AT+APPKEY=20220606154911112222333344445555

\sphinxAtStartPar
配置确认模式：AT+CFM=1

\sphinxAtStartPar
让Lora发出加入网络请求：AT+JOIN=1:0:10:8

\sphinxAtStartPar
让Lora发送数据：AT+SEND=22:12345678
\end{quote}

\sphinxAtStartPar
每发送一条AT指令，Lora模块的返回数据都会在串口助手上显示，即可判断Lora模块是否成功接收到AT指令，或者根据返回的信息判断是否成功加入网络，发送数据等。此外，若是使能了Lora模块的命令回显功能，发送的AT指令会一起返回。
\begin{itemize}
\item {} 
\sphinxAtStartPar
本次实验到此结束，然而，在实际使用的时候，不可能这样通过人为的形式来判断AT指令是否成功发送和根据Lora的返回判断Lora模块是否成功接收AT指令，而是需要通过编写程序来实现AT指令解析的。大概的功能就是stm32发送AT指令，然后根据Lora模块的返回值来判断Lora模块是否正确地接受到AT指令，在传输数据量比较大的时候，更是需要合理编写串口收发程序，避免溢出和错误，这方面的内容将在以后的章节讲解。

\end{itemize}

\sphinxstepscope


\section{基于ESP32的LoRa节点P2P通信}
\label{\detokenize{exp-lora/p2p-esp32:esp32lorap2p}}\label{\detokenize{exp-lora/p2p-esp32::doc}}
\sphinxstepscope


\section{基于ESP32的LoRaWan节点通信}
\label{\detokenize{exp-lora/lorawan-esp32:esp32lorawan}}\label{\detokenize{exp-lora/lorawan-esp32::doc}}

\subsection{实验目的}
\label{\detokenize{exp-lora/lorawan-esp32:id1}}\begin{itemize}
\item {} 
\sphinxAtStartPar
lora节点与lorawan网关之间的通信

\item {} 
\sphinxAtStartPar
chirpstack平台管理与应用

\item {} 
\sphinxAtStartPar
chirpstack与thingsboard集成

\end{itemize}


\subsection{实验方案}
\label{\detokenize{exp-lora/lorawan-esp32:id2}}

\subsubsection{所需软硬件}
\label{\detokenize{exp-lora/lorawan-esp32:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
lora节点：ESP32+ RAK3172

\item {} 
\sphinxAtStartPar
LORA 网关： RaspberryPi4 + RAK2275 + Chirpstack Gateway Bridge

\item {} 
\sphinxAtStartPar
Chirpstack 平台

\end{itemize}


\subsubsection{网络方案}
\label{\detokenize{exp-lora/lorawan-esp32:id4}}
\sphinxAtStartPar
\sphinxincludegraphics{{lorawan-chirpstack}.png}


\subsection{chirpstack}
\label{\detokenize{exp-lora/lorawan-esp32:chirpstack}}
\sphinxAtStartPar
ChirpStack 是一个开源的物联网 (IoT) 应用和设备管理平台，旨在简化和加强物联网解决方案的开发和管理。它提供了一个端到端的解决方案，包括设备管理、应用程序开发、数据管理和集成。

\sphinxAtStartPar
ChirpStack 通过使用 LoRaWAN® 网络协议来连接和管理物联网设备。LoRaWAN 是一种低功耗、长距离无线通信协议，非常适用于物联网应用。ChirpStack 支持与多种 LoRaWAN 网络服务器进行集成，例如 Semtech 的 LoRa Server 和其他兼容的网络服务器。

\sphinxAtStartPar
ChirpStack 提供了一套功能强大的工具和界面，帮助开发者管理物联网设备。它包括以下主要组件：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
网关管理器 (Gateway Bridge)：用于与物联网网关进行通信，接收从设备发送的数据，并将其传递给网络服务器。

\item {} 
\sphinxAtStartPar
网络服务器 (Network Server)：处理从设备和网关收到的数据，并负责验证和解析数据包。它还提供设备管理、设备活动监控和安全认证等功能。

\item {} 
\sphinxAtStartPar
应用服务器 (Application Server)：提供应用程序开发和集成的功能。它可以接收从设备发送的数据，并根据开发者定义的规则进行处理、存储和转发数据。开发者可以使用应用服务器来构建自定义的 IoT 应用程序和集成其他系统。

\item {} 
\sphinxAtStartPar
用户界面 (User Interface)：ChirpStack 提供了一个用户友好的界面，用于管理设备、应用程序和网络服务器的各个方面。开发者可以使用界面来监控设备的状态、配置应用程序和进行故障排除。

\end{enumerate}

\sphinxAtStartPar
ChirpStack 的开源性质使得开发者可以自由地定制和扩展平台的功能，以满足特定的物联网解决方案需求。它支持多种操作系统和硬件平台，使得部署和集成变得更加灵活和可靠。

\sphinxAtStartPar
总而言之，ChirpStack 是一个功能强大的开源物联网平台，通过集成 LoRaWAN 网络协议，提供了完整的设备管理、应用程序开发和数据管理解决方案，帮助开发者构建可靠和可扩展的物联网应用。


\subsection{实验步骤}
\label{\detokenize{exp-lora/lorawan-esp32:id5}}
\sphinxAtStartPar
chirpstack地址：http://8.134.62.44:8081


\subsubsection{添加网关}
\label{\detokenize{exp-lora/lorawan-esp32:id6}}
\sphinxAtStartPar
进入到chirpstack UI ，然后：
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Gateways|Add gateway}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
name

\item {} 
\sphinxAtStartPar
Gateway ID (如何获取 Gateway ID)

\item {} 
\sphinxAtStartPar
Submit

\end{itemize}
\end{quote}


\subsubsection{添加设备描述}
\label{\detokenize{exp-lora/lorawan-esp32:id7}}
\sphinxAtStartPar
进入到\sphinxhref{http://8.134.62.44:8081}{chirpstack UI} ，然后：
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Device profiles | Add device profile}} ，填写入下内容：
\begin{itemize}
\item {} 
\sphinxAtStartPar
Name

\item {} 
\sphinxAtStartPar
Regin：CN470

\item {} 
\sphinxAtStartPar
MAC Version：LoraWan 1.0.3

\item {} 
\sphinxAtStartPar
Regional parameters revision: A

\item {} 
\sphinxAtStartPar
ADR algorithm: Default

\end{itemize}

\item {} 
\sphinxAtStartPar
Submit

\end{itemize}


\subsubsection{添加应用}
\label{\detokenize{exp-lora/lorawan-esp32:id8}}
\sphinxAtStartPar
进入到\sphinxhref{http://8.134.62.44:8081}{chirpstack UI} ，然后：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Applications | Add application}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
name

\item {} 
\sphinxAtStartPar
Description

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Submit}}

\end{enumerate}


\subsubsection{在应用中添加设备}
\label{\detokenize{exp-lora/lorawan-esp32:id9}}
\sphinxAtStartPar
进入到\sphinxhref{http://8.134.62.44:8081}{chirpstack UI} ，然后：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Application|「选择应用」|Add device|}}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
填写你的设备

\item {} 
\sphinxAtStartPar
填写Device EUI ,由\sphinxcode{\sphinxupquote{at+deveui=?}}获取。

\item {} 
\sphinxAtStartPar
选择已经设置好的Device profile

\item {} 
\sphinxAtStartPar
submit

\item {} 
\sphinxAtStartPar
填写 \sphinxcode{\sphinxupquote{application key}}，由 \sphinxcode{\sphinxupquote{at+appkey=?}} 获取

\end{enumerate}

\item {} 
\sphinxAtStartPar
加入Lorawan网络
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{at+join}}

\end{enumerate}

\item {} 
\sphinxAtStartPar
发送数据
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{at+send=}}

\item {} 
\sphinxAtStartPar
例如：\sphinxcode{\sphinxupquote{at+send=25:018806765ff2960a0003e8}}

\end{enumerate}

\item {} 
\sphinxAtStartPar
接受数据

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{at+recv=?}}

\item {} 
\sphinxAtStartPar
编码实现以上 join，send，receive过程。

\end{enumerate}


\subsubsection{集成到ThingsBoard}
\label{\detokenize{exp-lora/lorawan-esp32:thingsboard}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
进入thingsboard\sphinxhref{http://8.134.62.44:8080}{管理页面}，添加设备，命名与上面在chirpstack的命名一致

\item {} 
\sphinxAtStartPar
获取该设备的访问令牌，即TOCKEN。

\item {} 
\sphinxAtStartPar
返回到\sphinxhref{http://8.134.62.44:8081}{chirpstack管理页面}，添加应用集成
\begin{itemize}
\item {} 
\sphinxAtStartPar
进入菜单 \sphinxcode{\sphinxupquote{Applications | {[}设备所在的应用名称{]} | Integrations}}，找到Thingsboard，

\item {} 
\sphinxAtStartPar
填写ThingsBoard server 为：http://8.134.62.44:8080

\end{itemize}

\item {} 
\sphinxAtStartPar
在\sphinxhref{http://8.134.62.44:8081}{chirpstack管理页面}，添加上述设备访问令牌
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
进入相应的设备页面

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Configuration | Variables | + add Variables}}

\item {} 
\sphinxAtStartPar
填写如下键值对：
\begin{itemize}
\item {} 
\sphinxAtStartPar
key:	ThingsBoardAccessToken

\item {} 
\sphinxAtStartPar
Value: 刚才在thingsboard中复制的访问令牌

\end{itemize}

\end{enumerate}

\item {} 
\sphinxAtStartPar
设置完成后，发送数据，在thingsboard设备的最新遥测数据中可观察到刚才发送的数据

\end{enumerate}

\sphinxstepscope


\chapter{提高篇\sphinxhyphen{} Mesh 网络与人工智能}
\label{\detokenize{exp-advanced/index:mesh}}\label{\detokenize{exp-advanced/index::doc}}
\sphinxAtStartPar
本章实验目前仅限于ESP32的视线，包含如下几个部分：

\sphinxstepscope


\section{WiFi Mesh 网}
\label{\detokenize{exp-advanced/wifi-mesh:wifi-mesh}}\label{\detokenize{exp-advanced/wifi-mesh::doc}}
\sphinxstepscope


\section{BLE Mesh \sphinxhyphen{} 低功耗蓝牙Mesh网}
\label{\detokenize{exp-advanced/ble-mesh:ble-mesh-mesh}}\label{\detokenize{exp-advanced/ble-mesh::doc}}
\sphinxstepscope


\section{二维码识别}
\label{\detokenize{exp-advanced/code-recognition:id1}}\label{\detokenize{exp-advanced/code-recognition::doc}}
\sphinxstepscope


\section{AI人脸识别}
\label{\detokenize{exp-advanced/ai-face-detection:ai}}\label{\detokenize{exp-advanced/ai-face-detection::doc}}
\sphinxstepscope


\section{AI运动检测}
\label{\detokenize{exp-advanced/ai-motion-detection:ai}}\label{\detokenize{exp-advanced/ai-motion-detection::doc}}
\sphinxstepscope


\section{AI Tensor Flow Light 训练}
\label{\detokenize{exp-advanced/ai-tensor-flow-light:ai-tensor-flow-light}}\label{\detokenize{exp-advanced/ai-tensor-flow-light::doc}}
\sphinxstepscope


\chapter{源代码与参考文档}
\label{\detokenize{reference:id1}}\label{\detokenize{reference::doc}}

\section{源代码下载}
\label{\detokenize{reference:id2}}
\sphinxAtStartPar
ESP32篇源代码 \sphinxcode{\sphinxupquote{下载}}


\section{硬件参考文档}
\label{\detokenize{reference:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.espressif.com/sites/default/files/documentation/esp32\_technical\_reference\_manual\_cn.pdf}{ESP32技术参考手册}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://espressif.com/sites/default/files/documentation/esp32\_datasheet\_cn.pdf}{ESP32技术规格书}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://espressif.com/sites/default/files/documentation/esp32\_hardware\_design\_guidelines\_cn.pdf}{ESP32硬件设计指南}

\end{itemize}

\sphinxAtStartPar
更多硬件文档，请参看\sphinxhref{https://espressif.com/sites/default/files/documentation/esp32\_hardware\_design\_guidelines\_cn.pdf}{官方参考}


\section{软件参考文档}
\label{\detokenize{reference:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-guides/index.html}{API指南}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.espressif.com/projects/esp-idf/zh\_CN/latest/esp32/api-reference/index.html}{API参考}

\end{itemize}

\sphinxstepscope


\chapter{关于我们}
\label{\detokenize{about:id1}}\label{\detokenize{about::doc}}
\sphinxAtStartPar
本技术文档仅提供广东药科大学医药信息工程学院电子信息工程系物联网相关课程使用。


\section{项目贡献者名单}
\label{\detokenize{about:id2}}
\sphinxAtStartPar
（以作者姓氏笔画顺序排名）
\begin{itemize}
\item {} 
\sphinxAtStartPar
罗明雄

\item {} 
\sphinxAtStartPar
銘

\item {} 
\sphinxAtStartPar
谭文龙

\end{itemize}



\renewcommand{\indexname}{索引}
\printindex
\end{document}